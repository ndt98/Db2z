/*REXX*/
numeric digits 15
totdif_DistTcb=0
totdif_DistSrb=0
/*-------------------------------------------------------------*/
/* Extract SMF 100 records - written by Nguyen Duc Tuan        */
/*                                      ndt.db2àgmail.com      */
/* Developed and tested on DB2 V12 in Guyancourt, FRANCE       */
/*   4 jan 2016     Release 1.1                                */
/*  14 jan 2016     Release 1.2 add dsnqdst ddf stats          */
/*  11 fev 2016     Release 1.2.1 correct imprecision          */
/*                  on bp figures (numeric digits)             */
/*  25 fev 2016     Release 2.0   Ifcid225 cur. threads        */
/*                  vsm=Y   option to calculate max thread     */
/*                  possible + central storage usage           */
/*  15 Apr 2016     Release 2.1   More displays for threads    */
/*                  calculation - Verification OK with values  */
/*                  from IBM Rexx MEMU                         */
/*  20 Apr 2016     Release 2.2   More columns for storage     */
/*                  monitoring                                 */
/*  03 Jul 2016     Release 2.3   Process Data Manager Section */
/*                  (DSNDQIST macro with difference)           */
/*  06 Jul 2016     Release 2.4   Correction abend in TF=...   */
/*                  when number of tasks = 0                   */
/*                  Able to process  records from several days */
/*  29 Jul 2016     Release 2.5   Minor fixes +Logs created    */
/*  13 Oct 2016     Release 2.6   Add Q3ST stats               */
/*                  (Signon, Terminate, Create Threads ..)     */
/*                  and Datasets Stats                         */
/*  16 Dec 2016     Release 2.7   PageIns buffer Stats         */
/*  02 Mar 2017     Release 3.0   Improve Bufferpool stats     */
/*  21 Mar 2017     Release 3.1   More Bufferpools stats and   */
/*                  warning messages                           */
/*  25 Apr 2017     Release 3.2   BP memory usage in Real and  */
/*                  Auxiliary                                  */
/*  11 May 2017     DSC stats (Full Prepare, Short, ...) Locks */
/*  24 May 2017     Z/OS Stats (must activate zparm) R3.4      */
/*  16 Aug 2017     Add BP simulated stats R3.5                */
/*  11 Oct 2017     Release 3.6 Add Workfile usage stats       */
/*  02 Feb 2018     Release 3.7 Add more QISE stats (DBDsteal  */
/*  02 Mar 2018     Group Buffer Pool stats + check            */
/*  25 Sep 2018     More stats (GBP...) and correction         */
/*  15 Nov 2018     Release 3.9 Correction error on QWSAPROC   */
/*  19 May 2019     Release 4.0 More columns                   */
/*  10 Sep 2019     More alerts (Latch class ..)               */
/*  19 Dec 2019     More alerts (Autobinds, Auth Cache)        */
/*  23 Mar 2020     FTB & Inserts Algo 2 - V12 Async XI        */
/*  11 Sep 2020     Corrections                                */
/*  07 Nov 2020     Display_Detail to have details on pagein   */
/*  10 Feb 2021     Global Locks                               */
/*  11 MAr 2021     ChangeLock & Unlock - Async Global Lock (LK)*/
/*  25 May 2021     Correction bufferpools figures+ Zos stats  */
/*  25 Jan 2022     More log manager stats                     */
/*-------------------------------------------------------------*/
/*Comment : Change datasets high level identifier              */
/*-------------------------------------------------------------*/
ARG SSID hlq smforig Alert BpSim NoHead StatOnly
If NoHead  ='NOHEAD' then NoHead=1
                     else NoHead=0
If StatOnly='STATONLY' then StatOnly=1
                       else StatOnly=0
retcode=0
/* Display Warning messages (best practices)*/
if Alert ='' then Alert='Y'
/* Bufferpool simulation */
if BpSim <> 'Y' then BpSim='N'
/* Virtual storage monitoring Yes/No */
VSM='Y'
 
say ' '
say 'Processing for Subsys' ssid
 
ifcid1_seen=0
if smforig='' then smforig='A'
if smforig='A' then
do
     /* Input file : SMF extract sorted */
     oufl = hlq !! '.SMFEXTS.OUT'
     "ALLOC DD(INP) DS('"oufl"') ,
                            SHR REU bufno(20)"
end
 
/* Report dataset on output (general stats) */
oufl = "'" !! hlq !! '.reports.' !! ssid'.S01' !!  "'"
x=OUTTRAP(TMP.)
"DELETE" oufl "PURGE"
x=OUTTRAP(OFF)
 
/* Report dataset on output (BP stats) */
oufl2= "'" !! hlq !! '.reportsb.' !! ssid !!  '.CSV' !! "'"
x=OUTTRAP(TMP.)
"DELETE" oufl2 "PURGE"
x=OUTTRAP(OFF)
 
/* Report dataset on output (GBP stats) */
oufl5= "'" !! hlq !! '.reportsg.' !! ssid !! '.CSV' !! "'"
x=OUTTRAP(TMP.)
"DELETE" oufl5 "PURGE"
x=OUTTRAP(OFF)
 
/* Report dataset on output (STOR stats) */
oufl3= "'" !! hlq !! '.reportst.' !! ssid !! '.CSV' !! "'"
x=OUTTRAP(TMP.)
"DELETE" oufl3 "PURGE"
x=OUTTRAP(OFF)
 
/* Report dataset on output (BP Simulation stats) */
oufl4= "'" !! hlq !! '.repSimBP.' !! ssid !! '.CSV' !! "'"
x=OUTTRAP(TMP.)
"DELETE" oufl4 "PURGE"
x=OUTTRAP(OFF)
 
"ALLOC FI(OUFL) DA("oufl") NEW CATALOG REUSE" ,
"lrecl(1800) RECFM(V B) TRACKS SPACE(200,200)"
RcAlloc = rc
if RcAlloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl  RcAlloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end
if ç StatOnly then
do
  "ALLOC FI(OUFL2) DA("oufl2") NEW CATALOG REUSE" ,
  "LRECL(500) RECFM(V B) TRACKS SPACE(50,50)"
  RcAlloc = rc
  if RcAlloc <> 0 then Do
       say "**********************************************"
       say "   Error allocating report file" oufl2 RcAlloc
       say "   Abnormal end  "
       say "**********************************************"
       Exit 8
  end
 
  "ALLOC FI(OUFL5) DA("oufl5") NEW CATALOG REUSE" ,
  "LRECL(130) RECFM(V B) TRACKS SPACE(50,50)"
  RcAlloc = rc
  if RcAlloc <> 0 then Do
       say "**********************************************"
       say "   Error allocating report file" oufl5 RcAlloc
       say "   Abnormal end  "
       say "**********************************************"
       Exit 8
  end
 
  "ALLOC FI(OUFL3) DA("oufl3") NEW CATALOG REUSE" ,
  "LRECL(200) RECFM(V B) TRACKS SPACE(10,10)"
  RcAlloc = rc
  if RcAlloc <> 0 then Do
       say "**********************************************"
       say "   Error allocating report file" oufl3 RcAlloc
       say "   Abnormal end  "
       say "**********************************************"
       Exit 8
  end
 
  if BPSim = 'Y' then
  do
      "ALLOC FI(OUFL4) DA("oufl4") NEW CATALOG REUSE" ,
      "LRECL(200) RECFM(V B) TRACKS SPACE(90,15)"
      RcAlloc = rc
      if RcAlloc <> 0 then Do
           say "**********************************************"
           say "   Error allocating report file" oufl3 RcAlloc
           say "   Abnormal end  "
           say "**********************************************"
           Exit 8
      end
  end
end /* StaOnly */
 
/* init counters */
call init_var
/* WRITE report header */
if ç NoHead then
  Call WriteHeader
 
/* START PROCESSING */
DO FOREVER
  /* read SMF record one by one   */
  "EXECIO 1 DISKR INP"
  IF RC > 0 THEN DO
            if rc =  2 then
             do
              SAY 'End of input SMF file rc=' RC
              RcAlloc = rc
             end
             else do
              SAY 'Error while reading SMF file rc=' RC
              RcAlloc = 8
             end
              leave
            END
  PARSE PULL InpRec
  reci=reci+1
  Ofs = 1
  /* Decode SMF header */
  CALL DSNDQWST
  if result > 0 then iterate
 
  /* Process only SMF100 */
  /* record SMF records period   */
  if min_time > run_fmt_time then min_time=run_fmt_time
  if max_time < run_fmt_time then max_time=run_fmt_time
  if min_date > sm100dte     then min_date=sm100dte
  if max_date < sm100dte     then max_date=sm100dte
 
  /* Save  offset_self to reuse later */
  OfsSelf= Ofs
  /* go thru Self Def. section to go to Prod section*/
  Ofs = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs - 4 + 1
  /* Process Product section*/
  CALL DSNDQWHS
  Ofs=OfsSelf
  /* IFCID 1 must start the stats group */
  if   ifcid =  1 then
  do
        ifcid1_seen = 1
  end
  else if   ifcid <> 1 & ifcid1_seen = 0 then
                   do
                      iterate
                      say 'Bypass' ifcid
                      say 'Ifcid 1 must start the group'
                   end
  recs=recs+1
 
  /* record  ifcid in this smf data */
  call record_ifcid
  Select
       When ifcid     = 1  Then do
                                    CALL DSNDQWS0
                                    Ofs = QWS00PSO - 4 + 1
                                end
       When ifcid     = 2  Then do
                                    CALL DSNDQWS1
                                    Ofs = QWS10PSO - 4 + 1
                                end
   /*  When ifcid     = 199 Then do
                                    CALL QW0199
                                    Ofs = QWS10PSO - 4 + 1
                                end  */
       When ifcid     = 225 Then do
                                    CALL QW0225
                                    Ofs = QWS10PSO - 4 + 1
                                end
       Otherwise      do
                /* add line here to avoid excessive displays */
                        /* 202 System param. attributes */
                        /* 230 DataSharing Global stats */
                        if  ifcid = 202 then nop
                        else
                            if  ifcid = 230 then nop
                        else
                            say 'ifcid ' ifcid ' not processed'
                      end
  end   /* select */
 
  /*write report when all IFCID processed */
  if ifcid = 1 & recs > 1 then
     do
        call ifcid_diff
        Call write_report
     end
  else
  do
       if ifcid = 1 & recs = 1 then
       do
            Old_Mstrtcb =       Mstrtcb
            Old_MstrSrb =       MstrSrb
            Old_MstrpSRB=       MstrpSRB
            Old_MstrpSRB_ziip = MstrpSRB_ziip
            Old_dbm1Tcb =       dbm1Tcb
            Old_dbm1srb =       dbm1srb
            Old_dbm1pSRB=       dbm1pSRB
            Old_dbm1pSRB_ziip = dbm1pSRB_ziip
            Old_irlmTcb =       irlmTcb
            Old_irlmsrb =       irlmsrb
            Old_irlmpSRB=       irlmpSRB
            Old_irlmpSRB_ziip = irlmpSRB_ziip
            Old_DistTcb =       DistTcb
            Old_Distsrb =       DistSrb
            Old_DistpSRB=       DistpSRB
            Old_DistpSRB_ziip = DistpSRB_ziip
       end
  end
END
 
/* close file */
address TSO "EXECIO 0 DISKW OUFL (FINIS"
rcwrite = rc
if rcwrite<> 0 then Do
   say "**********************************************"
   say "   Error writting OUFL file: " rcwrite
   say "   Abnormal end   "
   say "**********************************************"
   Exit 8
end
"EXECIO 0 DISKR INP (FINIS"
"FREE DD(INP)"
"FREE DD(OUFL)"
 
/* report ifcid read */
call report_ifcid
say "Total DistTcb=" totdif_DistTcb
say "Total DistSrb=" totdif_DistSrb
say ""
say "Input records =" reci
say "Output records=" reco
say 'SMF period : ' min_date "/" max_date min_time "/" max_time
 
/*-------------------------------------------------*/
/* F20 End of program display counters and figures */
/*-------------------------------------------------*/
call DispVStor
 
EXIT retcode
 
/*---------------------------------------*/
/* End of program body- Routines section */
/*---------------------------------------*/
 
/* MAP SELF-DEFINING SECT IFCID 001 LG = 112 */
DSNDQWS0:
  /*  OFFSET TO THE PRODUCT SECTION */
  QWS00PSO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS00PSL = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS00PSN = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  /*  Following sections are provided by DSNDQWST (Stats header) */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSA CPU TIME */
  QWS00R1O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS00R1L =  C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS00R1N =  C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  SvOfs = Ofs
  /* controle de coherence */
  if  QWS00R1N  > 4 then
      do
           say 'QWS00R1N is not equal to 4, abnormal end ' QWS00R1N
           exit 8
      end
  /* Load offset to DSNDQWSA section - decode db2 stc cpu section */
  Ofs= QWS00R1O - 3  /* -4 +1 */
  i=0
  /* init DIST - DIST stats not always present   */
  DISTTcb      = 0
  DISTSrb      = 0
  DISTpSRB     = 0
  DISTpSRB_Ziip= 0
  do until i= QWS00R1N
         i = i+ 1
         call DSNDQWSA
  end
 
  /*restore offset */
  Ofs = SvOfs
 
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSB STATS COUNTERS*/
  /*  INSTRUMENTATION STATISTICS DATA ABOUT OUTPUT DESTINATION */
  QWS00R2O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSC */
  /*  IFCIDS RECORDED TO STATISTICS */
  QWS00R3O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ3ST */
  /*  Subsytem services fields */
  /*  SIGNON, IDEN, COMMITS, ABORTS ...*/
  QWS00R4O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00R4O - 3
  call DSNDQ3ST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ9ST */
  QWS00R5O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSD */
  /*  CHECKPOINT INFO, IFI COUNT    ...*/
  QWS00R6O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00R6O - 3
  call DSNDQWSD
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQVLS */
  /*  LATCH COUNTS                  ...*/
  QWS00R7O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00R7O - 3
  call DSNDQVLS
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQVAS */
  /*  ASMC STATS NBRE DE SUSPENSIONS ..*/
  QWS00R8O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQSST */
  /*  STORAGE MANAGER */
  QWS00R9O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00R9O - 3
  call DSNDQSST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQLST */
  /*  DDF STATS BY LOCATION */
  QWS00RAO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS00RAL= C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 4
  SvOfs = Ofs
  Ofs = QWS00RAO - 3
  if QWS00RAO > 0 then
  call DSNDQLST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQJST */
  /*  LOG MANAGER           */
  QWS00RBO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00RBO - 3
  call DSNDQJST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQDST */
  /*  DBAT STATS            */
  QWS00RCO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00RCO - 3
  call DSNDQDST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWOS */
  /*  ZOS STATS             */
  QWS00RDO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  if  QWS00RDO > 0 then
  do
    Ofs = QWS00RDO - 3
    call DSNDQWOS
    Ofs = SvOfs
  end
  else do
           QWOSLPRU=0
           QWOSDB2U=0
           QWOSLPIR=0
           QWOSDPIR=0
           QWOSLRST=0
           QWOSLRSF=0
           QWOSDRSU=0
           QWOSLUIC=0
 
  end
  /* LG = 112 = 14 SECTIONS * 8 */
 
  Return
 
QW0225:
numeric digits 15
    /* offset_save=Ofs       save offset begin data section*/
       /* Ofs   = offset of self definition section*/
       /* Ofs   = Ofs    + 8 : bypass pointer to Product  Section*/
       /* OfsD = offset Data section */
       Ofs =Ofs +8     /*pointer to data section 1 4+2+2 */
       /*take the contents pointed by the offset */
       OfsD= C2D(SUBSTR(InpRec,Ofs,4))
 
       /* -------------- */
       /* data section 1 */
       /* -------------- */
       /* Data section 1 = 2 parts, DBM1 and DIST */
 
       /* offset to dbm1 */
       OfsD=OfsD -4+1
       Ofs=Ofs+4
 
   /*  say 'offs sect1'  OfsD */
       /* len of data section 1 : it will be repeated :*/
       /* One for DBM1 and one for DIST */
       len=      C2D(SUBSTR(InpRec,Ofs,2))
       Ofs=Ofs+2
       rep=      C2D(SUBSTR(InpRec,Ofs,2))
       Ofs=Ofs+2
    /* say 'len' len
       say 'rep' rep
       say 'Inprec:' InpRec */
 
       /* offset to DIST */
       OfsD2=OfsD+len
 
    /* say 'offs sect2'  OfsD2 */
 
       QW0225AN =(SUBSTR(InpRec,OfsD,4))
       if  QW0225AN <> 'DBM1' then
       do
           say 'W0225 - Mapping error'
           exit 8
       end
    /***********************************/
    /* Processing DBM1 storage section */
    /***********************************/
       if  QW0225AN =  'DBM1' & vsm ='Y'  then
       do
           OfsD=OfsD+4
           /* extended region size */
           QW0225RG = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+12
           /* 31 bit low private */
           QW0225EL = C2D(SUBSTR(InpRec,OfsD,4))
           /* say '31bit low priv' b2mb(QW0225EL)*/
           OfsD=OfsD+4
           QW0225EH = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+12
           /* storage reserved fo must complete */
           /* before V10 depends on CTHREAD and MAXDBAT zparm*/
           QW0225CR = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           /* storage reserved for open/close datasets */
           /* depends on DSMAX value */
           QW0225MV = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           QW0225SO = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           QW0225GS = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+8
           QW0225VR = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           QW0225FX = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           QW0225GM = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           /* 31 bit storage available */
           QW0225AV = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+40
           /* Number of real 4K frames in use for
                31 and 64-bit private  */
           QW0225RL_dbm1 = C2D(SUBSTR(InpRec,OfsD,8))
           /*  Real stor. frame used by the Address Space*/
           /*    this includes bufferpools storage qw0225bb */
           OfsD=OfsD+8
           QW0225AX_dbm1 = C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           /* QW0225HVPagesInReal 64 bits private Real */
           /* HV = High Virtual  */
           QW0225HVPagesInReal =  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           /* QW0225HVAuxSlots    64 bits private Aux */
           QW0225HVAuxSlots =  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+24
      /*   /* QW0225HWM           64 bits private Real*/
           QW0225HVGPagesInReal =  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           /* QW0225HWM           64 bits private Aux */
           QW0225HVGAuxSlots=  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8 */
           /* QW0225PagesInReal 64 bits private Real without BP */
           QW0225PriStg_Real=  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           /* QW0225PagesInAux  64 bits private Aux  without BP */
           QW0225PriStg_Aux=  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           TotalRealUsedBP = QW0225HVPagesInReal - QW0225PriStg_Real
           TotalAuxUsedBP = QW0225HVAuxSlots    - QW0225PriStg_Aux
       end  /* if  QW0225AN =  'DBM1' & vsm = 'Y' then */
 
       /* rep = 2 : there is 2 parts , DBM1 and DDF */
       if rep = 2 then
       do
          /* DIST section */
          QW0225AN =(SUBSTR(InpRec,OfsD2,4))
          if  QW0225AN <> 'DIST'  then
          do
              say 'W0225 - Mapping error DIST not found'
              exit 8
          end
          if  QW0225AN =  'DIST' & vsm='Y' then
          do
              OfsD2=OfsD2+ 104
              QW0225RL_Dist = C2D(SUBSTR(InpRec,OfsD2,8))
              OfsD2=OfsD2+8
              QW0225AX_Dist = C2D(SUBSTR(InpRec,OfsD2,8))
          end  /* if  QW0225AN =  'DIST' & vsm = 'Y' then */
       end
       else /*if rep = 2 then*/
       do
              QW0225RL_Dist = 0
              QW0225AX_Dist = 0
       end
 
       /***************************/
       /*pointer to data section 2*/
       /*  Thread information     */
       /***************************/
 
       OfsD= C2D(SUBSTR(InpRec,Ofs,4))
       OfsD=OfsD -4+1
 
 
       QW0225AT =C2D(SUBSTR(InpRec,OfsD,4))
       OfsD=OfsD+4 /*pointer on data section 2*/
       QW0225DB =C2D(SUBSTR(InpRec,OfsD,4))
 
       if (QW0225AT + qw0225DB) < MinThdSee then
          do
              MinThdSee = QW0225AT + qw0225DB
              MinThdSeeTime= run_fmt_time
              MinThdSeeDate= sm100dte
          end
       if (QW0225AT + qw0225DB) > MaxThdSee then
          do
              MaxThdSee = QW0225AT + qw0225DB
              MaxThdSeeTime= run_fmt_time
              MaxThdSeeDate= sm100dte
          end
    /* say 'threads allied=' QW0225AT
       say 'threads dbat=' QW0225DB */
 
       /********************************************************/
       /*                                                      */
       /*pointer to data section 3 : Shared and Common Storage */
       /*                                                      */
       /********************************************************/
       Ofs = Ofs+8     /* go to next pointer*/
       if vsm = 'Y' then
       do
          /* load address of section 3*/
          OfsD= C2D(SUBSTR(InpRec,Ofs,4))
          OfsD=OfsD -4+1
 
          OfsD=OfsD +136
          QW0225SHRINREAL  =C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 32
          QW0225ShrStg_Real=C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ShrStg_Aux =C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ShrStkStg_Real=C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ShrStkStg_Aux =C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ComStg_Real=C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ComStg_Aux =C2D(SUBSTR(InpRec,OfsD,8))
 
      /*  TotalRealUsedByLPAR meaning not clear - value does not  */
      /*     corresponds with others z/OS monitoring tool         */
      /*  TotalRealUsedByLPAR= qw0225rl_dbm1+ qw0225rl_Dist +,    */
      /*       QW0225ComStg_Real + -- in redbook but no where else*/
      /*                           QW0225SHRINREAL                */
          /* QW0225ComStg_Real Real in use 64 bit shared */
          /* QW0225SHRINREAL   Real in use 64 bit common */
 
          if MaxRealLPAR  <  TotalRealUsedByLPAR then
               do
                   MaxRealLPAR = TotalRealUsedByLPAR
                   time_MaxRealLPAR = run_fmt_time
               end
 
          OfsD=OfsD + 40
          QW0225_REALAVAIL =C2D(SUBSTR(InpRec,OfsD,4))
          if MinQW0225_REALAVAIL > QW0225_REALAVAIL then
               do
                   MinQW0225_REALAVAIL = QW0225_REALAVAIL
                   time_MinQW0225_REALAVAIL = run_fmt_time
                   date_MinQW0225_REALAVAIL = sm100dte
               end
 
          OfsD=OfsD + 40
          QW0225_LMWrite_Real=C2D(SUBSTR(InpRec,OfsD,4))
          OfsD=OfsD + 4
          QW0225_LMWrite_Aux =C2D(SUBSTR(InpRec,OfsD,4))
          OfsD=OfsD + 4
          QW0225_LMCtrl_Real =C2D(SUBSTR(InpRec,OfsD,4))
          OfsD=OfsD + 4
          QW0225_LMCtrl_Aux  =C2D(SUBSTR(InpRec,OfsD,4))
         /* formula from    Redbook V11 Monitoring */
         /* table 13-1 13-2                        */
         /* Calculation to be updated in   V11 + Log Mgr control */
         /* in Real, Log. write buffers  - Source MEMU Excel sheet */
          TotalRealUsedByDB2 = qw0225rl_dbm1+ qw0225rl_Dist +,
                 QW0225ShrStg_Real + QW0225ShrStkStg_Real +,
                 QW0225ComStg_Real + QW0225_LMWrite_Real +,
                 QW0225_LMCtrl_Real
         /* calculation updated in V11 + Log Mgr control */
         /* in aux - check IBM excel provided with memu */
         TotalAuxlUsedByDB2 = qw0225ax_dbm1+ qw0225ax_Dist +,
               QW0225ComStg_Aux  + QW0225ShrStg_Aux  +  ,
               QW0225ShrStkStg_Aux + QW0225_LMCtrl_Aux +,
               QW0225_LMWrite_Aux
         If MaxDB2AuxUse < TotalAuxlUsedByDB2 then
                          do
                             MaxDB2AuxUse=TotalAuxlUsedByDB2
                             timeMaxDB2AuxUse=run_fmt_time
                             DateMaxDB2AuxUse=sm100dte
                          end
       end
 
       /*----------------------------*/
       /* Pointer to data section 4  */
       /* Statement Cache and        */
       /* shareable statement Detail */
       /*----------------------------*/
 
       Ofs=Ofs+8
       /* Load address of section 4*/
       OfsD= C2D(SUBSTR(InpRec,Ofs,4))
       OfsD=OfsD -4+1
 
       OfsD=OfsD+16
 
       /*£ of dynamic SQL local cache statements in
             64-bit agent local pools used by active
             threads
             (64-bit shared agent local variable pools)  */
       QW0225LC =C2D(SUBSTR(InpRec,OfsD,4))
       OfsD=OfsD+4
       /* HWM of QW225LC */
       QW0225HC =C2D(SUBSTR(InpRec,OfsD,4))
       OfsD=OfsD+4
       /* Storage requested for dynam SQL 64-bit shared agent local*/
       QW0225L2=C2D(SUBSTR(InpRec,OfsD,8))
       OfsD=OfsD+16
       /* Time of HWM */
    /* QW0225HT=SUBSTR(InpRec,OfsD,8)
       call stck QW0225HT
       say timestamp  run_fmt_time */
       OfsD=OfsD+32
       /* Allocated for dynam  64-bit shared system variable pools*/
       QW0225SC8=C2D(SUBSTR(InpRec,OfsD,8))
       OfsD=OfsD+16
       /* Allocated for static 64-bit shared system variable pools*/
       QW0225SX8=C2D(SUBSTR(InpRec,OfsD,8))
 
 
       /*-------------------------------------------------*/
       /*pointer to data section 5 : Pool storage details */
       /*-------------------------------------------------*/
       Ofs=Ofs+8
       if  vsm = 'Y' then
       do
         OfsD= C2D(SUBSTR(InpRec,Ofs,4))
         OfsD= OfsD+4
       /* QW0225AS Total system agent storage 31 bits*/
         QW0225AS =C2D(SUBSTR(InpRec,OfsD,4))
       /* QW0225BB Total buffer manager storage blocks */
 
       /*-------------------------------*/
       /* Calculate max threads allowed */
       /*-------------------------------*/
 
         /*Ici on a eu tous les infos on peut donc calculer le */
         /* nombre de threads max theoriques*/
         /* Source : IBM formula  */
         /* (Redbook V11 subsystem monitoring Chap. Virtual Stor*/
         /* Min and Max is used in a very defensive way */
         /* The excel proposed with MEMU deoesn't use min max */
         /* I also caculate this value (thdcomp2) */
 
         /*    Thread footprint calculation : */
 
         /* Basic Storage Cushion */
         BC = QW0225CR + QW0225MV + QW0225SO
         /* Non DB2 storage, retains max value for final calculation*/
         ND = QW0225EH-QW0225GM-QW0225GS-QW0225FX-QW0225VR
         if ND > MaxND then MaxND=ND
         /* Max Allowable storage */
         AS = QW0225RG-BC-MaxND
         AS2= QW0225RG-BC-ND
         if AS < MinAS then MinAS=AS
         /* Max Allowable storage for thread use*/
         TS = MinAS-(QW0225AS + QW0225FX + QW0225GM+ QW0225EL)
         TS2= AS2-(QW0225AS + QW0225FX + QW0225GM+ QW0225EL)
         if TS < MinTS then MinTS=TS
         /* Average thread footprint */
         /*  qdstcnat and   QW0225DB  are identical */
         if (QW0225AT + qdstcnat) = 0 then
            /* if threads in system = 0 then 1 */
            TF =  QW0225VR- QW0225AS + QW0225GS
         else
            TF = (QW0225VR-QW0225AS+QW0225GS)/(QW0225AT+qdstcnat)
 
         if TF > MaxTF then MaxTF=TF
         /* Max threads supported    */
         ThdComp=MinTS/MaxTF
         ThdComp2=TS2/TF
         StorBefContract=qw0225AV-(qw0225cr+qw0225SO+qw0225MV)
         /* Storage contraction ?*/
         if qw0225AV <  qw0225cr then
                do
                    say ' Storage critical condition',
                        'à ' run_fmt_time
                end
         else do
              if qw0225AV <  (qw0225cr+ qw0225SO+qw0225MV) then
                do
                    say ' Full system contraction should happen',
                        'à ' run_fmt_time
                end
         end /* else */
 
         if ThdComp < MinThdComp then do
                                     MinThdComp =ThdComp
                                     MinThdCompTime=run_fmt_time
                                     MinThdCompDate=sm100dte
                                   end
         if ThdComp2 < MinThdComp2 then do
                                     MinThdComp2 =ThdComp2
                                     MinThdComp2Time=run_fmt_time
                                     MinThdComp2Date=sm100dte
                                   end
         if ThdComp > MaxThdComp then do
                                     MaxThdComp =ThdComp
                                     MaxThdCompTime =run_fmt_time
                                     MaxThdCompDate =sm100dte
                                   end
         if ThdComp2 > MaxThdComp2 then do
                                     MaxThdComp2 =ThdComp2
                                     MaxThdComp2Time =run_fmt_time
                                     MaxThdComp2Date =sm100dte
                                   end
 
         Real4K_dbm1=(QW0225RL_dbm1 *4096)/ 1048576    /*1MB*/
         Real4K_Dist=(QW0225RL_Dist *4096)/ 1048576    /*1MB*/
 
         If MinReal4K_dbm1 > Real4K_dbm1 then
                          do
                             MinReal4K_dbm1=Real4K_dbm1
                             time_MinReal4K_dbm1=run_fmt_time
                             Date_MinReal4K_dbm1=sm100dte
                          end
         If MaxReal4K_dbm1 < Real4K_dbm1 then
                          do
                             MaxReal4K_dbm1=Real4K_dbm1
                             time_MaxReal4K_dbm1=run_fmt_time
                             Date_MaxReal4K_dbm1=sm100dte
                          end
         If MinReal4K_Dist > Real4K_Dist then
                          do
                             MinReal4K_Dist=Real4K_Dist
                             time_MinReal4K_Dist=run_fmt_time
                             Date_MinReal4K_Dist=sm100dte
                          end
         If MaxReal4K_Dist < Real4K_Dist then
                          do
                             MaxReal4K_Dist=Real4K_Dist
                             time_MaxReal4K_Dist=run_fmt_time
                             Date_MaxReal4K_Dist=sm100dte
                          end
       end /* if vsm ... */
return
/* MAP SELF-DEFINING SECT IFCID 002 LG = 12X8 = 96 */
DSNDQWS1:
  /*  OFFSET TO THE PRODUCT SECTION */
  QWS10PSO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs= Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQXST */
  /*  RDS stats block  */
  QWS10R1O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if  QWS10R1O > 0 then
  do
    SvOfs = Ofs
    Ofs = QWS10R1O - 4 + 1
    call DSNDQXST
    Ofs = SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTST */
  /*  Binds counts, Plans allocated succ ... */
  QWS10R2O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if QWS10R2O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R2O - 4 + 1
     call DSNDQTST
     Ofs = SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBST */
  /*  Buffer manager stats                          */
  QWS10R3O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS10r3L = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS10r3N = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  /* decode dsndqbst to have  buffer stats */
  if  QWS10R3O > 0 then
  do
      SvOfs= Ofs
      Ofs=QWS10R3O - 4 + 1
      call init_sum_bpstats
      /*add code here if need figures by bufferpool ID */
      m=0
      do until m= QWS10r3N
             m = m+ 1
             call dsndqbst
      end
      call comp_sum_bpstats
      /* Just read => Old bpstats */
      call switch_bpstats
      Ofs=SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQIST */
  /*  Data   manager stats                          */
  QWS10R4O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if QWS10R4O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R4O - 4 + 1
     call DSNDQIST
     Ofs = SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTXA */
  /*  Lock   manager stats                          */
  QWS10R5O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if QWS10R5O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R5O - 4 + 1
     call DSNDQTXA
     Ofs = SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQISE */
  /*  EDM Pool stats                                */
  QWS10R6O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS10R6L = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS10R6N = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  if QWS10R6O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R6O - 4 + 1
     call DSNDQISE
     Ofs = SvOfs
  end
  /*  Stop here if not BP Simul. */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBGL */
  /*  Group BufferPool stats                        */
  QWS10R7O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 6
  QWS10R7N = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  if  QWS10R7O > 0 then
  do
       SvOfs = Ofs
       Ofs = QWS10R7O - 4 + 1
       call init_gbpstats
       m=0
       do until m= QWS10r7N
           m = m+ 1
           call DSNDQBGL
       end /* do until */
       call comp_diff_gbpstats
       call switch_gbpstats
       Ofs = SvOfs
  end  /* QWS10R7O > 0  */
  /*  OFFSET TO DSNDQTGS   GLOBAL LOCKING STATISTICS */
  QWS10R8O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if QWS10R8O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R8O - 4 + 1
     call DSNDQTGS
     Ofs = SvOfs
  end
  else do
     QTGSLSLM=0
     QTGSCSLM=0
     QTGSUSLM=0
     QTGSIGLO=0
     QTGSSGLO=0
     QTGSFLSE=0
     QTGSKIDS=0
  end
  /*  Others sections ...                           */
  /*  Jump to BP Simulated data */
  Ofs = Ofs + 24
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQLES */
  /*  Language Envt Stats                           */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQISJ */
  /*  Start Join    Stats                           */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ8ST */
  /*  Accelerator Services Stats                    */
  /*  */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBSP */
  /*  Simulated Buffer Pool Stats                   */
  if BPSim = 'N' then return /* haha */
  QWS10RCO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS10RCL = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS10RCN = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  /* continuation flag from DSNDQBSP data */
  if  QWS10RCO > 0 then
  do
      SvOfs= Ofs
      Ofs=QWS10RCO - 4 + 1
 /*  say SUBSTR(InpRec,OFFSET,104)
  say SUBSTR(InpRec,Ofs+104,104) */
      m=0
      do until m= QWS10RCN
             m = m+ 1
             call DSNDQBSP
      end
      Ofs=SvOfs
  end
  else
  do
      Simbp_entry.0=0
  end
  /*************************************/
  /* End of IFCID002 (for this moment) */
  /*************************************/
  return
 
 
/* MAP STANDARD HEADER PRODUCT SECTION */
DSNDQWHS:
  Ofs = Ofs + 4
  /* QWHSIID DS XL2 IFCID */
  IFCID   = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 3
  /* release number */
  QWHSRN = C2X(SUBSTR(InpRec,Ofs,1))
  /* TOTAL LENGTH = 76 */
  RETURN
 
/* STATISTICS CPU TIME MAPPING MACRO LG = 52*4*/
DSNDQWSA:
    numeric digits 15
    QWSAPROC =(SUBSTR(InpRec,Ofs,4))
    /* Temporaire possible bug socle 48 */
    /* say 'QWSAPROC=<'QWSAPROC'>'  Ofs */
    if wordpos(QWSAPROC,'MSTR DBM1 IRLM DIST')=0 then
    do
      Ofs = Ofs + 8
      signal DSNDQWSA
    end
    Ofs = Ofs + 4
    /*CONVERT INTO HEX VALUE*/
    QWSAEJST = C2X(SUBSTR(InpRec,Ofs,8))
    /*ELIMINATE 1.5 BYTES */
    QWSAEJST = X2D(SUBSTR(QWSAEJST,1,13))
    QWSAEJST = QWSAEJST/1000000
    Ofs = Ofs + 8
 
    QWSASRBT = C2X(SUBSTR(InpRec,Ofs,8))
    QWSASRBT = X2D(SUBSTR(QWSASRBT,1,13))
    QWSASRBT = QWSASRBT/1000000
    Ofs = Ofs + 16
 
    QWSAPSRB = C2X(SUBSTR(InpRec,Ofs,8))
    QWSAPSRB = X2D(SUBSTR(QWSAPSRB,1,13))
    QWSAPSRB = QWSAPSRB/1000000
    Ofs = Ofs + 8
 
    QWSAPSRB_zIIP = C2X(SUBSTR(InpRec,Ofs,8))
    QWSAPSRB_ziip = X2D(SUBSTR(QWSAPSRB_zIIP,1,13))
    QWSAPSRB_ziip = QWSAPSRB_ziip/1000000
    Ofs = Ofs + 16
 
    Select
         When qwsaproc  = 'MSTR' Then do
                    MstrTcb      =QWSAEJST
                    MstrSrb      =QWSAsrbt
                    MstrpSRB     =QWSApsrb
                    MstrpSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'DBM1' Then do
                    DBM1Tcb      =QWSAEJST
                    DBM1Srb      =QWSAsrbt
                    DBM1pSRB     =QWSApsrb
                    DBM1pSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'DIST' Then do
                    DISTTcb      =QWSAEJST
                    DISTSrb      =QWSAsrbt
                    DISTpSRB     =QWSApsrb
                    DISTpSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'IRLM' Then do
                    IRLMTcb      =QWSAEJST
                    IRLMSrb      =QWSAsrbt
                    IRLMpSRB     =QWSApsrb
                    IRLMpSRB_Ziip=QWSApsrb_ziip
                 end
         Otherwise      do
                          say 'qwsaproc NOT correct' qwsaproc
                          exit 8
                        end
    end   /* select */
RETURN
 
DSNDQISE:
    /* EDMPOOL STATS */
    numeric digits 15
    /* Fields from IFCID002  : all cumulative */
    /* calculate difference between interval */
 
    /*£ OF REQ FOR CT SECTIONS*/
    Ofs = Ofs + 8
    QISECTG = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF LOAD CT SECT FROM DASD*/
    Ofs = Ofs + 4
    QISECTL = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF REQUESTS FOR DBD*/
    Ofs = Ofs + 20
    QISEDBDG = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF LOAD DBD FROM DASD*/
    Ofs = Ofs + 4
    QISEDBDL = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF REQ FOR PT SECTIONS*/
    Ofs = Ofs + 4
    QISEKTG  = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF LOAD PT SECT FROM DASD*/
    Ofs = Ofs + 4
    QISEKTL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 12
    /*£ OF Inserts  FOR DYN CACHE*/
    QISEDSI  = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF REQUESTS FOR DYN CACHE*/
    Ofs = Ofs +        4
    QISEDSG  = C2D(SUBSTR(InpRec,Ofs,4))
    /*NUMBER OF PAGES IN DBD POOL*/
    Ofs = Ofs + 12
    QISEDPGE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FREE PG IN DBD FREE CHAIN*/
    Ofs = Ofs + 4
    QISEDFRE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FAIL DUE TO DBD POOL FULL*/
    Ofs = Ofs - 8
    QISEDFAL = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF PGS IN DYN STMT POOL*/
    Ofs = Ofs + 20
    QISECPGE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FREE PG IN STMT FREE CHAIN*/
    Ofs = Ofs + 4
    QISECFRE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FAIL DUE TO STMT POOL FULL*/
    Ofs = Ofs - 8
    QISECFAL = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF PAGES IN SKEL EDM POOL*/
    Ofs = Ofs + 24
    QISEKPGE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FREE PG IN SKEL EDM POOL FREE CHAIN */
    Ofs = Ofs + 4
    QISEKFRE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FAIL DUE TO STMT SKEL POOL FULL*/
    Ofs = Ofs - 8
    QISEKFAL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 52
    /* Total stealable SKEL pages*/
    QISEKLRU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Total stealable DBD  pages*/
    QISEDLRU = C2D(SUBSTR(InpRec,Ofs,4))
 
return
DSNDQWSD:
    /* Nbr of checkpoints cumulative value */
    QWSDCKPT = C2D(SUBSTR(InpRec,Ofs,4))
 return
DSNDQSST:
    Ofs= Ofs+4
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QSST' ) then
                  do
                      say 'DSNDQSST eye catcher not met, error'
                      exit(8)
                  end
    Ofs= Ofs+4*14
    /* full storage contraction*/
    QSSTCONT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    QSSTCRIT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    QSSTABND = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
 return
DSNDQVLS:
    Ofs= Ofs+52   /*4*13*/
    /* Bufferpool LRU  */
    QVLSLC14 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4*5
    /* Log Write       */
    QVLSLC19 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4*5
    /* EDM pool or prefetch*/
    QVLSLC24 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4*7
    /* Storage Manager */
    QVLSLC31 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Storage Manager */
    QVLSLC32 = C2D(SUBSTR(InpRec,Ofs,4))
 return
DSNDQTGS:
/* Global Locking stats */
    Ofs = Ofs + 12
    /* Lock requests propagated to XES (L-lock or P-lock) */
    /* synchronously */
    QTGSLSLM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Change requests propagated to XES (L-lock or P-lock) */
    /* synchronously */
    QTGSCSLM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Unlock requests propagated to XES (L-lock or P-lock) */
    /* synchronously */
    QTGSUSLM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Suspends due to IRLM global contention */
    /* IRLM lock states were in conflict */
    QTGSIGLO = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Suspends due to XES  global contention but no IRLM global */
    /* contention. XES lock states were in conflict but IRLM lock*/
    /* states were not */
    QTGSSGLO = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Sync to Async heuristic conversions for lock request in XES*/
    /* This conversion is done when XES determines that it is more*/
    /* efficient to drive the request asynchronously to the CF */
    QTGSFLSE = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 16
    /* The sum of QTGSIGLO, QTGSSGLO and QTGSFLSE gives the total
    number of suspends due to global contention.  */
    /* QTXASLOC is the number of suspends due to local contention*/
    /* Asynchronous propagation from IRLM to XES*/
    QTGSKIDS = C2D(SUBSTR(InpRec,Ofs,4))
return
 
DSNDQTXA:
    /* Local locks - Lock manager stats */
    /* Deadlocks */
    QTXADEA  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Local Susp Locks*/
    QTXASLOC = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* TimeOuts  */
    QTXATIM  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Lock Escal Share  */
    QTXALES  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Lock Escal Excl   */
    QTXALEX  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Max numb of rows and pages lock */
    QTXANPL  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 24
    /* Suspend Latch conflict */
    QTXASLAT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Suspend Latch Other    */
    QTXASOTH = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Lock requests          */
    QTXALOCK = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Unlock requests          */
    QTXAUNLK = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Query  requests          */
    QTXAQRY  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Change requests          */
    QTXACHG  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Other IRLM  requests      */
    QTXAIRLM  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Claim requests         */
    QTXACLNO = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Drain requests         */
    QTXADRNO = C2D(SUBSTR(InpRec,Ofs,4))
 return
 
DSNDQTST:
    /* Service Controler Stats */
    Ofs= Ofs+4
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QTST' ) then
                  do
                      say 'DSNDQTST eye catcher not met, error'
                      exit(8)
                  end
    Ofs= Ofs+12
    /* Autobind Plan Attempts*/
    QTABINDA =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Autobind Plan Success */
    QTABIND  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs= Ofs+56
    /* Datasets opened (snapshot)*/
    QTDSOPN  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 48
    /* DS closed by drain DSMAX reached */
    QTDSDRN  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* RWRO Convert */
    QTPCCT   =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 44
    /* Autobind Package Attemps */
    QTAUTOBA =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Autobind Package Succ    */
    QTPKABND =  C2D(SUBSTR(InpRec,Ofs,4))
 
 return
DSNDQ3ST:
    /* DB2 Subsystem services fields */
    Ofs= Ofs+4
    /* Signon, meaningful only with CICS or IMS */
    /* Nbr of signon for new user of an EXISTING thread*/
    /* If Signon > CrtThread then there is Thread reuse */
    Q3STSIGN = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Create thread (does not include DBAT) */
    Q3STCTHD = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Terminate     */
    Q3STTERM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Commit1 */
    Q3STPREP = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Commit2 */
    Q3STCOMM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Aborts */
    Q3STABRT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 28
    /* Create Thread queued */
    Q3STCTHW = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* HWM   IDBACK*/
    Q3STHWIB = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* HWM   IDFORE*/
    Q3STHWIF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* HWM   CTHREAD*/
    Q3STHWCT = C2D(SUBSTR(InpRec,Ofs,4))
 return
 
DSNDQJST:
    Ofs=Ofs+4
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QJST' ) then
                  do
                      say 'DSNDQJST eye catcher not met, error'
                      exit(8)
                  end
    Ofs=Ofs+4
    /* Write Wait   */
    QJSTWRW = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Write No wait = nb log records  (good) */
    QJSTWRNW = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Write Force  (Not Good as does not include force to commit) */
    QJSTWRF= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Wait Output Buffer unavailable   */
    QJSTWTB  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from OutBuf */
    QJSTRBUF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from Active */
    QJSTRACT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from Archive*/
    QJSTRARH = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Delays from Tape volume contention */
    QJSTTVC  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read BSDS */
    QJSTBSDS = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* active log output CI created */
    QJSTBFFL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Archive log Read allocations */
    QJSTALR  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* CI offloaded */
    QJSTCIOF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Read access delayed due to unav resource*/
    QJSTWUR  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 32
    /* Page In Log Output Buff*/
    QJSTBPAG = C2D(SUBSTR(InpRec,Ofs,4))
    return
 
DSNDQLST:
    return
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QJST' ) then
                  do
                      say 'DSNDQJST eye catcher not met, error'
                      exit(8)
                  end
    Ofs=Ofs+4
    /* Write Wait   */
    QJSTWRW = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Write No wait = nb log records  (good) */
    QJSTWRNW = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Write Force  (Not Good as does not include force to commit) */
    QJSTWRF= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Wait Output Buffer unavailable   */
    QJSTWTB  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from OutBuf */
    QJSTRBUF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from Active */
    QJSTRACT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from Archive*/
    QJSTRARH = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Delays from Tape volume contention */
    QJSTTVC  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read BSDS */
    QJSTBSDS = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* active log output CI created */
    QJSTBFFL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 16
    /* CI offloaded */
    QJSTCIOF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 36
    /* Page In Log Output Buff*/
    QJSTBPAG = C2D(SUBSTR(InpRec,Ofs,4))
    return
DSNDQDST:
    if QWS00RCO = 0 then
    /* No DDF information */
      do
          if tsayNoDDF = 0 then do
             say 'There is no DDF information in this trace'
             tsayNoDDF=1
             say ' '
          end
          QDSTQDBT =0
          QDSTQCRT =0
          QDSTQCIT =0
          QDSTQMIT =0
          QDSTCNAT =0
          QDSTHWAT =0
          QDSTHWDT =0
          QDSTCIN2 =0
          QDSTMIN2 =0
          QDSTNQMN =0
          QDSTNQMX =0
          QDSTNQAV =0
          QDSTNQR2 =0
          QDSTMQR2 =0
          QDSTNDBA =0
          QDSTPOOL =0
          return
      end
    /* dbat queued  */
    QDSTQDBT = C2D(SUBSTR(InpRec,Ofs,4))
    ofs    = Ofs    + 20 /* 4x 5 */
    /* dbat rejected condbat reached */
    QDSTQCRT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Inactive 1 Private Protocol only  */
    /* Inactive 1 : not exec. but the VTAM conn. is kept */
    /* current inact 1 */
    QDSTQCIT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* max     inact 1 - max is CONDBAT */
    QDSTQMIT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* curr pooled dbat : active and disconnect */
    QDSTCNAT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* max  pooled dbat : active and disconnect */
    QDSTHWAT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* max  dbat        : max active + inact    */
    QDSTHWDT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Type 2 : Upon Commit the DBAT is marked as Disconn and pooled*/
    /* cur inact 2        */
    QDSTCIN2 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* max inact 2        */
    QDSTMIN2 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Cur type 2 queued  */
    QDSTNQR2 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* HWM type 2 queued  */
    QDSTMQR2 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 12
    /* Requests that required DBAT creation Type 2 */
    QDSTNDBA = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Requests that reuse a disconnected DBAT (Pooled DBAT)*/
    QDSTPOOL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 16
    /* Min time wait QDSTNQR2 */
    QDSTNQMN = C2X(SUBSTR(InpRec,Ofs,8))
    /*ELIMINATE 1.5 BYTES */
    QDSTNQMN = X2D(SUBSTR(QDSTNQMN,1,13))
    QDSTNQMN = QDSTNQMN/1000000
    Ofs = Ofs + 8
    /* Max time wait QDSTNQR2 */
    QDSTNQMX = C2X(SUBSTR(InpRec,Ofs,8))
    /*ELIMINATE 1.5 BYTES */
    QDSTNQMX = X2D(SUBSTR(QDSTNQMX,1,13))
    QDSTNQMX = QDSTNQMX/1000000
    Ofs = Ofs + 8
    /* Avg time wait QDSTNQR2 */
    QDSTNQAV = C2X(SUBSTR(InpRec,Ofs,8))
    /*ELIMINATE 1.5 BYTES */
    QDSTNQAV = X2D(SUBSTR(QDSTNQAV,1,13))
    QDSTNQAV = QDSTNQAV/1000000
    Ofs = Ofs + 8
    return
 
DSNDQXST:
    /*************************************************/
    /*  RDS STATISTICS BLOCK  DSNDQXST               */
    /*************************************************/
    /* Fields from IFCID002 : cumulative */
    /* calculate difference between interval */
    Ofs=Ofs+4
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QXST' ) then
                  do
                      say 'Ofs=' Ofs
                      eyec = SUBSTR(InpRec,1,100)
                      say 'eyec' eyec
                      say 'DSNDQXST eye catcher not met, error'
                      exit(8)
                  end
    Ofs     =  Ofs + 4
    /* Selects     */
    QXSELECT = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /* Inserts     */
    QXINSRT  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /* Update      */
    QXUPDTE  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /* Delete      */
    QXDELET  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 160
    /* Fetch       */
    QXFETCH  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 112
    /*---*/
    /*£RID List failed No storage */
    QXNSMIAP = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Failed Limit exceeded */
    QXMRMIAP = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 248
    /*£ Short Prepare */
    QXSTFND  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Full Prepare */
    QXSTNFND  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Implicit Prepare = FULL prepare */
    QXSTIPRP  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Avoided  Prepare */
    QXSTNPRP  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Stmt discarded - MAXKEEPD */
    QXSTDEXP  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 496
    /* (...) */
    /*£ RID list Overflowed to Workfile No storage in RIDPOOL */
    QXWFRIDS = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ RID list overflowed to wKk Limit Exceeded   */
    QXWFRIDT = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ RID list append for a hybrid join was interrupt No Storage*/
    QXHJINCS = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ RID list append for a hybrid join Limit exceeded*/
    QXHJINCT = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 136
    /*£ IWF not created for sparse index NO storage (zparm MXDTCACHE)*/
    QXSISTOR = C2D(SUBSTR(InpRec,Ofs,8))
  /*if  QWHSRN = 'B1' then return /* V11*/ */
    Ofs     =  Ofs + 32
    /*£ Insert Algorithm 1 */
    QXRWSINSRTDAlg1=C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Insert Algorithm 2 */
    QXRWSINSRTDAlg2=C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 56
    /*£ RDS Sort */
    QXSTSRT =C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ RDS Sort used by Accelerator (SORTL)*/
    QXSTSRTL=C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 120
    /*£ MIAP not used RID List could not be used */
    QXRFMIAP=C2D(SUBSTR(InpRec,Ofs,8))
return
DSNDQXST0:
    QXSELECT = 0
    QXINSRT  = 0
    QXUPDTE  = 0
    QXDELET  = 0
    QXFETCH  = 0
    QXNSMIAP = 0
    QXSTFND  = 0
    QXSTNFND = 0
    QXSTIPRP = 0
    QXSTNPRP = 0
    QXSTDEXP = 0
    QXWFRIDS = 0
    QXWFRIDT = 0
    QXHJINCS = 0
    QXHJINCT = 0
    QXMRMIAP = 0
    QXSISTOR = 0
    QXRWSINSRTDAlg1=0
    QXRWSINSRTDAlg2=0
    QXRSDMAD = 0
    QXRFMIAP = 0
return
 
GET_FMT_TIME:
  RUN_HH = SM100TME % 360000
  RUN_HH = RIGHT(RUN_HH,2,'0')
  RUN_MIN = SM100TME % 6000 - RUN_HH*60
  RUN_MIN = RIGHT(RUN_MIN,2,'0')
  RUN_SEC = SM100TME % 100 - RUN_HH *3600 - RUN_MIN*60
  RUN_SEC = RIGHT(RUN_SEC,2,'0')
  RUN_FMT_TIME = RUN_HH!!':'!!RUN_MIN!!':'!!RUN_SEC
  RETURN
 
 
WriteHeader:
say 'CSV file ' oufl     ' will be produced'
Lpax=MVSVAR(SYSNAME)
If substr(lpax,1,2) <> 'CR' then
do
  outrec.0= 1
  outrec.1= ,
        "Lp,ssi,date,time,Hr,MstrTcb,MsSrb,MsPSrb,"!!,
         "MsPSrbZi,Dbm1Tcb,DbSrb,DbPSrb,DbPSrbZi,"!!,
                       "IrlmTcb,IrSrb,IrPSrb,IrPSrbZi,"!!,
                       "DistTcb,DstSrb,DstPSrb,DstPSrbZi,"!!,
         "Ckp,"!!,
         "CrTd,Sign,Term,Com1,Com2,Abrt,CrTdQd,MxIdBck,"!!,
         "MxIdfr,MxCtd,"!!,
         "AuBdPlA,AuBdPlS,AuBdPkA,AuBdPkS,"!!,
         "DsCu,DsClo,ROSwch,DsOpe,"!!,
         "Gp,GpSq,SynIo,PgWriten,SynWr,AsyWr,"!!,
         "PgInR,PgInW,"!!,
         "CasPg,CasIO,SPrfIO,DyPrfIO,LstPrfIO,BpSio,"!!,
         "NbSqlLocCch,HwmLocCch,AloLocCch,"!!,
         "AloGlbCchDy,AloGlbCchStic,"!!,
       /* Distributed data */,
         "DbatRjCnMx,"!!,
         "CuInac1,MxIn1,CuActDbat,MxActDbat,MxAllDbat,"!!,
         "CuIn2Cn,MxIn2Cn,CuT2Qd,MxT2Qd,"!!,
         "MnQTme,MxQTme,AvQTme,"!!,
         "TdCrDbt,TdReuDbt,"!!,
         "CuAldTd,TdMxComp,TdMxComp2,"!!,
       /* Storage data*/,
         "TotReaUsDb2,TotAxUsDb2,"!!,
         "TotReaUsBp,TotAxUsBp,ReaAvl,"!!,
         "XRgSz,31Avl,StoBfCnt,"!!,
         "FulCnt,StoCri,NbAbSto,"!!,
         "NoOptColP,"!!,
      /* Workfiles block */ ,
         "32KU4Prf,4KUs32Prf,MxWfKb,"!!,
         "CuWfKb,Cu4KWfKb,Cu32KWfKb,"!!,
         "CuDMnMWfNb,CuDMnMWfKb,"!!,
         "CuSRInMWfNb,CuSRInMWfKb,"!!,
         "CuRIDsOvfWf,CuNonSRTWfNb,"!!,
         "NbPhyWfCrt,MxWfUsTdKb,"!!,
         "AllWfCnfKb,DGTWfCnfKb,"!!,
         "OthWfCnfKb,"!!,
         "CuDGTUsKb,MxDGTUsKb,"!!,
         "CuOthUsKb,MxOthUsKb,"!!,
     ,/* EDM Pool block  */
        "MxRIDBlks,"!!,
        "RqCT,LodCT,RqDBD,LodDBD,RqPT,LodPT,RqDyCch,"!!,
        "InsDyC,"!!,
        "DBDPg,DBDFre,DBDSteal,FailDBFul,StmPooPg,"!!,
        "StmFre,"!!,
        "FailStFul,SkPg,SkFre,SkSteal,FailSkFul,"!!,
    ,/* Locks           */
         "DedLk,TimO,EscS,EscX,MxPgRLckd,SusLtch,SusOth,"!!,
         "LocSusLck,LckRq,ULkRq,ChgRq,OthRq,"!!,
         "ClmRq,DrnRq,"!!,
    ,/* Global locks    */
         "SynLckRq2XES,SynChgRq2XES,SynUnlRq2XES,AsyIRLM2XES,"!!,
         "SusIrlmGbCnt,"!!,
         "SusXESCnt,SusHeuCnv,TotGbSus,"!!,
    ,/* RID Pool block  */
         "Sel,Ins,Upd,Del,Ftch,"!!,
         "Prep,ShrtP,ImplP,AvoidP,PrepMxKD,"!!,
         "RIDFailSto,RIDFailLim,RIDOvfSto,RIDOvfLim,"!!,
         "RIDHybFailSto,RIDHybFailLim,"!!,
         "RIDTrmRDS,RIDTrmDM,"!!,
         "IWFNoSto,IAG1,IAG2,RIDLstNO,"!!,
    ,/* FTB & IAG2 V12 features */
         "IAG2Aloc,IAG2Dis,FTBMnThres,FTBElig,FTBCand,"!!,
         "FTBSz,FTBPrev,FtbCu,IAG2EnA,IAG2EnS,"!!,
    ,/* Logging */
         "LogWrNW,WriteW,WrFor,ActLgCI,CIOff,"!!,
         "LgRBuf,LgRAct,LgRArc,TapeCnt,BsdsR,"!!,
         "LgRArcAl,LgRDlayResUnv,"!!,
    ,/*ZOS Stats from RMF Api */
         "NbCpLp,Cpu%Lp,CpuDb2,CpuMstr,CpuDbm1,"!!,
         "PgInLp,PgInDb2,ReaLpMb,ReaFree,"!!,
         "ReaDb2Mb,VirtLp,VirtFre,VirtDb2,"!!,
         "UIC"
     /*  Zones below correspond to the ibm provided excel columns */
     /*  "Z,BE,CV,CX,CZ,CU,CW,CY,CQ,Y,BD"  */
end
else do
  /* Cas BPCR couper le header en 2 */
  outrec.0= 2
  outrec.1= ,
        "Lp,ssi,date,time,Hr,MstrTcb,MsSrb,MsPSrb,"!!,
         "MsPSrbZi,Dbm1Tcb,DbSrb,DbPSrb,DbPSrbZi,"!!,
                       "IrlmTcb,IrSrb,IrPSrb,IrPSrbZi,"!!,
                       "DistTcb,DstSrb,DstPSrb,DstPSrbZi,"!!,
         "Ckp,"!!,
         "CrTd,Sign,Term,Com1,Com2,Abrt,CrTdQd,MxIdBck,"!!,
         "MxIdfr,MxCtd,"!!,
         "AuBdPlA,AuBdPlS,AuBdPkA,AuBdPkS,"!!,
         "DsCu,DsClo,ROSwch,DsOpe,"!!,
         "Gp,GpSq,SynIo,PgWriten,SynWr,AsyWr,"!!,
         "PgInR,PgInW,"!!,
         "CasPg,CasIO,SPrfIO,DyPrfIO,LstPrfIO,BpSio,"!!,
         "NbSqlLocCch,HwmLocCch,AloLocCch,"!!,
         "AloGlbCchDy,AloGlbCchStic,"!!,
       /* Distributed data */,
         "DbatRjCnMx,"!!,
         "CuInac1,MxIn1,CuActDbat,MxActDbat,MxAllDbat,"!!,
         "CuIn2Cn,MxIn2Cn,CuT2Qd,MxT2Qd,"!!,
         "MnQTme,MxQTme,AvQTme,"!!,
         "TdCrDbt,TdReuDbt,"!!,
         "CuAldTd,TdMxComp,TdMxComp2,"!!,
       /* Storage data*/,
         "TotReaUsDb2,TotAxUsDb2,"!!,
         "TotReaUsBp,TotAxUsBp,ReaAvl,"!!,
         "XRgSz,31Avl,StoBfCnt,"!!,
         "FulCnt,StoCri,NbAbSto,"!!,
         "NoOptColP,"!!,
      /* Workfiles block */ ,
         "32KU4Prf,4KUs32Prf,MxWfKb,"!!,
         "CuWfKb,Cu4KWfKb,Cu32KWfKb,"!!,
         "CuDMnMWfNb,CuDMnMWfKb,"!!,
         "CuSRInMWfNb,CuSRInMWfKb,"!!,
         "CuRIDsOvfWf,CuNonSRTWfNb,"!!,
         "NbPhyWfCrt,MxWfUsTdKb,"!!,
         "AllWfCnfKb,DGTWfCnfKb,"!!,
         "OthWfCnfKb,"!!,
         "CuDGTUsKb,MxDGTUsKb,"!!,
         "CuOthUsKb,MxOthUsKb,"!!,
     ,/* EDM Pool block  */
        "MxRIDBlks,"!!,
        "RqCT,LodCT,RqDBD,LodDBD,RqPT,LodPT,RqDyCch,"!!,
        "InsDyC,"
    outrec.2=,
        "DBDPg,DBDFre,DBDSteal,FailDBFul,StmPooPg,"!!,
        "StmFre,"!!,
        "FailStFul,SkPg,SkFre,SkSteal,FailSkFul,"!!,
    ,/* Locks           */
         "DedLk,TimO,EscS,EscX,MxPgRLckd,SusLtch,SusOth,"!!,
         "LocSusLck,LckRq,ULkRq,ChgRq,OthRq,"!!,
         "ClmRq,DrnRq,"!!,
    ,/* Global locks    */
         "SynLckRq2XES,SynChgRq2XES,SynUnlRq2XES,AsyIRLM2XES,"!!,
         "SusIrlmGbCnt,"!!,
         "SusXESCnt,SusHeuCnv,TotGbSus,"!!,
    ,/* RID Pool block  */
         "Sel,Ins,Upd,Del,Ftch,"!!,
         "Prep,ShrtP,ImplP,AvoidP,PrepMxKD,"!!,
         "RIDFailSto,RIDFailLim,RIDOvfSto,RIDOvfLim,"!!,
         "RIDHybFailSto,RIDHybFailLim,"!!,
         "RIDTrmRDS,RIDTrmDM,"!!,
         "IWFNoSto,IAG1,IAG2,RIDLstNO,"!!,
    ,/* FTB & IAG2 V12 features */
         "IAG2Aloc,IAG2Dis,FTBMnThres,FTBElig,FTBCand,"!!,
         "FTBSz,FTBPrev,FtbCu,IAG2EnA,IAG2EnS,"!!,
    ,/* Logging */
         "LogWrNW,WriteW,WrFor,ActLgCI,CIOff,"!!,
         "LgRBuf,LgRAct,LgRArc,TapeCnt,BsdsR,"!!,
         "LgRArcAl,LgRDlayResUnv,"!!,
    ,/*ZOS Stats from RMF Api */
         "NbCpLp,Cpu%Lp,CpuDb2,CpuMstr,CpuDbm1,"!!,
         "PgInLp,PgInDb2,ReaLpMb,ReaFree,"!!,
         "ReaDb2Mb,VirtLp,VirtFre,VirtDb2,"!!,
         "UIC"
end
 
  "EXECIO 1 DISKW OUFL (STEM OUTREC. "
 
  if ç StatOnly then
  do
  /*------------------------------*/
  /* Header for Buffer pool stats */
  /*------------------------------*/
  outrec.1= ,
        "Lpar,Ssid,Date,Time,Hour,BP,Size,"!!,
                  "Gp,GpSeq,SyncIo,PgWr,SyncWr,AsyncWr,"!!,
                  "PgInR,PgInW,"!!,
          "SPfIo,CastPg,CastIo,DynPfIo,LPfIo,BpSio,"!!,
                  "MinSRLU,MaxSLRU,NbSLRUFull,NbRandSLRU,StorFree"
 
  "EXECIO 1 DISKW OUFL2 (STEM OUTREC. "
 
  /*------------------------------*/
  /* Header for GBP         stats */
  /*------------------------------*/
  outrec.1= ,
      "Lpar,Ssid,Date,Time,Hour,GBP,Gp,"!!,
      "GBPGp,XIRdFnd,XIRdNFnd,XIMissRatio,PgAsyncW,PgSyncW,"!!,
      "PgCast,PgWrAro,AsynXI,SusAsynXI"
 
  "EXECIO 1 DISKW OUFL5 (STEM OUTREC. "
 
  /*------------------------------*/
  /* Header for Storage     stats */
  /*------------------------------*/
  outrec.1= ,
        "Lpar,ssid,date,time,Hour,TotalRealDB2,"!!,
           "RealDBM1,RealDist,ShrReal,StkReal,ComReal," !!,
           "AuxDBM1,AuxDist,ShrAux,StkAux,ComAux," !!,
           "ShrRealLPAR," !!,
           "TotAuxDB2,TotRealBP,TotAuxBP,RealAvLPAR," !!,
           "ExtRegSz,StoAvDB2"
 
  "EXECIO 1 DISKW OUFL3 (STEM OUTREC. "
 
  if BPSim = 'N' then return
  /*--------------------------------*/
  /* Header for BP Simulation Stats */
  /*--------------------------------*/
  outrec.1= ,
        "Lpar,Ssid,Date,Time,Hour,BP,"!!,
           "SimSize,SeqPage,SyncIOAvoid,SeqSyncIO,AsyncPgRd," !!,
           "GSyncIO,GSeqSyncIO,GAsyncPgRd," !!,
           "PgMov,SyncIOWaitAvoid"
 
  "EXECIO 1 DISKW OUFL4 (STEM OUTREC. "
 
  end /* StatOnly*/
 
  return
 
 
write_report:
    totdif_DistTcb=dif_DistTcb+totdif_DistTcb
    totdif_DistSrb=dif_Distsrb+totdif_Distsrb
 
    reco= reco+ 1
    /* allocate small datasets (to bypass mail limit)*/
    select
       when  reco = 6000 then call AllocS01
       when  reco = 12000 then call AllocS02
       when  reco = 18000 then call AllocS03
       otherwise
    end
 
    /* bypass first record because off difference calculation */
    if reco = 1 then return
    /* Warning messages or not ? */
    if Alert='Y' & run_fmt_time <> Recycle_time
                 then call CheckForAlert
    /*---*/
    outrec.0= 1
    outrec.1= sm100sid  !! ',' !! sm100ssi !! ','  ,
    !! '"'sm100dtex'"'   !! ','   ,
    !! run_fmt_time     !! ','   ,
    !! run_hh           !! ','   ,
    !! dif_MstrTcb      !! ','   ,
    !! dif_MstrSrb      !! ','   ,
    !! dif_MstrpSRB     !! ','   ,
    !! dif_MstrpSRB_ziip !! ','   ,
    !! dif_dbm1Tcb      !! ','   ,
    !! dif_dbm1Srb      !! ','   ,
    !! dif_dbm1pSRB     !! ','   ,
    !! dif_dbm1pSRB_ziip !! ','   ,
    !! dif_IrlmTcb      !! ','   ,
    !! dif_IrlmSrb      !! ','   ,
    !! dif_IrlmpSRB     !! ','   ,
    !! dif_IrlmpSRB_ziip !! ','  ,
    !! dif_DistTcb      !! ','   ,
    !! dif_DistSrb      !! ','   ,
    !! dif_DistpSRB     !! ','    ,
    !! dif_DistpSRB_ziip !! ','   ,
    !! Dif_QWSDCKPT      !! ','   ,     /* Checkpoints */
    !! Dif_Q3STCTHD  !! ','        ,     /* Create Thd */
    !! Dif_Q3STSIGN  !! ','        ,     /* Signon  */
    !! Dif_Q3STTERM  !! ','        ,     /* Terminate*/
    !! Dif_Q3STPREP  !! ','        ,     /* Commit phase 1 */
    !! Dif_Q3STCOMM  !! ','        ,     /* Commit Ph 2*/
    !! Dif_Q3STABRT  !! ','        ,     /* Aborts */
    !! Dif_Q3STCTHW  !! ','        ,     /* Wait Cthread*/
    !!     Q3STHWIB  !! ','        ,     /* Max IDBACK */
    !!     Q3STHWIF  !! ','        ,     /* Max IDFORE */
    !!     Q3STHWCT  !! ','        ,     /* Max CTHREAD */
    !! Dif_QTABINDA  !! ','        ,     /* Autobind Plan*/
    !! Dif_QTABIND   !! ','        ,
    !! Dif_QTAUTOBA  !! ','        ,     /* Auto bind Pack */
    !! Dif_QTPKABND  !! ','        ,
    !! QTDSOPN       !! ','        ,     /* DS Current  */
    !! Dif_QTDSDRN   !! ','        ,     /* Close Drain */
    !! Dif_QTPCCT    !! ','        ,     /* RWRO switch */
    !! Sum_QBSTDSO   !! ','        ,     /* OPEN DS     */
    !! Sum_QBSTGET   !! ','        ,
    !! Sum_QBSTSGT   !! ','        ,     /* Sequential Getp */
    !! Sum_QBSTRIO   !! ','        ,
    !! Sum_QBSTPWS   !! ','        ,
    !! Sum_QBSTIMW   !! ','        ,
    !! Sum_QBSTWIO   !! ','        ,
    !! Sum_QBSTRPI   !! ','        ,
    !! Sum_QBSTWPI   !! ','        ,
    !! Sum_QBSTPCO   !! ','        ,
    !! Sum_QBSTCIO   !! ','        ,
    !! Sum_QBSTPIO   !! ','        ,
    !! Sum_QBSTDIO   !! ','        ,
    !! Sum_QBSTLIO   !! ','        ,
    !! Sum_QBSTSIO   !! ','        ,
    !! QW0225LC      !! ','        ,
    !! QW0225HC      !! ','        ,
    !! QW0225L2      !! ','        ,
    !! QW0225SC8     !! ','        ,
    !! QW0225SX8     !! ','        ,
    !! Dif_QDSTQCRT  !! ','  , /* Conn. rejected CONDBAT reached */
    !! QDSTQCIT      !! ','        ,     /* curr. inact type 1*/
    !! QDSTQMIT      !! ','        ,     /* max . inact type 1*/
    !! QDSTCNAT      !! ','        ,     /* curr. active dbat */
    !! QDSTHWAT      !! ','        ,     /* max active dbat */
    !! QDSTHWDT      !! ','        ,     /* max act & inact dbat */
    !! QDSTCIN2      !! ','        ,     /* current inactive Conn*/
    !! QDSTMIN2      !! ','        ,     /* hwm inactive  conn */
    !! QDSTNQR2      !! ','        ,     /* Type 2 queued      */
    !! QDSTMQR2      !! ','        ,     /* HWM type 2 queued  */
    !! QDSTNQMN      !! ','        ,
    !! QDSTNQMX      !! ','        ,
    !! QDSTNQAV      !! ','        ,
    !! Dif_QDSTNDBA      !! ','        ,
    !! Dif_QDSTPOOL      !! ','        ,
    !! QW0225AT      !! ','        ,     /* curr. allied threads*/
    !! strip(format(ThdComp ,6,0))   !! ',' ,
    !! strip(format(ThdComp2,6,0))   !! ',' ,
    !! f2mb(TotalRealUsedByDB2)     !! ',' ,
    !! f2mb(TotalAuxlUsedByDB2)     !! ',' ,
    !! f2mb(TotalRealUsedBP)        !! ',' ,
    !! f2mb(TotalAuxUsedBP)         !! ',' ,
    !! f2mb(QW0225_REALAVAIL)       !! ',' ,
    !! b2mb(QW0225RG)               !! ',' ,
    !! b2mb(QW0225AV)               !! ',' ,
    !! b2mb(StorBefContract)        !! ',' ,
    !!             QSSTCONT         !! ',' ,
    !!             QSSTCRIT         !! ',' ,
    !!             QSSTABND         !! ',' ,
    !!         Dif_QISTCOLS         !! ',' ,
  /* Workfiles block */ ,
    !!         Dif_QISTWFP1         !! ',' ,
    !!         Dif_QISTWFP2         !! ',' ,
    !!             QISTWMXU         !! ',' ,
    /* Current all workfile usage in KB : DGTT and Sort */,
    !! QISTWCTO     !! ',' ,
    /* Current 4K wrkfile storage usage in KB*/ ,
    !! QISTW4K      !! ',' ,
    /* Current 32K wrkfile storage usage in KB*/,
    !! QISTW32K     !! ',' ,
    /* Nb DM in memory   wrkfiles active currently */ ,
    !! QISTIMAC     !! ',' ,
    /* Space DM in memory active currently in KB*/ ,
    !! QISTIMSC     !! ',' ,
    /* Nb SRT in memory   wrkfiles active currently */ ,
    !! QISTSIAC     !! ',' ,
    /* Space SRT in memory active currently in KB */ ,
    !! QISTSISC     !! ',' ,
    /* Current RID blocks overflowed (stored) in wrkfiles*/ ,
    !! QISTWFRCUR   !! ',' ,
    /* Current NON Sort related workfiles active */,
    !! QISTI2AC     !! ',' ,
    /* Physical  workfiles created */,
    !! Dif_QISTI2OF !! ',' ,
    /* HWM wkfile storage used by an agent */ ,
    !! QISTAMXU     !! ','  ,
    /* Current storage configured for wkfiles*/ ,
    !! QISTWSTG     !! ','  ,
    /* Current DGTT  configured for wkfile KB*/ ,
    !! QISTDGTTSTG  !! ',' ,
    /* Current others  configured for wkfile KB*/,
    !! QISTWFSTG    !! ',' ,
    /* Current DGTT  used  KB*/,
    !! QISTDGTTCTO  !! ',' ,
    /* HWM     DGTT  used  KB*/ ,
    !! QISTDGTTMXU  !! ',' ,
    /* Current others used  KB*/ ,
    !! QISTWFCTO    !! ',' ,
    /* HWM    others used KB*/ ,
    !! QISTWFMXU    !! ',' ,
  /* EDMPOOL block */ ,
    !! QISTRHIG                     !! ',' ,    /* Max RID blocks*/
    !! Dif_QISECTG                  !! ',' ,    /* requests CT*/
    !! Dif_QISECTL                  !! ',' ,    /* Load CT    */
    !! Dif_QISEDBDG                 !! ',' ,    /* Req DBD    */
    !! Dif_QISEDBDL                 !! ',' ,    /* Load DBD   */
    !! Dif_QISEKTG                  !! ',' ,    /* Req PT     */
    !! Dif_QISEKTL                  !! ',' ,    /* Load PT    */
    !! Dif_QISEDSG                  !! ',' ,    /* Req Dyn Cache */
    !! Dif_QISEDSI                  !! ',' ,    /* Ins Dyn Cache */
    !!     QISEDPGE                 !! ',' ,    /* DBDPool used pages */
    !!     QISEDFRE                 !! ',' ,    /* DBDPOOL free pages */
    !!     QISEDLRU                 !! ',' ,    /* DBDPOOL stealable  */
    !!     QISEDFAL                 !! ',' ,    /* Failed DBDPool Full*/
    !!     QISECPGE                 !! ',' ,    /* Pages STMTPool */
    !!     QISECFRE                 !! ',' , /* Pages STMTPool free */
    !!     QISECFAL                 !! ',' , /* Failed STMTool Full*/
    !!     QISEKPGE                 !! ',' , /* Pages in SkelPool */
    !!     QISEKFRE                 !! ',' , /* Free pages SKELPool*/
    !!     QISEKLRU                 !! ',' ,  /* Skel pages stealable*/
    !!     QISEKFAL                 !! ',' ,  /* Failed SkelPoolFull*/
  /* Locks                              */,
    !!  Dif_QTXADEA                 !! ',' ,
    !!  Dif_QTXATIM                 !! ',' ,
    !!  Dif_QTXALES                 !! ',' ,
    !!  Dif_QTXALEX                 !! ',' ,
    !!  Dif_QTXANPL                 !! ',' ,
    !!  Dif_QTXASLAT                !! ',' ,
    !!  Dif_QTXASOTH                !! ',' ,
    !!  Dif_QTXASLOC                !! ',' ,
    !!  Dif_QTXALOCK                !! ',' ,
    !!  Dif_QTXAUNLK                !! ',' ,
    !!  Dif_QTXACHG                 !! ',' ,
    !!  Dif_QTXAIRLM                !! ',' ,
    !!  Dif_QTXACLNO                !! ',' ,
    !!  Dif_QTXADRNO                !! ',' ,
  /* Global locks */,
    !!  Dif_QTGSLSLM                !! ',' ,
    !!  Dif_QTGSCSLM                !! ',' ,
    !!  Dif_QTGSUSLM                !! ',' ,
    !!  Dif_QTGSKIDS                !! ',' ,
    !!  Dif_QTGSIGLO                !! ',' ,
    !!  Dif_QTGSSGLO                !! ',' ,
    !!  Dif_QTGSFLSE                !! ',' ,
    !!  Dif_QTGSFLSE+Dif_QTGSSGLO+Dif_QTGSIGLO  !! ',' ,
  /* RID LIST BLOCK RID List processing */,
    !!  Dif_QXSELECT                !! ',' ,
    !!  Dif_QXINSRT                 !! ',' ,
    !!  Dif_QXUPDTE                 !! ',' ,
    !!  Dif_QXDELET                 !! ',' ,
    !!  Dif_QXFETCH                 !! ',' ,
    !!  Dif_QXSTNFND                !! ',' , /* Full  Prepare */
    !!  Dif_QXSTFND                 !! ',' , /* Short Prepare */
    !!  Dif_QXSTIPRP                !! ',' , /* Impl  Prepare */
    !!  Dif_QXSTNPRP                !! ',' , /* Avoided Prepare */
    !!  Dif_QXSTDEXP                !! ',' , /* Prepare MAXKEEPD reach*/
    !!  Dif_QXNSMIAP                !! ',' ,  /*Failed Limit no Stor */
    !!  Dif_QXMRMIAP                !! ',' ,  /*Failed Limit exc*/
    !!  Dif_QXWFRIDS                !! ',' ,  /*Overflow no Stor. */
    !!  Dif_QXWFRIDT                !! ',' ,  /*Overflow Limit    */
    !!  Dif_QXHJINCS                !! ',' ,  /*Failed Hybrid Stor*/
    !!  Dif_QXHJINCT                !! ',' ,  /*Failed Hybrid Limit*/
    !!  Dif_QISTRLLM                !! ',' ,  /*RID interrupted */
                 /* RDS Limit = MAX(25% table size, rid storage) */,
                 /* but can be others reason */,
    !!  Dif_QISTRPLM                !! ',' ,  /*RID interrupt > 16M */
    !!  Dif_QXSISTOR                !! ',' ,  /*IWF no storage    */
    !!  Dif_QXRWSINSRTDAlg1         !! ',' ,  /*Insert Algo 1     */
    !!  Dif_QXRWSINSRTDAlg2         !! ',' ,  /*Insert Algo 2     */
    !!  Dif_QXRFMIAP                !! ',' ,  /*RID not used      */
  /* V12 features: FTB & IAG2 */ ,
    !!  QISTINPA  !! ',' ,              /* IAG2 Alloc */
    !!  QISTINPD  !! ',' ,              /* IAG2 Dealloc */
    !!  QISTTRAVMIN  !! ',' ,           /* FTB Min traverse count*/
    !!  QISTFTBCANT !! ',' ,            /* FTB Eligible */
    !!  QISTFTBCAN !! ',' ,             /* FTB Candidate */
    !!  QISTFTBSIZE !! ',' ,            /* FTB Size */
    !!  QISTFTBNUMP !! ',' ,            /* Prev Interval FTB usage */
    !!  QISTFTBNUMC !! ',' ,            /* Current Ix using FTB */
    !!  QISTINPR !! ',' ,               /* IAG2 reenable attempts*/
    !!  QISTINPE !! ',' ,               /* IAG2 attempts succ.*/
  /*Logging */ ,
    !!     Dif_QJSTWRNW             !! ',' ,  /*Log rec -WriteNWoW*/
    !!     Dif_QJSTWRW             !! ',' ,  /*Write Waits */
    !!     Dif_QJSTWRF              !! ',' ,  /*Write Force*/
    !!     Dif_QJSTBFFL             !! ',' ,  /*Log CI created*/
    !!     Dif_QJSTCIOF             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTRBUF             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTRACT             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTRARH             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTTVC              !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTBSDS             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTALR              !! ',' , /* Log Arc Read Alloc*/
    !!     Dif_QJSTWUR              !! ',' , /* Log R Delay ResUn*/
    !!     QWOSLNCP                 !! ',' ,  /* Nb CPu    LPAR */
    !!     QWOSLPRU                 !! ',' ,  /* CPU util. LPAR */
    !!     QWOSDB2U                 !! ',' ,  /* CPU util. DB2 */
    !!     QWOSMSTU                 !! ',' ,  /* CPU util. Mstr*/
    !!     QWOSDBMU                 !! ',' ,  /* CPU util. Dbm1*/
    !!     QWOSLPIR                 !! ',' ,  /* Page in rate LPAR */
    !!     QWOSDPIR                 !! ',' ,  /* Page in DB2 */
    !!     QWOSLRST                 !! ',' ,  /* Real    LPAR */
    !!     QWOSLRSF                 !! ',' ,  /* Real    Free */
    !!     QWOSDRSU                 !! ',' , /* Stor used by this Db2*/
    !!     QWOSLVST                 !! ',' , /* Virt Stor Lpar       */
    !!     QWOSLVSF                 !! ',' , /* Virt Stor Free       */
    !!     QWOSDVSU                 !! ',' , /* Virt Stor Db2        */
    !!     QWOSLUIC                 !! ','    /* UIC */
  /*!! f2mb(qw0225ax_dbm1)          !! ',' ,
    !! f2mb(qw0225ax_Dist)          !! ',' ,
    !! f2mb(QW0225ShrStg_Aux)       !! ',' ,
    !! f2mb(QW0225ShrStkStg_Aux)    !! ',' ,
    !! f2mb(QW0225ComStg_Aux)       !! ',' ,
    !! f2mb(QW0225ShrStg_Real)      !! ',' ,
    !! f2mb(QW0225ShrStkStg_Real)   !! ',' ,
    !! f2mb(QW0225ComStg_Real)      !! ',' ,
    !! f2mb(QW0225SHRINREAL)        !! ',' ,
    !! f2mb(qw0225rl_dbm1)          !! ',' ,
    !! f2mb(qw0225rl_Dist)          !! ','    */
    /* active thread =  QDSTCNAT +  QW0225AT */
  "EXECIO 1 DISKW OUFL (STEM OUTREC. "
 
If StatOnly=0 then do
  /*************************************/
  /* Second record for Detail Bufstats */
  /* Loop  for each bufferpool ID      */
  /*************************************/
  do i = 1 to NbBPEnt.0
        j = NbBPEnt.i
        /* decode BPID to BP name */
        Select
             When j >='0'   & j <= '50'    Then BPNm = 'BP'j
             When j >='100' & j <= '109'   Then do
                                                  k    = j-100
                                                  BPNm = 'BP8K'k
                                                end
             When j >='120' & j <= '129'   Then do
                                                  k    = j-120
                                                  BPNm = 'BP16K'k
                                                end
             When j >='80'  & j <= '89'    Then do
                                                  k    = j-80
                                                  BPNm = 'BP32K'k
                                                end
             Otherwise do
                         say 'Buffer pool ID ??? 'j
                         BPNm = '?'j
                       end
        end
    /* SLRU full   */
/*      if Det_HST.j >0 then
             do
               say 'Warning : SLRU chain = VPSEQT for' BPNm,
                   'à' run_fmt_time
               retcode=4
             end */
        if BPNm = 'BP32K0' then BPNm = 'BP32K'
        outrec.1= sm100sid !! ',' !! sm100ssi !! ','  ,
        !! '"'sm100dtex'"'  !! ','   ,
        !! run_fmt_time    !! ','   ,
        !! run_hh          !! ','   ,
        !! BPNm            !! ','   ,
        !! BufVPL.j      !! ','  ,
        !! Det_GET.j     !! ','  ,
        !! Det_SGT.j     !! ','  ,
        !! Det_RIO.j     !! ','  ,
        !! Det_PWS.j     !! ','  ,
        !! Det_IMW.j     !! ','  ,
        !! Det_WIO.j     !! ','  ,
        !! Det_RPI.j     !! ','  ,
        !! Det_WPI.j     !! ','  ,
        !! Det_PIO.j     !! ','  ,
        !! Det_PCO.j     !! ','  ,
        !! Det_CIO.j     !! ','  ,
        !! Det_DIO.j     !! ','  ,
        !! Det_LIO.j     !! ','  ,
        !! Det_SIO.j     !! ','  ,
        !! BufMIN.j      !! ','  ,
        !! BufMAX.j      !! ','  ,
        !! Det_HST.j     !! ','  ,
        !! Det_RHS.j     !! ','  ,
        !! QWOSLRSF
        "EXECIO 1 DISKW OUFL2 (STEM OUTREC. "
  end
  /***************************************************/
  /* Another record for Detail Group Bufferpool stats*/
  /* Loop  for each bufferpool ID                    */
  /***************************************************/
  do i = 1 to NbGBPEnt.0
        j = NbGBPEnt.i
        /* decode BPID to BP name */
        Select
             When j >='0'   & j <= '50'    then BPNm = 'GBP'j
             When j >='100' & j <= '109'   then do
                                              k    = j-100
                                              BPNm = 'GBP8K'k
                                           end
             When j >='120' & j <= '129'   then do
                                              k    = j-120
                                              BPNm = 'GBP16K'k
                                           end
             When j >='80'  & j <= '89'    then do
                                              k    = j-80
                                              BPNm = 'GBP32K'k
                                           end
             Otherwise do
                         BPNm = '?'j
                       end
        end
        if BPNm = 'GBP32K0' then BPNm = 'GBP32K'
 
        outrec.1= sm100sid !! ',' !! sm100ssi !! ','  ,
        !! '"'sm100dtex'"'  !! ','   ,
        !! run_fmt_time    !! ','   ,
        !! run_hh          !! ','   ,
        !! BPNm            !! ','   ,
        !! Det_GET.j       !! ','   ,      /* getpage */
        !! Dif_GBPGetPage.j     !! ','  ,
        !! Dif_GBPXIReadRet.j     !! ','  ,
        !! Dif_GBPXIReadNoRet.j   !! ','  ,
        !! format(GBPXIMissRatio.j,4,2) !! ','  ,
        !! Dif_QBGLAW.j   !! ','  ,
        !! Dif_QBGLSW.j   !! ','  ,
        !! Dif_QBGLRC.j   !! ','  ,
        !! Dif_QBGLWA.j   !! ','  ,
        !! Dif_QBGLWX.j   !! ','  ,
        !! Dif_QBGLAS.j
        "EXECIO 1 DISKW OUFL5 (STEM OUTREC. "
  end
 
  /**************************************/
  /* Another record for Storage stats   */
  /*************************************/
        /* Buid output record */
        outrec.1= sm100sid !! ',' !! sm100ssi !! ','  ,
        !! '"'sm100dtex'"'  !! ','   ,
        !! run_fmt_time    !! ','   ,
        !! run_hh          !! ','   ,
        !! f2mb(TotalRealUsedByDB2) !! ','   ,
        !! f2mb(qw0225rl_dbm1)   !! ','   ,
        !! f2mb(qw0225rl_Dist)   !! ','   ,
        !! f2mb(qw0225ShrStg_Real)    !! ','   ,
        !! f2mb(qw0225ShrStkStg_Real) !! ','   ,
        !! f2mb(QW0225ComStg_Real) !! ','   ,
    !! f2mb(qw0225ax_dbm1)          !! ',' ,
    !! f2mb(qw0225ax_Dist)          !! ',' ,
    !! f2mb(QW0225ShrStg_Aux)       !! ',' , /* ShAux slots used SSID */
    !! f2mb(QW0225ShrStkStg_Aux)    !! ',' , /* ShStak slots SSID */
    !! f2mb(QW0225ComStg_Aux)       !! ',' , /* Common Aux SSID*/
    !! f2mb(QW0225SHRINREAL)   !! ',',       /* Share backed by Real*/
    !! f2mb(TotalAuxlUsedByDB2)     !! ',' ,        /*for LPAR*/
    !! f2mb(TotalRealUsedBP)        !! ',' ,
    !! f2mb(TotalAuxUsedBP)         !! ',' ,
    !! f2mb(QW0225_REALAVAIL)       !! ',' ,  /* Real Available LPAR */
    !! b2mb(QW0225RG)               !! ',' ,
    !! b2mb(QW0225AV) /* How much DB2 thinks it is avail*/
 
        "EXECIO 1 DISKW OUFL3 (STEM OUTREC. "
  if BPSim  = 'Y' then
  do
  /*************************************/
  /* Simulation  Bufstats              */
  /* Loop  for each bufferpool ID      */
  /*************************************/
      do i = 1 to Simbp_entry.0
            j = Simbp_entry.i
            /* decode BPID to BP name */
            Select
                 When j >='0'   & j <= '50'    Then BPNm = 'BP'j
                 When j >='100' & j <= '109'   Then do
                                                      k    = j-100
                                                      BPNm = 'BP8K'k
                                                    end
                 When j >='120' & j <= '129'   Then do
                                                      k    = j-120
                                                      BPNm = 'BP16K'k
                                                    end
                 When j >='80'  & j <= '89'    Then do
                                                      k    = j-80
                                                      BPNm = 'BP32K'k
                                                    end
                 Otherwise do
                             BPNm = '?'j
                           end
            end
            if BPNm = 'BP32K0' then BPNm = 'BP32K'
            /* Buid output record */
            outrec.1= sm100sid !! ',' !! sm100ssi !! ','  ,
            !! '"'sm100dtex'"'  !! ','   ,
            !! run_fmt_time    !! ','   ,
            !! run_hh          !! ','   ,
            !! BPNm            !! ','   ,
            !! DifSimPage.i         !! ','   ,
            !! DifSimSeqPage.i      !! ','   ,
            !! DifSimSyncIO.i       !! ','   ,
            !! DifSimSeqSyncIO.i    !! ','   ,
            !! DifSimAsyncPage.i    !! ','   ,
            !! DifSimGBPSyncIO.i    !! ','   ,
            !! DifSimGBPSeqSyncIO.i !! ','   ,
            !! DifSimGBPAsyncPage.i !! ','   ,
            !! DifSimPageMov.i      !! ','   ,
            !! DifSimWaitSyncIO.i
            "EXECIO 1 DISKW OUFL4 (STEM OUTREC. "
      end
  end  /* If BPSim='Y' */
End /*If StatOnly=0 then do*/
 
return
 
 
/* SMF HEADER */
DSNDQWST:
   Ofs = Ofs + 1
   /* Smf record type   = X'64' =  100 */
   SM100RTY = C2D(SUBSTR(InpRec,Ofs,1))
   /* stop processing if not 100 */
   if sm100rty <> 100 then return 4
   Ofs = Ofs + 9
   /* Optimisation : Get Subsystem ID first */
   /* System Id = SMF ID */
   sm100sid = SUBSTR(InpRec,Ofs,4)
   Ofs = Ofs + 4
   /* Subsystem Id  */
   sm100ssi = SUBSTR(InpRec,Ofs,4)
   if sm100ssi <> ssid then return 4
   /* Go back to get time */
   Ofs = Ofs -12
   /* SM100TME DS XL4 TIME SMF MOVED RECORD */
   SM100TME = C2D(SUBSTR(InpRec,Ofs,4))
   Ofs = Ofs + 4
   if  sm100tme <> old_sm100tme then
   do
       CALL GET_FMT_TIME
       old_sm100tme=sm100tme
   end
   /* compute date only if there is a change */
   sm100dte_0 = C2X(SUBSTR(InpRec,Ofs,4))
   Ofs = Ofs + 18
 
   if sm100dte_0 = sm100dte_0Old then
                                      return 0
   /* sometimes it arrives that there is an old smf record .. bug*/
   if sm100dte_0 < sm100dte_0Old then do
            parse value sm100dte_0 with 1 . 2 c 3 yy 5 ddd 8 .
            say '!!!!!!!!!!!!!!!!!!!'
            say 'Anomaly in Smf record read inferior date met',
                '@' run_fmt_time '20'yy!!'.'!!ddd
                 return 4
              end
   parse value sm100dte_0 with 1 . 2 c 3 yy 5 ddd 8 .
   sm100dte    = '20'yy!!'.'!!ddd
   sm100dte_0Old = sm100dte_0
   /* get day of week : easier to select days */
   test_date = '20'yy ddd
   sm100dtex=DAT_MVS2SD(test_date)
   /* save date of smf records processed */
   if reco = 0 then save_date=sm100dte
   else do
     if save_date <> sm100dte & displ = 0 then do
        displ=1
        say 'There is 2 different dates in this SMF extract'
        say '             '  save_date sm100dte
        say ' '
     end
   end
   /* TOTAL LENGTH = 28 */
   Return 0
DSNDQWOS:
    /* Nb CPU */
    QWOSLNCP =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* CPU use. LPAR      */
    QWOSLPRU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* CPU use. DB2       */
    QWOSDB2U = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* CPU use. MSTR      */
    QWOSMSTU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* CPU use. DBM1      */
    QWOSDBMU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Page in rate LPAR       */
    QWOSLPIR = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Page in rate DB2        */
    QWOSDPIR = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Real Stor. LPAR         */
    QWOSLRST = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Real Stor. Free LPAR  (MB) */
    QWOSLRSF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Real Stor. used by this Db1 Mb */
    QWOSDRSU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Virt Stor. on this Lpar */
    QWOSLVST = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Virt Stor. free on this Lpar */
    QWOSLVSF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Virt Stor. used by Db2       */
    QWOSDVSU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Real Stor. used by this DB2 */
    QWOSLUIC = C2D(SUBSTR(InpRec,Ofs,4))
 /* Ofs = Ofs + 16  /* new 2021 */
    /* Real Stor. used by this DB2 */
    QWOSREAL = C2D(SUBSTR(InpRec,Ofs,8))
    Say 'QWOSREAL' QWOSREAL */
    return
 
dsndqist:
    numeric digits 15
    Ofs     =  Ofs +4
    /* Fields of these macro seems to be all cumulative */
    /* calculate difference between interval */
    /* check QIEYE */
      if  SUBSTR(InpRec,Ofs,4) <> 'QIST' then
        do
              say 'Mapping error QIST eye catcher not found'
              exit(8)
        end
 
    Ofs = Ofs + 4
    /* RID Interrupted  RDS Limit */
    /*  when Db2 facilitates incremental processing of the RIDs by */
    /*  retrieving one RID block of RIDs in advance (eg. used by */
    /*  adaptive index processing).  When more than one RID block is*/
    /*  required this is also considered as RDS limit exceeded */
    QISTRLLM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* RID Interrupted DM  Limit */
    /* (Physical limit of 16.6M Rids) */
    QISTRPLM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Highest RID blocks */
    QISTRHIG = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 16
    /* not optimal column proc */
    QISTCOLS = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    Ofs = Ofs + 36
    /* 32KB Wrkfile used instead of 4KB */
    QISTWFP1 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* 4 KB Wrkfile used instead of 32 KB */
    QISTWFP2 = C2D(SUBSTR(InpRec,Ofs,4))
  if QWHSRN= 'A1' then /* zones not available V10 */
  do
     QISTWMXU=0
     QISTWCTO=0
     QISTW4K=0
     QISTW32K=0
     QISTIMAC=0
     QISTIMSC=0
     QISTSIAC=0
     QISTSISC=0
     QISTWFRCUR=0
     QISTI2AC=0
     QISTI2OF=0
     QISTAMXU=0
     QISTWSTG=0
     QISTDGTTSTG=0
     QISTWFSTG=0
     QISTDGTTCTO=0
     QISTDGTTMXU=0
     QISTWFCTO=0
     QISTWFMXU=0
     QISTINPA =0
     QISTINPD =0
     QISTTRAVMIN =0
     QISTFTBCANT =0
     QISTFTBCAN =0
     QISTFTBSIZE =0
     QISTFTBNUMP =0
     QISTFTBNUMC =0
     QISTINPR =0
     QISTINPE =0
    return
  end
    Ofs = Ofs + 28
    /* hwm storage used by workfiles in KB */
    QISTWMXU = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current all workfile usage in KB : DGTT and Sort */
    QISTWCTO = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current 4K wrkfile storage usage in KB*/
    QISTW4K  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current 32K wrkfile storage usage in KB*/
    QISTW32K = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Nb DM in memory   wrkfiles active currently */
    QISTIMAC = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Space DM in memory active currently in KB*/
    QISTIMSC = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 24
    /* Nb SRT in memory   wrkfiles active currently */
    QISTSIAC = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Space SRT in memory active currently in bytes */
    QISTSISC = C2D(SUBSTR(InpRec,Ofs,8))
    QISTSISC = trunc(QISTSISC/1024) /* in KB */
    Ofs = Ofs + 32
    /* Current RID blocks overflowed (stored) in wrkfiles*/
    QISTWFRCUR=  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current NON Sort related workfiles active */
    QISTI2AC =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* Physical  workfiles created */
    QISTI2OF =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 24
    /* HWM wkfile storage used by an agent */
    QISTAMXU =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current storage configured for wkfiles*/
    QISTWSTG =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current DGTT  configured for wkfile KB*/
    QISTDGTTSTG = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current DGTT  used  KB*/
    QISTDGTTCTO = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* HWM     DGTT  used  KB*/
    QISTDGTTMXU = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current others  configured for wkfile KB*/
    QISTWFSTG = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current others used  KB*/
    QISTWFCTO = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* HWM    others used KB*/
    QISTWFMXU = C2D(SUBSTR(InpRec,Ofs,8))
 /* if  QWHSRN = 'B1' then        /* V11*/
       do
          QISTINPA =0
          QISTINPD =0
          QISTTRAVMIN =0
          QISTFTBCANT =0
          QISTFTBCAN =0
          QISTFTBSIZE =0
          QISTFTBNUMP =0
          QISTFTBNUMC =0
          QISTINPR =0
          QISTINPE =0
          return
       end */
    Ofs = Ofs + 8
    /* Fast Insert allocated */
    QISTINPA  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Fast Insert disabled  */
    QISTINPD  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* FTB Traverse count threshold (hidden zparm) */
    QISTTRAVMIN= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Indexes Eligible to FTB (Unique,key size <64 ...*/
    QISTFTBCANT= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Indexes Candidate to FTB (Eligible AND meet FTB  Threshold*/
    QISTFTBCAN = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* FTB Size                         */
    QISTFTBSIZE= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* FTB Indexes prev interval*/
    QISTFTBNUMP= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* FTB Indexes Used         */
    QISTFTBNUMC= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Fast Insert re-enabled attempt */
    QISTINPR   = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Fast Insert attempt success */
    QISTINPE   = C2D(SUBSTR(InpRec,Ofs,4))
    return
 
/***************************/
/* Group buffer pool stats */
/***************************/
dsndqbgl:
    numeric digits 15
    /* Group BPID */
    QBGLGN  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    QBGLFLG  =  SUBSTR(InpRec,Ofs,1)
    Ofs = Ofs + 1 + 3
    /* GBP Dependent Getpage */
    QBGLGG  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Syn.Read(XI)-Data returned (A in the formula ) */
    QBGLXD  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Syn.Read(XI)-No Data Return (B in the formula) */
    QBGLXR  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 24
    /* Sync Write  (from local BP to GBP) called User Write */
    QBGLSW  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 56
    /* ASync Write  (from local BP to GBP) called Syst Write */
    QBGLAW  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Pages castout (written from GBP to DASD) */
    QBGLRC  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 32
    /* Write requests failed no storage */
    /* QBGLWF  =  C2D(SUBSTR(InpRec,OFFSET,8)) */
    Ofs = Ofs + 104
    /* Write requests failed no storage secondary GBP */
    /* QBGL2F  =  C2D(SUBSTR(InpRec,OFFSET,8)) */
    /* Write Around */
    Ofs = Ofs + 136
    /* Page in write around  */
    QBGLWA  =  C2D(SUBSTR(InpRec,Ofs,8))
    if  QWHSRN > 'B1' then  /*v12*/
    do
       Ofs = Ofs + 8
       /* Asynchronous XI   */
       QBGLWX  =  C2D(SUBSTR(InpRec,Ofs,8))
       Ofs = Ofs + 16
       /* Suspensions due to Asyn XI */
       QBGLAS  =  C2D(SUBSTR(InpRec,Ofs,8))
       Ofs = Ofs + 8
    end
    else
    do
       QBGLWX =0;QBGLAS =0
       Ofs = Ofs + 32
    end
    /* End of macro QBGL */
    /*------------------------------------------------------------- */
    /* For GBP changed data pages estimation :                      */
    /* Tot changed pages = Pages Async Written + Pages Sync Written */
    /*                   + Pages Written around                     */
    /* Or  ???           = Pages Castout + Pages Wriiten around     */
    /*------------------------------------------------------------- */
 
    /*****************************/
    /* Processing the data read  */
    /*****************************/
 
    /* if there is a new bufferpool in the list */
    if qws10r7n > NbGBPEnt.0 then call record_gbp
    GBPGetPage.QBGLGN    = QBGLGG
    GBPXIReadRet.QBGLGN    = QBGLXD
    GBPXIReadNoRet.QBGLGN  = QBGLXR
    QBGLAW.QBGLGN  = QBGLAW
    QBGLSW.QBGLGN  = QBGLSW
    QBGLRC.QBGLGN  = QBGLRC
    QBGLWA.QBGLGN  = QBGLWA
    QBGLWX.QBGLGN  = QBGLWX
    QBGLAS.QBGLGN  = QBGLAS
 
    return
 
dsndqbst:
    numeric digits 15
    QBSTPID =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    QBSTGET =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTRIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 40
    QBSTPWS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTWIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    QBSTRPI =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTWPI =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Open Dataset */
    QBSTDSO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTIMW =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* Pages read seq Prefetch */
    QBSTSPP =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 56
    /* Nb SEQ PREFETCH (ASYNCHRONOUS) READ*/
    QBSTPIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* nb wkfile not created due to buffers resource */
    QBSTMAX =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 48
    /* nb of workfiles denied during sort/merge */
    QBSTWFD =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* nb of time sort not optimized due to BP shortage*/
    QBSTWFF =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 32
    /* nb of pages cast out  */
    QBSTPCO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* nb of cast out IO */
    QBSTCIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTVPL =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 24
    QBSTDIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTLIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTSGT =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTSIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs    =  Ofs +   112 /* 8*14*/
    /* Min SRLU */
    QBSTSMIN=  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Max SRLU */
    QBSTSMAX=  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Nb times SLRU = VPSEQT */
    QBSTHST =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Nb times Random getpage found in SRLU chain */
    QBSTRHS =  C2D(SUBSTR(InpRec,Ofs,8))
 /* if QWHSRN = 'B1' then /* V11*/
        Ofs = Ofs + 8
    else */
    Ofs = Ofs + 40 /*V12*/
 
    /******************************/
    /* End of macro QBST DSNDQBST */
    /******************************/
 
         /* if there is a new bufferpool in the list */
         if qws10r3n > NbBPEnt.0 then call record_bp
         BufGet.QBSTPID = QBSTGET
         BufRIO.QBSTPID=  QBSTRIO
         BufPWS.QBSTPID=  QBSTPWS
         BufWIO.QBSTPID=  QBSTWIO
         BufRPI.QBSTPID=  QBSTRPI
         BufWPI.QBSTPID=  QBSTWPI
         BufIMW.QBSTPID=  QBSTIMW
         BufDSO.QBSTPID=  QBSTDSO
         BufPIO.QBSTPID=  QBSTPIO
         BufPCO.QBSTPID=  QBSTPCO
         BufCIO.QBSTPID=  QBSTCIO
         BufVPL.QBSTPID=  QBSTVPL
         BufDIO.QBSTPID=  QBSTDIO
         BufLIO.QBSTPID=  QBSTLIO
         BufSIO.QBSTPID=  QBSTSIO
         BufSGT.QBSTPID=  QBSTSGT
         BufMIN.QBSTPID=  QBSTSMIN
         BufMAX.QBSTPID=  QBSTSMAX
         BufHST.QBSTPID=  QBSTHST
         BufRHS.QBSTPID=  QBSTRHS
    /*        'QBSTRIO=' QBSTRIO,     */
    /*        'QBSTWIO=' QBSTWIO,     */
    /*        'QBSTIMW=' QBSTIMW,     */
    /*    say 'QBSTPIO=' QBSTPIO,     */
    /*        'QBSTCIO=' QBSTCIO,     */
    /*        'QBSTDIO=' QBSTDIO,     */
    /*        'QBSTLIO=' QBSTLIO,     */
    /*        'QBSTSIO=' QBSTSIO      */
    return
/*--------------------*/
/* Simulated BP stats */
/*--------------------*/
DSNDQBSP:
    numeric digits 20
    /* Bpool ID */
    QBSPPID =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    QBSPCON = C2X(SUBSTR(InpRec,Ofs,1))
    Ofs = Ofs + 4
    /* Current Number of pages simulated */
    QBSPIUS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* Current number of seq pages simulated */
    QBSPSUS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* Random Sync read  */
    QBSPDRR =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Seq    Sync read  */
    QBSPDRS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Pages Async Reads */
    QBSPDRA =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* GBP Random Sync read  */
    QBSPGRR =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* GBP Seq Sync read  */
    QBSPGRS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* GBP Pages Async Reads */
    QBSPGRA =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Pages moved into Simulated pool */
    QBSPMVI =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Total wait for sync/IO  */
    QBSPDTM =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs    = Ofs    + 16 /* Yes, there is a bug */
 
    /* Check in simulated BP list */
    do i = 1 to Simbp_entry.0
              if QBSPPID = Simbp_entry.i then leave
    end
    /* not found => new entry */
    if i > Simbp_entry.0 then
           do
               Simbp_entry.0 = Simbp_entry.0 + 1
               j            = Simbp_entry.0
               Simbp_entry.j = QBSPPID
 
               SimPage.j = 0
               SimSeqPage.j = 0
               SimSyncIO.j = 0
               SimSeqSyncIO.j = 0
               SimAsyncPage.j = 0
               SimGBPSyncIO.j = 0
               SimGBPSeqSyncIO.j = 0
               SimGBPAsyncPage.j = 0
               SimPageMov.j = 0
               SimWaitSyncIO.j = 0
           end
 
    /* Check in simulated BP list */
    do i = 1 to Simbp_entry.0
              if QBSPPID = Simbp_entry.i then leave
    end
    /* not found => error  */
    if i > Simbp_entry.0 then
           do
               say 'Abnormal error '
               exit 8
           end
    /*-----------------------------------------------*/
    /* Difference between current and previous value */
    /*-----------------------------------------------*/
 
    /* Current Number of pages simulated */
    DifSimPage.i = QBSPIUS
    /* Current Number of seq pages simulated */
    DifSimSeqPage.i = QBSPSUS
    /* Random Sync read  */
    DifSimSyncIO.i = QBSPDRR - SimSyncIO.i
    /* Seq    Sync read  */
    DifSimSeqSyncIO.i = QBSPDRS - SimSeqSyncIO.i
    /* Pages Async Reads */
    DifSimAsyncPage.i = QBSPDRA - SimAsyncPage.i
    /* GBP Random Sync read  */
    DifSimGBPSyncIO.i = QBSPGRR - SimGBPSyncIO.i
    /* GBP Seq Sync read  */
    DifSimGBPSeqSyncIO.i = QBSPGRS - SimGBPSeqSyncIO.i
    /* GBP Pages Async Reads */
    DifSimGBPAsyncPage.i = QBSPGRA - SimGBPAsyncPage.i
    /* Pages moved into Simulated pool */
    DifSimPageMov.i = QBSPMVI - SimPageMov.i
    /* Total wait for sync/IO in ms  */
    DifSimWaitSyncIO.i = QBSPDTM - SimWaitSyncIO.i
 
    /*------------------------------------*/
    /* Save the values for next iteration */
    /* New => Previous                    */
    /*------------------------------------*/
    SimPage.i = QBSPIUS
    SimSeqPage.i = QBSPSUS
    SimSyncIO.i = QBSPDRR
    SimSeqSyncIO.i = QBSPDRS
    SimAsyncPage.i = QBSPDRA
    SimGBPSyncIO.i = QBSPGRR
    SimGBPSeqSyncIO.i = QBSPGRS
    SimGBPAsyncPage.i = QBSPGRA
    SimPageMov.i = QBSPMVI
    SimWaitSyncIO.i = QBSPDTM
 
    /******************************/
    /* End of macro QBST DSNDQBST */
    /******************************/
 
    return
ifcid_diff:
       /* Cumulative values, report only the difference */
       /* When diff is negative, this means that the value have been*/
       /* reset (Seen at DB2 restart , but probably also if they    */
       /* reach their max)                                          */
              Dif_QDSTPOOL=       QDSTPOOL      - Old_QDSTPOOL
              Dif_QDSTQDBT=       QDSTQDBT      - Old_QDSTQDBT
              Dif_QDSTQCRT=       QDSTQCRT      - Old_QDSTQCRT
              Dif_QDSTNDBA=       QDSTNDBA      - Old_QDSTNDBA
              Dif_MstrTcb =       MstrTcb       - Old_MstrTcb
              Dif_MstrSrb =       MstrSrb       - Old_MstrSrb
              Dif_MstrpSRB=       MstrpSRB      - Old_MstrpSRB
              Dif_MstrpSRB_ziip = MstrpSRB_ziip - Old_MstrpSRB_ziip
              Dif_dbm1Tcb =       dbm1Tcb       - Old_dbm1Tcb
              Dif_dbm1srb =       dbm1srb       - Old_dbm1srb
              Dif_dbm1pSRB=       dbm1pSRB      - Old_dbm1pSRB
              Dif_dbm1pSRB_ziip = dbm1pSRB_ziip - Old_dbm1pSRB_ziip
              Dif_irlmTcb =       irlmTcb       - Old_irlmTcb
              Dif_irlmsrb =       irlmsrb       - Old_irlmsrb
              Dif_irlmpSRB=       irlmpSRB      - Old_irlmpSRB
              Dif_irlmpSRB_ziip = irlmpSRB_ziip - Old_irlmpSRB_ziip
              Dif_DistTcb =       distTcb       - Old_DistTcb
              Dif_Distsrb =       distsrb       - Old_Distsrb
              Dif_DistpSRB=       distpSRB      - Old_DistpSRB
              Dif_DistpSRB_ziip = distpSRB_ziip - Old_DistpSRB_ziip
 
        if    Dif_MstrTcb < 0 then
        do
              say '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!§'
              say 'Cumulative fields reset, possible DB2 RECYCLE'
              say '      at' sm100dte run_fmt_time
              say '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!§'
              say ''
              Recycle_Time=Run_fmt_time
 
 
              Dif_QDSTPOOL=       QDSTPOOL
              Dif_QDSTQDBT=       QDSTQDBT
              Dif_QDSTQCRT=       QDSTQCRT
              Dif_QDSTNDBA=       QDSTNDBA
              Dif_MstrTcb =       MstrTcb
              Dif_MstrSrb =       MstrSrb
              Dif_MstrpSRB=       MstrpSRB
              Dif_MstrpSRB_ziip = MstrpSRB_ziip
              Dif_dbm1Tcb =       dbm1Tcb
              Dif_dbm1srb =       dbm1srb
              Dif_dbm1pSRB=       dbm1pSRB
              Dif_dbm1pSRB_ziip = dbm1pSRB_ziip
              Dif_irlmTcb =       irlmTcb
              Dif_irlmsrb =       irlmsrb
              Dif_irlmpSRB=       irlmpSRB
              Dif_irlmpSRB_ziip = irlmpSRB_ziip
              Dif_DistTcb =       distTcb
              Dif_Distsrb =       distsrb
              Dif_DistpSRB=       distpSRB
              Dif_DistpSRB_ziip = distpSRB_ziip
 
        end
              Old_QDSTPOOL=       QDSTPOOL
              Old_QDSTQDBT=       QDSTQDBT
              Old_QDSTQCRT=       QDSTQCRT
              Old_QDSTNDBA=       QDSTNDBA
              Old_Mstrtcb =       Mstrtcb
              Old_MstrSrb =       MstrSrb
              Old_MstrpSRB=       MstrpSRB
              Old_MstrpSRB_ziip = MstrpSRB_ziip
              Old_dbm1Tcb =       dbm1Tcb
              Old_dbm1srb =       dbm1srb
              Old_dbm1pSRB=       dbm1pSRB
              Old_dbm1pSRB_ziip = dbm1pSRB_ziip
              Old_irlmTcb =       irlmTcb
              Old_irlmsrb =       irlmsrb
              Old_irlmpSRB=       irlmpSRB
              Old_irlmpSRB_ziip = irlmpSRB_ziip
              Old_DistTcb =       distTcb
              Old_Distsrb =       distsrb
              Old_DistpSRB=       distpSRB
              Old_DistpSRB_ziip = distpSRB_ziip
 
       /*********************************/
       /* Subsystem services stats QTDS */
       /*********************************/
          Dif_QTABINDA=   QTABINDA -Old_QTABINDA
          Dif_QTABIND =   QTABIND  -Old_QTABIND
          Dif_QTAUTOBA=   QTAUTOBA -Old_QTAUTOBA
          Dif_QTPKABND=   QTPKABND -Old_QTPKABND
          Dif_QTDSDRN =     QTDSDRN-Old_QTDSDRN
          Dif_QTPCCT  =     QTPCCT -Old_QTPCCT
          Dif_QVLSLC14=    QVLSLC14-Old_QVLSLC14
          Dif_QVLSLC19=    QVLSLC19-Old_QVLSLC19
          Dif_QVLSLC24=    QVLSLC24-Old_QVLSLC24
          Dif_QVLSLC31=    QVLSLC31-Old_QVLSLC31
          Dif_QVLSLC32=    QVLSLC32-Old_QVLSLC32
          if  Dif_QTDSDRN < 0 then
          do
              Dif_QTABINDA=   QTABINDA
              Dif_QTABIND =   QTABIND
              Dif_QTAUTOBA=   QTAUTOBA
              Dif_QTPKABND=   QTPKABND
              Dif_QTDSDRN =   QTDSDRN
              Dif_QTPCCT  =   QTPCCT
              Dif_QVLSLC14=    QVLSLC14
              Dif_QVLSLC19=    QVLSLC19
              Dif_QVLSLC24=    QVLSLC24
              Dif_QVLSLC31=    QVLSLC31
              Dif_QVLSLC32=    QVLSLC32
          end
          Old_QTABINDA=   QTABINDA
          Old_QTABIND =   QTABIND
          Old_QTAUTOBA=   QTAUTOBA
          Old_QTPKABND=   QTPKABND
          Old_QTDSDRN =   QTDSDRN
          Old_QTPCCT  =   QTPCCT
          Old_QVLSLC14=    QVLSLC14
          Old_QVLSLC19=    QVLSLC19
          Old_QVLSLC24=    QVLSLC24
          Old_QVLSLC31=    QVLSLC31
          Old_QVLSLC32=    QVLSLC32
       /*********************************/
       /* Subsystem services stats Q3ST */
       /*********************************/
              Dif_Q3STSIGN =     Q3STSIGN-Old_Q3STSIGN
              Dif_Q3STTERM =     Q3STTERM-Old_Q3STTERM
              Dif_Q3STCTHD =     Q3STCTHD-Old_Q3STCTHD
              Dif_Q3STPREP =     Q3STPREP-Old_Q3STPREP
              Dif_Q3STCOMM =     Q3STCOMM-Old_Q3STCOMM
              Dif_Q3STABRT =     Q3STABRT-Old_Q3STABRT
              Dif_Q3STCTHW =     Q3STCTHW-Old_Q3STCTHW
 
          if  Dif_Q3STCTHD < 0 then
          do
              Dif_Q3STSIGN = Q3STSIGN
              Dif_Q3STTERM = Q3STTERM
              Dif_Q3STCTHD = Q3STCTHD
              Dif_Q3STPREP = Q3STPREP
              Dif_Q3STCOMM = Q3STCOMM
              Dif_Q3STABRT = Q3STABRT
              Dif_Q3STCTHW = Q3STCTHW
          end
 
          Old_Q3STSIGN = Q3STSIGN
          Old_Q3STTERM = Q3STTERM
          Old_Q3STCTHD = Q3STCTHD
          Old_Q3STPREP = Q3STPREP
          Old_Q3STCOMM = Q3STCOMM
          Old_Q3STABRT = Q3STABRT
          Old_Q3STCTHW = Q3STCTHW
 
       /***************************/
       /* buffer pool stats       */
       /***************************/
 
 
      /****************************************/
      /* dsndqjst Log  Manager stats IFCID 001*/
      /****************************************/
      Dif_QJSTWRNW = QJSTWRNW - Old_QJSTWRNW
      Dif_QJSTWRW = QJSTWRW - Old_QJSTWRW
      Dif_QJSTWRF  = QJSTWRF  - Old_QJSTWRF
      Dif_QJSTBFFL = QJSTBFFL - Old_QJSTBFFL
      Dif_QJSTALR  = QJSTALR  - Old_QJSTALR
      Dif_QJSTWTB  = QJSTWTB  - Old_QJSTWTB
      Dif_QJSTCIOF = QJSTCIOF - Old_QJSTCIOF
      Dif_QJSTWUR  = QJSTWUR  - Old_QJSTWUR
      Dif_QJSTBPAG = QJSTBPAG - Old_QJSTBPAG
      Dif_QJSTRBUF = QJSTRBUF - Old_QJSTRBUF
      Dif_QJSTRACT = QJSTRACT - Old_QJSTRACT
      Dif_QJSTRARH = QJSTRARH - Old_QJSTRARH
      Dif_QJSTTVC  = QJSTTVC  - Old_QJSTTVC
      Dif_QJSTBSDS = QJSTBSDS - Old_QJSTBSDS
      if  Dif_QJSTBFFL < 0 then  do
              Dif_QJSTWRNW = QJSTWRNW
              Dif_QJSTWRW = QJSTWRW
              Dif_QJSTWRF  = QJSTWRF
              Dif_QJSTBFFL = QJSTBFFL
              Dif_QJSTALR  = QJSTALR
              Dif_QJSTRBUF = QJSTRBUF
              Dif_QJSTRACT = QJSTRACT
              Dif_QJSTRARH = QJSTRARH
              Dif_QJSTTVC  = QJSTTVC
              Dif_QJSTBSDS = QJSTBSDS
              Dif_QJSTCIOF = QJSTCIOF
              Dif_QJSTWUR  = QJSTWUR
              Dif_QJSTBPAG = QJSTBPAG
              Dif_QJSTWTB  = QJSTWTB
      end
      Old_QJSTWRNW = QJSTWRNW
      Old_QJSTWRW = QJSTWRW
      Old_QJSTWRF  = QJSTWRF
      Old_QJSTRBUF = QJSTRBUF
      Old_QJSTRACT = QJSTRACT
      Old_QJSTRARH = QJSTRARH
      Old_QJSTTVC  = QJSTTVC
      Old_QJSTBSDS = QJSTBSDS
      Old_QJSTBFFL = QJSTBFFL
      Old_QJSTALR  = QJSTALR
      Old_QJSTWTB  = QJSTWTB
      Old_QJSTCIOF = QJSTCIOF
      Old_QJSTWUR  = QJSTWUR
      Old_QJSTBPAG = QJSTBPAG
 
      /****************************************/
      /* dsndqist Data Manager stats IFCID 002 */
      /****************************************/
              Dif_QWSDCKPT = QWSDCKPT - Old_QWSDCKPT /*checkpoints*/
              Dif_QTGSLSLM = QTGSLSLM - Old_QTGSLSLM
              Dif_QTGSCSLM = QTGSCSLM - Old_QTGSCSLM
              Dif_QTGSUSLM = QTGSUSLM - Old_QTGSUSLM
              Dif_QTGSIGLO = QTGSIGLO - Old_QTGSIGLO
              Dif_QTGSSGLO = QTGSSGLO - Old_QTGSSGLO
              Dif_QTGSFLSE = QTGSFLSE - Old_QTGSFLSE
              Dif_QTGSKIDS = QTGSKIDS - Old_QTGSKIDS
              Dif_QTXADEA  = QTXADEA  - Old_QTXADEA
              Dif_QTXASLOC = QTXASLOC - Old_QTXASLOC
              Dif_QTXATIM  = QTXATIM  - Old_QTXATIM
              Dif_QTXALES  = QTXALES  - Old_QTXALES
              Dif_QTXALEX  = QTXALEX  - Old_QTXALEX
              Dif_QTXANPL  = QTXANPL  - Old_QTXANPL
              Dif_QTXASLAT = QTXASLAT - Old_QTXASLAT
              Dif_QTXASOTH = QTXASOTH - Old_QTXASOTH
              Dif_QTXALOCK = QTXALOCK - Old_QTXALOCK
              Dif_QTXAUNLK = QTXAUNLK - Old_QTXAUNLK
              Dif_QTXAQRY  = QTXAQRY  - Old_QTXAQRY
              Dif_QTXACHG  = QTXACHG  - Old_QTXACHG
              Dif_QTXAIRLM = QTXAIRLM - Old_QTXAIRLM
              Dif_QTXACLNO = QTXACLNO - Old_QTXACLNO
              Dif_QTXADRNO = QTXADRNO - Old_QTXADRNO
              Dif_QXSELECT = QXSELECT - Old_QXSELECT
              Dif_QXINSRT  = QXINSRT  - Old_QXINSRT
              Dif_QXUPDTE  = QXUPDTE  - Old_QXUPDTE
              Dif_QXDELET  = QXDELET  - Old_QXDELET
              Dif_QXFETCH  = QXFETCH  - Old_QXFETCH
              Dif_QXSTFND  = QXSTFND  - Old_QXSTFND
              Dif_QXSTNFND = QXSTNFND - Old_QXSTNFND
              Dif_QXSTIPRP = QXSTIPRP - Old_QXSTIPRP
              Dif_QXSTNPRP = QXSTNPRP - Old_QXSTNPRP
              Dif_QXSTDEXP = QXSTDEXP - Old_QXSTDEXP
              Dif_QXNSMIAP = QXNSMIAP - Old_QXNSMIAP
              Dif_QXMRMIAP = QXMRMIAP - Old_QXMRMIAP
              Dif_QXWFRIDS = QXWFRIDS - Old_QXWFRIDS
              Dif_QXWFRIDT = QXWFRIDT - Old_QXWFRIDT
              Dif_QXHJINCS = QXHJINCS - Old_QXHJINCS
              Dif_QXHJINCT = QXHJINCT - Old_QXHJINCT
              Dif_QXSISTOR = QXSISTOR - Old_QXSISTOR
              if  QWHSRN > 'B1' then
              do
         Dif_QXRWSINSRTDAlg1 = QXRWSINSRTDAlg1-Old_QXRWSINSRTDAlg1
         Dif_QXRWSINSRTDAlg2 = QXRWSINSRTDAlg2-Old_QXRWSINSRTDAlg2
         Dif_QXRSDMAD=QXRSDMAD-Old_QXRSDMAD
         Dif_QXRFMIAP=QXRFMIAP-Old_QXRFMIAP
              end
              Dif_QISECTG  = QISECTG  - Old_QISECTG
              Dif_QISECTL  = QISECTL  - Old_QISECTL
              Dif_QISEDBDG = QISEDBDG - Old_QISEDBDG
              Dif_QISEDBDL = QISEDBDL - Old_QISEDBDL
              Dif_QISEKTG  = QISEKTG  - Old_QISEKTG
              Dif_QISEKTL  = QISEKTL  - Old_QISEKTL
              Dif_QISEDSG  = QISEDSG  - Old_QISEDSG
              Dif_QISEDSI  = QISEDSI  - Old_QISEDSI
              Dif_QISTRLLM = QISTRLLM - Old_QISTRLLM
              Dif_QISTRPLM = QISTRPLM - Old_QISTRPLM
              Dif_QISTCOLS = QISTCOLS - Old_QISTCOLS
              Dif_QISTWFP1 = QISTWFP1 - Old_QISTWFP1
              Dif_QISTWFP2 = QISTWFP2 - Old_QISTWFP2
              Dif_QISTI2OF = QISTI2OF - Old_QISTI2OF
 
      if  Dif_QWSDCKPT <0 then
              Dif_QWSDCKPT = QWSDCKPT
 
      if  Dif_QXSELECT <0 then
      do
              Dif_QISTRLLM = QISTRLLM
              Dif_QISECTG  = QISECTG
              Dif_QISECTL  = QISECTL
              Dif_QISEDBDG = QISEDBDG
              Dif_QISEDBDL = QISEDBDL
              Dif_QISEKTG  = QISEKTG
              Dif_QISEKTL  = QISEKTL
              Dif_QISEDSG  = QISEDSG
              Dif_QISEDSI  = QISEDSI
              Dif_QTGSLSLM = QTGSLSLM
              Dif_QTGSCSLM = QTGSCSLM
              Dif_QTGSUSLM = QTGSUSLM
              Dif_QTGSIGLO = QTGSIGLO
              Dif_QTGSSGLO = QTGSSGLO
              Dif_QTGSFLSE = QTGSFLSE
              Dif_QTGSKIDS = QTGSKIDS
              Dif_QTXADEA  = QTXADEA
              Dif_QTXASLOC = QTXASLOC
              Dif_QTXATIM  = QTXATIM
              Dif_QTXALES  = QTXALES
              Dif_QTXALEX  = QTXALEX
              Dif_QTXANPL  = QTXANPL
              Dif_QTXASLAT = QTXASLAT
              Dif_QTXASOTH = QTXASOTH
              Dif_QTXALOCK = QTXALOCK
              Dif_QTXAUNLK = QTXAUNLK
              Dif_QTXAQRY  = QTXAQRY
              Dif_QTXACHG  = QTXACHG
              Dif_QTXAIRLM = QTXAIRLM
              Dif_QTXACLNO = QTXACLNO
              Dif_QTXADRNO = QTXADRNO
              Dif_QXSELECT = QXSELECT
              Dif_QXINSRT  = QXINSRT
              Dif_QXUPDTE  = QXUPDTE
              Dif_QXDELET  = QXDELET
              Dif_QXFETCH  = QXFETCH
              Dif_QXSTFND  = QXSTFND
              Dif_QXSTNFND = QXSTNFND
              Dif_QXSTIPRP = QXSTIPRP
              Dif_QXSTNPRP = QXSTNPRP
              Dif_QXSTDEXP = QXSTDEXP
              Dif_QXNSMIAP = QXNSMIAP
              Dif_QXMRMIAP = QXMRMIAP
              Dif_QXWFRIDS = QXWFRIDS
              Dif_QXWFRIDT = QXWFRIDT
              Dif_QXHJINCS = QXHJINCS
              Dif_QXHJINCT = QXHJINCT
              Dif_QXSISTOR = QXSISTOR
              if  QWHSRN > 'B1' then
              do
                Dif_QXRWSINSRTDAlg1 = QXRWSINSRTDAlg1
                Dif_QXRWSINSRTDAlg2 = QXRWSINSRTDAlg2
                Dif_QXRSDMAD = QXRSDMAD
                Dif_QXRFMIAP = QXRFMIAP
              end
              Dif_QISTRPLM = QISTRPLM
              Dif_QISTCOLS = QISTCOLS
              Dif_QISTWFP1 = QISTWFP1
              Dif_QISTWFP2 = QISTWFP2
              Dif_QISTI2OF = QISTI2OF
      end
              Old_QWSDCKPT = QWSDCKPT
 
              Old_QISTRLLM = QISTRLLM
              Old_QISECTG  = QISECTG
              Old_QISECTL  = QISECTL
              Old_QISEDBDG = QISEDBDG
              Old_QISEDBDL = QISEDBDL
              Old_QISEKTG  = QISEKTG
              Old_QISEKTL  = QISEKTL
              Old_QISEDSG  = QISEDSG
              Old_QISEDSI  = QISEDSI
              Old_QTGSLSLM = QTGSLSLM
              Old_QTGSCSLM = QTGSCSLM
              Old_QTGSUSLM = QTGSUSLM
              Old_QTGSIGLO = QTGSIGLO
              Old_QTGSSGLO = QTGSSGLO
              Old_QTGSFLSE = QTGSFLSE
              Old_QTGSKIDS = QTGSKIDS
              Old_QTXADEA  = QTXADEA
              Old_QTXASLOC = QTXASLOC
              Old_QTXATIM  = QTXATIM
              Old_QTXALES  = QTXALES
              Old_QTXALEX  = QTXALEX
              Old_QTXANPL  = QTXANPL
              Old_QTXASLAT = QTXASLAT
              Old_QTXASOTH = QTXASOTH
              Old_QTXALOCK = QTXALOCK
              Old_QTXAUNLK = QTXAUNLK
              Old_QTXAQRY  = QTXAQRY
              Old_QTXACHG  = QTXACHG
              Old_QTXAIRLM = QTXAIRLM
              Old_QTXACLNO = QTXACLNO
              Old_QTXADRNO = QTXADRNO
              Old_QXSELECT = QXSELECT
              Old_QXINSRT  = QXINSRT
              Old_QXUPDTE  = QXUPDTE
              Old_QXDELET  = QXDELET
              Old_QXFETCH  = QXFETCH
              Old_QXSTFND  = QXSTFND
              Old_QXSTNFND = QXSTNFND
              Old_QXSTIPRP = QXSTIPRP
              Old_QXSTNPRP = QXSTNPRP
              Old_QXSTDEXP = QXSTDEXP
              Old_QXNSMIAP = QXNSMIAP
              Old_QXMRMIAP = QXMRMIAP
              Old_QXWFRIDS = QXWFRIDS
              Old_QXWFRIDT = QXWFRIDT
              Old_QXHJINCS = QXHJINCS
              Old_QXHJINCT = QXHJINCT
              Old_QXSISTOR = QXSISTOR
              if  QWHSRN > 'B1' then
              do
                Old_QXRWSINSRTDAlg1 = QXRWSINSRTDAlg1
                Old_QXRWSINSRTDAlg2 = QXRWSINSRTDAlg2
                Old_QXRSDMAD = QXRSDMAD
                Old_QXRFMIAP = QXRFMIAP
              end
              Old_QISTRPLM = QISTRPLM
              Old_QISTCOLS = QISTCOLS
              Old_QISTWFP1 = QISTWFP1
              Old_QISTWFP2 = QISTWFP2
              Old_QISTI2OF = QISTI2OF
 
      return
DispVStor:
  if vsm='Y' & reco > 0 then
  do
    Say ' '; say ' '
    Say 'Threads observed Max : ' MaxThdSee 'at' MaxThdSeeDate,
                                                 MaxThdSeeTime
    Say '                 Min : ' MinThdSee 'at' MinThdSeeDate,
                                                 MinThdSeeTime
    Say ' '; say ' '
    Say 'Max Threads allowed projected with this period is : '
    Say '    ' floor(MinThdComp) 'at' MinThdCompDate MinThdCompTime,
        '/' floor(MaxThdComp) 'at' MaxThdCompDate MaxThdCompTime
    Say '    Formula without Min/Max applied : '
    Say '    ' floor(MinThdComp2) 'at' MinThdComp2Date MinThdComp2Time,
        '/' floor(MaxThdComp2) 'at' MaxThdComp2Date MaxThdComp2Time
    Say ' '
    Say 'DBM1, Max Real Storage is : ' format(MaxReal4K_dbm1,5,2),
        'MB at ' Date_MaxReal4K_dbm1 time_MaxReal4K_dbm1
    Say '                   Min is : ' ,
                             format(MinReal4K_dbm1,5,2) 'MB at ',
           Date_MinReal4K_dbm1 time_MinReal4K_dbm1
    Say 'DIST, Max Real Storage is : ' format(MaxReal4K_Dist,5,2),
        'MB at ' Date_MaxReal4K_Dist time_MaxReal4K_Dist
    Say '                   Min is : ' ,
                          format(MinReal4K_Dist,5,2) 'MB at ',
         Date_MinReal4K_Dist time_MinReal4K_Dist
    Say ' '
    Say 'Max Real Storage used by LPAR :' MaxRealLPAR ' Frames --',
               f2mb(MaxRealLPAR)  ' in MB'
    Say '       at ' time_MaxRealLPAR
    temp=MinQW0225_REALAVAIL*4096 / 1048576      /* in MB*/
    Say 'Min Real Storage available for LPAR : ' MinQW0225_REALAVAIL,
                'Frames --' f2mb(MinQW0225_REALAVAIL) ' MB'
    Say '       at ' Date_MinQW0225_REALAVAIL time_MinQW0225_REALAVAIL
    Say ' '
    Say 'Max Aux Storage used by DB2  :' MaxDB2AuxUse ' Slots  --',
           f2mb(MaxDB2AuxUse)        ' MB'
    Say '       at ' DateMaxDB2AuxUse timeMaxDB2AuxUse
  end
return
init_var:
  if  QWHSRN > 'B1' then  /*v12*/
  do
      Dif_QXRWSINSRTDAlg1=0
      Dif_QXRWSINSRTDAlg2=0
      Dif_QXRFMIAP=0
  end
  nbr_ifcid=0
  GBPCount   =0
  HistCKPT.0 =0
  HistRWRO.0 =0
  tsayLocal=0
  tsayNoDDF=0
 
  /* nb of buffers recorded*/
  NbBPEnt.0=0
  NbGBPEnt.0=0
  /* nb of simulated buffers recorded*/
  SimBp_Entry.0=0
  if vsm='Y' then
      do
           MaxND=0
           MinAS=999999999999999
           MinTS=999999999999999
           MaxTF=0
           MaxThdSee =0
           MaxThdComp=0
           MaxThdComp2=0
           MinThdSee =999999999999999
           MinThdComp=999999999999999
           MinThdComp2=999999999999999
           MaxReal4K_dbm1=0
           MinReal4K_dbm1=999999999999999
           MaxReal4K_Dist=0
           MinReal4K_Dist=999999999999999
           MinQW0225_REALAVAIL=999999999999999
           MaxRealLPAR = 0
           MaxDB2AuxUse = -1
      end
  /* init counters */
  Old_QDSTPOOL= 0
  Old_QDSTQDBT= 0
  Old_QDSTQCRT= 0
  Old_QDSTNDBA= 0
  Old_QTABINDA= 0
  Old_QTABIND = 0
  Old_QTAUTOBA= 0
  Old_QTPKABND= 0
  Old_QTDSDRN = 0
  Old_QTPCCT  = 0
  Old_QVLSLC14=  0
  Old_QVLSLC19=  0
  Old_QVLSLC24=  0
  Old_QVLSLC31=  0
  Old_QVLSLC32=  0
  Old_QBSTGET = 0
  Old_QBSTRIO = 0
  Old_QBSTPWS = 0
  Old_QBSTDSO = 0
  Old_QBSTIMW = 0
  Old_QBSTWIO = 0
  Old_QBSTRPI = 0
  Old_QBSTWPI = 0
  Old_QBSTPIO = 0
  Old_QBSTPCO = 0
  Old_QBSTCIO = 0
  Old_QBSTDIO = 0
  Old_QBSTLIO = 0
  Old_QBSTSIO = 0
  Old_QBSTSGT = 0
  Old_QBSTHST = 0
  Old_QBSTRHS = 0
 
  Old_QJSTBFFL  = 0
  Old_QJSTALR   = 0
  Old_QJSTWRNW  = 0
  Old_QJSTWRW  = 0
  Old_QJSTRBUF = 0
  Old_QJSTRACT = 0
  Old_QJSTRARH = 0
  Old_QJSTTVC  = 0
  Old_QJSTBSDS = 0
  Old_QJSTWRF =0
  Old_QJSTWTB   = 0
  Old_QJSTCIOF  = 0
  Old_QJSTWUR   = 0
  Old_QJSTBPAG  = 0
 
  Old_QISTRLLM  = 0
  Old_QISECTG   = 0
  Old_QISECTL   = 0
  Old_QISEDBDG  = 0
  Old_QISEDBDL  = 0
  Old_QISEKTG   = 0
  Old_QISEKTL   = 0
  Old_QISEDSG   = 0
  Old_QISEDSI   = 0
  Old_QWSDCKPT  = 0
  Old_QTGSLSLM  = 0
  Old_QTGSCSLM  = 0
  Old_QTGSUSLM  = 0
  Old_QTGSIGLO  = 0
  Old_QTGSSGLO  = 0
  Old_QTGSFLSE  = 0
  Old_QTGSKIDS  = 0
  Old_QTXADEA   = 0
  Old_QTXASLOC  = 0
  Old_QTXATIM   = 0
  Old_QTXALES   = 0
  Old_QTXALEX   = 0
  Old_QTXANPL   = 0
  Old_QTXASLAT  = 0
  Old_QTXASOTH  = 0
  Old_QTXALOCK  = 0
  Old_QTXAUNLK  = 0
  Old_QTXAQRY   = 0
  Old_QTXACHG   = 0
  Old_QTXAIRLM  = 0
  Old_QTXACLNO  = 0
  Old_QTXADRNO  = 0
  Old_QXSELECT  = 0
  Old_QXINSRT   = 0
  Old_QXUPDTE   = 0
  Old_QXDELET   = 0
  Old_QXFETCH   = 0
  Old_QXNSMIAP  = 0
  Old_QXSTFND   = 0
  Old_QXSTNFND  = 0
  Old_QXSTIPRP  = 0
  Old_QXSTNPRP  = 0
  Old_QXSTDEXP  = 0
  Old_QXMRMIAP  = 0
  Old_QXWFRIDS  = 0
  Old_QXWFRIDT  = 0
  Old_QXHJINCS  = 0
  Old_QXHJINCT  = 0
  Old_QXSISTOR = 0
  Old_QXRWSINSRTDAlg1 = 0
  Old_QXRWSINSRTDAlg2 = 0
  Old_QXRSDMAD = 0
  Old_QXRFMIAP = 0
  Old_QISTRPLM  = 0
  Old_QISTCOLS  = 0
  Old_QISTWFP1  = 0
  Old_QISTWFP2  = 0
  Old_QISTI2OF  = 0
 
  Old_Q3STSIGN = 0
  Old_Q3STTERM = 0
  Old_Q3STCTHD = 0
  Old_Q3STPREP = 0
  Old_Q3STCOMM = 0
  Old_Q3STABRT = 0
  Old_Q3STCTHW = 0
 
 
  Old_MstrTcb =       0
  Old_MstrSrb =       0
  Old_MstrpSRB=       0
  Old_MstrpSRB_ziip = 0
  Old_dbm1Tcb =       0
  Old_dbm1srb =       0
  Old_dbm1pSRB=       0
  Old_dbm1pSRB_ziip = 0
  Old_irlmTcb =       0
  Old_irlmsrb =       0
  Old_irlmpSRB=       0
  Old_irlmpSRB_ziip = 0
  Old_DistTcb =       0
  Old_Distsrb =       0
  Old_DistpSRB=       0
  Old_DistpSRB_ziip = 0
 
 
  /* compteurs input/output */
  reco= 0
  reci= 0
  recs= 0
 
  min_time ='26:00:00'
  max_time ='ZZ:00:00'
  min_date ='2100.000'
  max_date ='1900.000'
  /* reinit IFCID 2 data */
  call DSNDQXST0
  return
 
FLOOR: procedure
parse arg F
return TRUNC(F) - (F < 0) * (F <> TRUNC(F))
 
CEIL: procedure
parse arg C
return TRUNC(C) + (C > 0) * (C <> TRUNC(C))
/* convert 4K frames to MB */
f2mb:
 arg num
 num = format(num*4/1024,,2)
 return num
/* convert bytes to MB */
b2mb:
 arg num
 num = format(num/1048576,,0)
 return num
comp_sum_bpstats:
        /* we have all the stats for each bpid */
        /* now compare with old value to get the Dif and then*/
        /* have the sum */
         do i = 1 to NbBPEnt.0
            j = NbBPEnt.i
            /*--*/
            /* if value is given by DB2 */
            if  BufGET.j > 0  then
            do
                 Diff= BufGet.j- OBufGet.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufGet.j
                      Sum_QBSTGET = 0
                 end
                 Det_GET.j =  Diff
                 Sum_QBSTGET = Sum_QBSTGET + Diff
                 /*--*/
                 Diff= BufRIO.j- OBufRIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufRIO.j
                      Sum_QBSTRIO = 0
                 end
                 Det_RIO.j =  Diff
                 Sum_QBSTRIO = Sum_QBSTRIO + Diff
                 /*--*/
                 Diff= BufPWS.j- OBufPWS.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufPWS.j
                      Sum_QBSTPWS = 0
                 end
                 Det_PWS.j =  Diff
                 Sum_QBSTPWS = Sum_QBSTPWS + Diff
                 /*--*/
                 Diff= BufIMW.j- OBufIMW.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufIMW.j
                      Sum_QBSTIMW = 0
                 end
                 Det_IMW.j =  Diff
                 Sum_QBSTIMW = Sum_QBSTIMW + Diff
                 /*--*/
                 Diff= BufDSO.j- OBufDSO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufDSO.j
                      Sum_QBSTDSO = 0
                 end
                 Det_DSO.j =  Diff
                 Sum_QBSTDSO = Sum_QBSTDSO + Diff
                 /*--*/
                 Diff= BufWIO.j- OBufWIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufWIO.j
                      Sum_QBSTWIO = 0
                 end
                 Det_WIO.j =  Diff
                 Sum_QBSTWIO = Sum_QBSTWIO + Diff
                 /*--*/
                 Diff= BufRPI.j- OBufRPI.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufRPI.j
                      Sum_QBSTRPI = 0
                 end
                 Det_RPI.j =  Diff
                 /* Display_Detail
                 if  Diff > 0 then
                   do
                      Say 'Page In Read :'diff '-BP#'j,
                        '-IO/s' strip(format(Det_RIO.j/60,8,0))
                   end
                 End_Display_Detail */
                 Sum_QBSTRPI = Sum_QBSTRPI + Diff
                 /*--*/
                 Diff= BufWPI.j- OBufWPI.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufWPI.j
                      Sum_QBSTWPI = 0
                 end
                 Det_WPI.j =  Diff
                 Sum_QBSTWPI = Sum_QBSTWPI + Diff
                 /*--*/
                 Diff= BufPIO.j- OBufPIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufPIO.j
                      Sum_QBSTPIO = 0
                 end
                 Det_PIO.j =  Diff
                 Sum_QBSTPIO = Sum_QBSTPIO + Diff
                 /*--*/
                 Diff= BufPCO.j- OBufPCO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufPCO.j
                      Sum_QBSTPCO = 0
                 end
                 Det_PCO.j =  Diff
                 Sum_QBSTPCO = Sum_QBSTPCO + Diff
                 /*--*/
                 Diff= BufCIO.j- OBufCIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufCIO.j
                      Sum_QBSTCIO = 0
                 end
                 Det_CIO.j =  Diff
                 Sum_QBSTCIO = Sum_QBSTCIO + Diff
                 /*--*/
                 Diff= BufDIO.j- OBufDIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufDIO.j
                      Sum_QBSTDIO = 0
                 end
                 Det_DIO.j =  Diff
                 Sum_QBSTDIO = Sum_QBSTDIO + Diff
                 /*--*/
                 Diff= BufLIO.j- OBufLIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufLIO.j
                      Sum_QBSTLIO = 0
                 end
                 Det_LIO.j =  Diff
                 Sum_QBSTLIO = Sum_QBSTLIO + Diff
                 /*--*/
                 Diff= BufSGT.j- OBufSGT.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufSGT.j
                      Sum_QBSTSGT = 0
                 end
                 Det_SGT.j =  Diff
                 Sum_QBSTSGT = Sum_QBSTSGT + Diff
                 /*--*/
                 Diff= BufSIO.j- OBufSIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufSIO.j
                      Sum_QBSTSIO = 0
                 end
                 Det_SIO.j =  Diff
                 Sum_QBSTSIO = Sum_QBSTSIO + Diff
                 /*--*/
                 Diff= BufHST.j- OBufHST.j
                 /* db2 recycle */
                 if Diff < 0 then
                      Diff= BufHST.j
                 Det_HST.j =  Diff
                 /*--*/
                 Diff= BufRHS.j- OBufRHS.j
                 /* db2 recycle */
                 if Diff < 0 then
                      Diff= BufRHS.j
                 Det_RHS.j =  Diff
                 /*--*/
            end
            else
            do
                 Det_GET.j = 0
                 Det_RIO.j = 0
                 Det_PWS.j = 0
                 Det_IMW.j = 0
                 Det_DSO.j = 0
                 Det_WIO.j = 0
                 Det_RPI.j = 0
                 Det_WPI.j = 0
                 Det_PIO.j = 0
                 Det_PCO.j = 0
                 Det_CIO.j = 0
                 Det_DIO.j = 0
                 Det_LIO.j = 0
                 Det_SIO.j = 0
                 Det_SGT.j = 0
                 Det_HST.j = 0
                 Det_RHS.j = 0
            end
         end
   return
comp_diff_gbpstats:
        /* We have all the stats for each bpid */
        /* now compare with old value to get the Dif */
         GBPCount = GBPCount+1
         do i = 1 to NbGBPEnt.0
            j = NbGBPEnt.i
            /*--*/
            /* if value is given in the SMF record */
            if  GBPGetpage.j > 0  then
            do
                 Dif_GBPGetpage.j= GBPGetpage.j - oGBPGetpage.j
                 if Dif_GBPGetpage.j < 0 then
                 do
                      Dif_GBPGetpage.j= GBPGetpage.j
                 end
                 /*--*/
                 Dif_GBPXIReadRet.j= GBPXIReadRet.j -,
                                      oGBPXIReadRet.j
                 if Dif_GBPXIReadRet.j < 0 then
                 do
                      Dif_GBPXIReadRet.j= GBPXIReadRet.j
                 end
                 /*--*/
                 Dif_GBPXIReadNoRet.j= GBPXIReadNoRet.j -,
                                      oGBPXIReadNoRet.j
                 if Dif_GBPXIReadNoRet.j < 0 then
                 do
                 end
                 /*--*/
                 Dif_QBGLAW.j= QBGLAW.j - oQBGLAW.j
                 if Dif_QBGLAW.j < 0 then
                 do
                      Dif_QBGLAW.j= QBGLAW.j
                 end
                 /*--*/
                 Dif_QBGLSW.j= QBGLSW.j - oQBGLSW.j
                 if Dif_QBGLSW.j < 0 then
                 do
                      Dif_QBGLSW.j= QBGLSW.j
                 end
                 /*--*/
                 Dif_QBGLRC.j= QBGLRC.j - oQBGLRC.j
                 if Dif_QBGLRC.j < 0 then
                 do
                      Dif_QBGLRC.j= QBGLRC.j
                 end
                 /*--*/
                 Dif_QBGLWA.j= QBGLWA.j - oQBGLWA.j
                 if Dif_QBGLWA.j < 0 then
                 do
                      Dif_QBGLWA.j= QBGLWA.j
                 end
                 /*--*/
                 Dif_QBGLWX.j= QBGLWX.j - oQBGLWX.j
                 if Dif_QBGLWX.j < 0 then
                 do
                      Dif_QBGLWX.j= QBGLWX.j
                 end
                 /*--*/
                 Dif_QBGLAS.j= QBGLAS.j - oQBGLAS.j
                 if Dif_QBGLAS.j < 0 then
                 do
                      Dif_QBGLAS.j= QBGLAS.j
                 end
            end
            else
            do
                 Dif_GBPGetPage.j =  0
                 Dif_GBPXIReadRet.j =  0
                 Dif_GBPXIReadNoRet.j =  0
                 Dif_QBGLAW.j =  0
                 Dif_QBGLSW.j =  0
                 Dif_QBGLRC.j =  0
                 Dif_QBGLWA.j =  0
                 Dif_QBGLWX.j =  0
                 Dif_QBGLAS.j =  0
            end
            /* compute sum for every 15 values = 15 minutes */
            /* not a rolling average because too much CPU for usage*/
            Sum_GBPXIReadRet.j   =  Sum_GBPXIReadRet.j +,
                          Dif_GBPXIReadRet.j
            Sum_GBPXIReadNoRet.j =  Sum_GBPXIReadNoRet.j +,
                          Dif_GBPXIReadNoRet.j
            if GBPCount = 15 then
            do
               GBPXIMissRatio.j = Sum_GBPXIReadNoRet.j /,
                      (1+Sum_GBPXIReadNoRet.j + Sum_GBPXIReadRet.j)
               Sum_GBPXIReadRet.j   =  Dif_GBPXIReadRet.j
               Sum_GBPXIReadNoRet.j =  Dif_GBPXIReadNoRet.j
               GBPCount=0
            end
            else GBPXIMissRatio.j=0
         end /* loop */
   return
init_sum_bpstats:
          Sum_QBSTGET = 0
          Sum_QBSTRIO = 0
          Sum_QBSTPWS = 0
          Sum_QBSTIMW = 0
          Sum_QBSTDSO = 0
          Sum_QBSTWIO = 0
          Sum_QBSTRPI = 0
          Sum_QBSTWPI = 0
          Sum_QBSTPIO = 0
          Sum_QBSTPCO = 0
          Sum_QBSTCIO = 0
          Sum_QBSTDIO = 0
          Sum_QBSTLIO = 0
          Sum_QBSTSGT = 0
          Sum_QBSTSIO = 0
 
         /* raz all figures for all bufferpool */
         do i = 1 to NbBPEnt.0
            j = NbBPEnt.i
            BufGet.j = 0
            BufRIO.j = 0
            BufPWs.j = 0
            BufIMW.j = 0
            BufDSO.j = 0
            BufWIO.j = 0
            BufRPI.j = 0
            BufWPI.j = 0
            BufPIO.j = 0
            BufPCO.j = 0
            BufCIO.j = 0
            BufVPL.j = 0
            BufDIO.j = 0
            BufLIO.j = 0
            BufSGT.j = 0
            BufSIO.j = 0
            BufHST.j = 0
            BufRHS.j = 0
         end
     return
init_gbpstats:
         /* raz all figures for all bufferpool */
         do i = 1 to NbGBPEnt.0
            j = NbGBPEnt.i
            GBPGetpage.j=0
            GBPXIReadRet.j=0
            GBPXIReadNoRet.j=0
            QBGLAW.j=0
            QBGLSW.j=0
            QBGLRC.j=0
            QBGLWA.j=0
            QBGLWX.j=0
            QBGLAS.j=0
         end
     return
switch_bpstats:
         /* new to Old only if new value exists */
         do i = 1 to NbBPEnt.0
            j = NbBPEnt.i
            oBufGet.j = BufGet.j
            oBufRIO.j = BufRIO.j
            oBufPWS.j = BufPWS.j
            oBufIMW.j = BufIMW.j
            oBufDSO.j = BufDSO.j
            oBufWIO.j = BufWIO.j
            oBufRPI.j = BufRPI.j
            oBufWPI.j = BufWPI.j
            oBufPIO.j = BufPIO.j
            oBufPCO.j = BufPCO.j
            oBufCIO.j = BufCIO.j
            oBufDIO.j = BufDIO.j
            oBufLIO.j = BufLIO.j
            oBufSGT.j = BufSGT.j
            oBufSIO.j = BufSIO.j
            oBufHST.j = BufHST.j
            oBufRHS.j = BufRHS.j
         end   /* end do */
     return
switch_bpstatx:
         /* new to Old only if new value exists */
         do i = 1 to NbBPEnt.0
            j = NbBPEnt.i
            if BufGet.j > 0  then do
              oBufGet.j = BufGet.j
              oBufRIO.j = BufRIO.j
              oBufPWS.j = BufPWS.j
              oBufIMW.j = BufIMW.j
              oBufDSO.j = BufDSO.j
              oBufWIO.j = BufWIO.j
              oBufRPI.j = BufRPI.j
              oBufWPI.j = BufWPI.j
              oBufPIO.j = BufPIO.j
              oBufPCO.j = BufPCO.j
              oBufCIO.j = BufCIO.j
              oBufDIO.j = BufDIO.j
              oBufLIO.j = BufLIO.j
              oBufSGT.j = BufSGT.j
              oBufSIO.j = BufSIO.j
              oBufHST.j = BufHST.j
              oBufRHS.j = BufRHS.j
            end   /* end if */
         end /* end do ...*/
     return
switch_gbpstats:
         /* new to Old only if new value exists */
         do i = 1 to NbGBPEnt.0
            j = NbGBPEnt.i
            if GBPGetPage.j > 0 then do
               oGBPGetPage.j  =GBPGetPage.j
               oGBPXIReadRet.j  =GBPXIReadRet.j
               oGBPXIReadNoRet.j=GBPXIReadNoRet.j
               oQBGLAW.j=QBGLAW.j
               oQBGLSW.j=QBGLSW.j
               oQBGLRC.j=QBGLRC.j
               oQBGLWA.j=QBGLWA.j
               oQBGLWX.j=QBGLWX.j
               oQBGLAS.j=QBGLAS.j
            end
         end   /* end do */
     return
record_bp:
     /* add a new bufferpool id in the list */
           do i = 1 to NbBPEnt.0
              if QBSTPID = NbBPEnt.i then leave
           end
           /* not found => new entry */
           if i > NbBPEnt.0 then
           do
               NbBPEnt.0 = NbBPEnt.0 + 1
               j            = NbBPEnt.0
               NbBPEnt.j = QBSTPID
 
               oBufGet.QBSTPID = 0
               oBufRIO.QBSTPID = 0
               oBufPWS.QBSTPID = 0
               oBufIMW.QBSTPID = 0
               oBufDSO.QBSTPID = 0
               oBufWIO.QBSTPID = 0
               oBufRPI.QBSTPID = 0
               oBufWPI.QBSTPID = 0
               oBufPIO.QBSTPID = 0
               oBufPCO.QBSTPID = 0
               oBufCIO.QBSTPID = 0
               oBufDIO.QBSTPID = 0
               oBufLIO.QBSTPID = 0
               oBufSIO.QBSTPID = 0
               oBufSGT.QBSTPID = 0
               oBufHST.QBSTPID = 0
               oBufRHS.QBSTPID = 0
           end
   return
record_gbp:
     /* add a new bufferpool id in the list */
           do i = 1 to NbGBPEnt.0
              if QBGLGN  = NbGBPEnt.i then leave
           end
           /* not found => new entry */
           if i > NbGBPEnt.0 then
           do
               NbGBPEnt.0 = NbGBPEnt.0 + 1
               j            = NbGBPEnt.0
               NbGBPEnt.j = QBGLGN
               oGBPGetPage.QBGLGN  = 0
               oGBPXIReadRet.QBGLGN  = 0
               oGBPXIReadNoRet.QBGLGN  = 0
               oQBGLAW.QBGLGN  = 0
               oQBGLSW.QBGLGN  = 0
               oQBGLRC.QBGLGN  = 0
               oQBGLWA.QBGLGN  = 0
               oQBGLWX.QBGLGN  = 0
               oQBGLAS.QBGLGN  = 0
               Sum_GBPXIReadRet.QBGLGN  = 0
               Sum_GBPXIReadNoRet.QBGLGN  = 0
           end
   return
/********************************************************/
/* Check individual parameters for best practices alert */
/* (Checkcounters)                                      */
/********************************************************/
CheckForAlert:
    /*************************************/
    /*  V12 features                     */
    /*************************************/
    if  QWHSRN  > 'B1' then  /* V12 */
    do
      /* Insert Algorithm 2 usage */
      if Dif_QXRWSINSRTDAlg2 > 0 then
          do
             say 'Insert Algoritm 2 is used',
             '£'Dif_QXRWSINSRTDAlg2' à' substr(run_fmt_time,1,5)
          end
      /* FTB Usage */
      if (QISTFTBNUMC - QISTFTBCAN) > 0 then
          do
             say 'FTB Usage not optimal : Current is' QISTFTBNUMC,
             'Candidates is:' QISTFTBCAN' à' substr(run_fmt_time,1,5)
          end
      /* RiDList not done  */
      if Dif_QXRFMIAP> 0     then
          do
             say 'Warning : RID list processing was not used',
             '#'Dif_QXRFMIAP' à' substr(run_fmt_time,1,5)
             retcode=3
          end
    End   /* End V12 feature */
    /*************************************/
    /*  End DB2 12                       */
    /*************************************/
 
    /* No space to create SPARSE IX BUILT WF */
    /* Source V11 Transaction Monitoring Redbook */
    if Dif_QXSISTOR> 0     then
        do
           say 'Warning : No space to create Sparse Ix WF',
           '£'Dif_QXSISTOR' à' substr(run_fmt_time,1,5)
           retcode=3
        end
    /* RiD list no workfile */
    if Dif_QXWFRIDS> 0     then
        do
           say 'Warning : RID goes to workfile, no storage RIDPOOL',
           '£'Dif_QXWFRIDS' à' substr(run_fmt_time,1,5)
           retcode=3
        end
    /* Auth cache PLan  error */
    /*
       QTAUCHK (all checks attempts)
       QTAUSUC (all checks successful)
       QTAUCCH successful plan auth checks
       QTPACAUT successful pack auth checks
       QTPACNOT unsucc pack not found in cache
       QTRACAUT User define  functions and sp
    */
    /* Autobind failed */
    if Dif_QTABIND < Dif_QTABINDA   then
       do
         say 'Warning :Autobind Plan failed',
         ' à' substr(run_fmt_time,1,5),
         '£Bind attemps:'Dif_QTABINDA,
         '£Bind success:'Dif_QTABIND
         retcode=3
       end
    if Dif_QTAUTOBA >Dif_QTPKABND   then
       do
         say 'Warning :Autobind Pack failed',
         ' à' substr(run_fmt_time,1,5),
         '£Bind attemps:'Dif_QTAUTOBA,
         '£Bind success:'Dif_QTPKABND
         retcode=3
       end
    /* Drain Close  */
    if Dif_QTDSDRN  > 0 then
             do
               say 'Warning : Drain Close DSMAX reached. Close#:',
               Dif_QTDSDRN  '#Cur DS:' QTDSOPN,
               '@' substr(run_fmt_time,1,5)
               retcode=3
             end
    /* Latch classes*/
    /* Put in stem for automatic processing */
    LCcl.1 = 14 /* Bufferpool LRU */
    LCVal.1=Dif_QVLSLC14
    LCcl.2 = 19 /* Log write */
    LCVal.2=Dif_QVLSLC19
    LCcl.3 = 24  /* EDM thread alloc, BM prefetch, unlatch serial.*/
    LCVal.3=Dif_QVLSLC24
    LCcl.4 = 31 /* Storage manager */
    LCVal.4=Dif_QVLSLC31
    LCcl.5 = 32 /* Storage manager */
    LCVal.5=Dif_QVLSLC32
    do i = 1 to 5
       if LCVal.i > 60000 then /* alerts if > 1000 events/s */
       do
         say 'Warning : Latch class' Lccl.i '> 1000/s',
         LCVal.i      ' à' substr(run_fmt_time,1,5)
         retcode=3
       end
    end i
    /* 32k used 4k preferred */
    if Dif_QISTWFP1 > 0 then
             do
               say 'Warning : Workfile - 32K used 4K preferred.',
               Dif_QISTWFP1 ' à' substr(run_fmt_time,1,5)
               retcode=3
             end
    /* 4K  used 32K preferred */
    if Dif_QISTWFP2 > 0 then
             do
               say 'Warning : Workfile - 4K used 32K preferred.',
               Dif_QISTWFP2 ' à' substr(run_fmt_time,1,5)
               retcode=3
             end
    /* Log Output Buffer unavailable */
    if Dif_QJSTWTB  > 0 then
             do
               say 'Warning : Wait - Log Output Buffer Unavail.',
               Dif_QJSTWTB  ' à' substr(run_fmt_time,1,5)
               retcode=3
             end
    /* Log Output Buffer Page In     */
    if Dif_QJSTBPAG > 0 then
             do
               say 'Warning : Log Output Buffer Page In',
             Dif_QJSTBPAG   ' à' substr(run_fmt_time,1,5)
               retcode=3
             end
    /* CTHREAD reached */
    if Dif_Q3STCTHW > 0 then
             do
               say 'Warning : CTHREAD reached, Thread queued :',
                  Dif_Q3STCTHW  ' à' substr(run_fmt_time,1,5)
               retcode=3
             end
    /* MAXDBAT reached */
    if Dif_QDSTQDBT > 0 then
             do
               say 'Warning : MAXDBAT reached, DBAT queued :',
                  Dif_QDSTQDBT  ' à' substr(run_fmt_time,1,5)
               retcode=3
             end
    if Dif_QDSTQCRT > 0 then
             do
               say 'Warning : CONDBAT reached, Conn rejected :',
                  Dif_QDSTQCRT ' à' substr(run_fmt_time,1,5)
               retcode=3
             end
    if QDSTNQR2 > 0 & QDSTNQAV > 0.01 then
             do
               say 'Warning : Type2 queued too long,£:' !!,
               QDSTNQR2 ' à' substr(run_fmt_time,1,5) ,
               '- Avg wait:'QDSTNQAV
               retcode=3
             end
    /* Global Dynamic Stmt cache hit ratio > 90% */
    if (Dif_QXSTFND+Dif_QXSTNFND) > 100 then do
        Hit = Dif_QXSTFND / (Dif_QXSTFND+Dif_QXSTNFND + 0.01)
        if Hit < 0.90 then
                 do
                   say 'Warning : Global Dyn. Cache Hit < 90%',
                      format(Hit,3,2) ' à' substr(run_fmt_time,1,5)
                   retcode=4
                 end
    end
    if (Dif_QXSTNPRP + Dif_QXSTIPRP) > 100 then do
    /* Local  Dynamic Stmt cache hit ratio > 70% */
    /* Source Optimizing DB2 System Performance using db2 statistics*/
        Hit = Dif_QXSTNPRP/ (Dif_QXSTNPRP + Dif_QXSTIPRP + 0.01)
        if Hit = 0   then do
               if tsaylocal=0 then do
                 say 'Warning : Local Dyn. Cache probably not used'
                 tsayLocal = 1
               end
        end
        else if Hit < 0.70 then
                 do
                   say 'Warning : Local Dyn. Cache Hit < 70%',
                      format(Hit,3,2) ' à' substr(run_fmt_time,1,5)
                   retcode=4
                 end
    end
    /* Checkpoints */
       period= 15
       if HistCKPT.0 < period then
       do
          /* store the value for sliding */
          HistCKPT.0 = HistCKPT.0 + 1
          j=HistCKPT.0
          HistCKPT.j = Dif_QWSDCKPT
       end
       else do /* decaler pour prendre que les 15 dernieres */
          i=1
          sum=0
          do until i= period
              j=i+1
              HistCKPT.i = HistCKPT.j
              sum = sum+HistCKPT.j
              i=i+1
          end
          HistCKPT.i = Dif_QWSDCKPT  /*i= period */
          sum = sum+HistCKPT.i
          if sum  > 9 then /* 1 checkpoint each 5/10 mn is OK */
             do
               say 'Warning : Checkpoint frequency too high' sum,
                   'for' period 'minutes à' substr(run_fmt_time,1,5)
               retcode=4
             end
       end
 
    /* RWRO Switch */
       period= 5
       if HistRWRO.0 < period then
       do
          HistRWRO.0 = HistRWRO.0 + 1
          j=HistRWRO.0
          HistRWRO.j = Dif_QTPCCT
       end
       else do /* push stack */
          i=1
          sum=0
          do until i= period
              j=i+1
              HistRWRO.i = HistRWRO.j
              sum = sum+HistRWRO.j
              i=i+1
          end
          HistRWRO.i = Dif_QTPCCT    /*i= period */
          sum = sum+HistRWRO.i
          /* 15 switch per minute is acceptable */
          if sum  > (15* period)  & Dif_Dbm1Srb >5 then
             do
               say 'Warning : RWRO switch too high' sum,
                   'for' period 'minutes à' substr(run_fmt_time,1,5),
                   'Dbm1Srb:'Dif_Dbm1Srb
               retcode=4
             end
       end
    /* Page Ins    */
    /* for BpId level : uncomment section Display_Detail */
          if (Sum_QBSTRPI  > 0 §  Sum_QBSTWPI > 0),
             & Sum_QBSTRIO/60 > 600 then
             do
               say 'Warning : Page in for Read/Write happened',
                   ' à' substr(run_fmt_time,1,5) ,
                   Sum_QBSTRPI Sum_QBSTWPI,
                   'SyncIO/s:' format(Sum_QBSTRIO/60,9,0)
               retcode=4
             end
 return
record_ifcid:
   found=0
   do i = 1 to nbr_ifcid
      if ifcid_st.i = ifcid then
         do
            found=1
            ifcid_count.i=ifcid_count.i+1
            leave
         end
   end
   /* not found : add new ifcid to list*/
   if found=0 then
      do
         nbr_ifcid = nbr_ifcid + 1
         ifcid_st.nbr_ifcid = ifcid
         ifcid_count.nbr_ifcid = 1
      end
   return
report_ifcid:
  say ' '
  say 'List of IFCIDS read in this SMF file :' nbr_ifcid
  say 'IFCID/Description/Count'
  do i=1 to nbr_ifcid
      Select
           When ifcid_st.i = 01 then
                      ifcid_desc='System stats - processed'
           When ifcid_st.i = 02 then
                      ifcid_desc='DB2 stats'
           When ifcid_st.i = 202 then
                      ifcid_desc='BP attributes'
           When ifcid_st.i = 230 then
                      ifcid_desc='GBP attributes'
           When ifcid_st.i = 225 then
                      ifcid_desc='Storage Stats'
           When ifcid_st.i = 402 then
                      ifcid_desc='Profile Stats'
           otherwise
                      ifcid_desc='Unknow'
 
      end   /* select */
     say ifcid_st.i  ifcid_desc ifcid_count.i
   end /* end do */
   say ' '
   return
/*---------------------------------------*/
/* Date functions from Chuck Meyer paper */
/*---------------------------------------*/
/*---------------------*/
/* yyyyddd => yyyymmdd */
/*---------------------*/
DAT_MVS2SD: Procedure
Parse Value REVERSE(arg(1)) With 1 j +3 y
Parse Value REVERSE(j y) With y j
If LENGTH(y) = 2 Then y = YY2YYYY(y)
months = '31' (28 + LY?(y)) ,
'31 30 31 30 31 31 30 31 30 31'
Do m = 1 To 12 While j > WORD(months,m)
j = j - WORD(months,m)
End
Return RIGHT(y,4,0) !! RIGHT(m,2,0) !! RIGHT(j,2,0)
/*---------------------*/
/* Is this leap year ? */
/*---------------------*/
LY?: Procedure
Parse Arg 1 y +4
Return ((y//4)=0)
stck:
Arg TUNITS
  TIMESTAMP = Copies(0,26)  /* force result length=26 */
  Address linkpgm "BLSUXTOD TUNITS TIMESTAMP"
  /* variable Timestamp has the value of timestamp */
  TSDate=substr(timestamp,1,10)
  TSTime=substr(timestamp,12,08)
  return
 
AllocS01:
   /* close file */
   address TSO "EXECIO 0 DISKW OUFL (FINIS"
   rcwrite = rc
   if rcwrite<> 0 then Do
      say "**********************************************"
      say "   Error writting OUFL file: " rcwrite
      say "   Abnormal end  AllocS01"
      say "**********************************************"
      Exit 8
   end
   /* Free */
   "FREE DD(OUFL)"
   oufl = "'" !! hlq !! '.reports.' !! ssid'.S02' !!  "'"
   "DELETE" oufl "PURGE"
   "ALLOC FI(OUFL) DA("oufl") NEW CATALOG REUSE" ,
   "lrecl(1800) RECFM(V B) TRACKS SPACE(200,200)"
   RcAlloc = rc
   if RcAlloc <> 0 then Do
        say "**********************************************"
        say "   Error allocating report file" oufl  RcAlloc
        say "   Abnormal end  AllocS01"
        say "**********************************************"
        Exit 8
   end
return
AllocS02:
   /* close file */
   address TSO "EXECIO 0 DISKW OUFL (FINIS"
   rcwrite = rc
   if rcwrite<> 0 then Do
      say "**********************************************"
      say "   Error writting OUFL file: " rcwrite
      say "   Abnormal end  AllocS02"
      say "**********************************************"
      Exit 8
   end
   /* Free */
   "FREE DD(OUFL)"
   oufl = "'" !! hlq !! '.reports.' !! ssid'.S03' !!  "'"
   "DELETE" oufl "PURGE"
   "ALLOC FI(OUFL) DA("oufl") NEW CATALOG REUSE" ,
   "lrecl(1800) RECFM(V B) TRACKS SPACE(200,200)"
   RcAlloc = rc
   if RcAlloc <> 0 then Do
        say "**********************************************"
        say "   Error allocating report file" oufl  RcAlloc
        say "   Abnormal end  AllocS02"
        say "**********************************************"
        Exit 8
   end
return
AllocS03:
   /* close file */
   address TSO "EXECIO 0 DISKW OUFL (FINIS"
   rcwrite = rc
   if rcwrite<> 0 then Do
      say "**********************************************"
      say "   Error writting OUFL file: " rcwrite
      say "   Abnormal end  AllocS03"
      say "**********************************************"
      Exit 8
   end
   /* Free */
   "FREE DD(OUFL)"
   oufl = "'" !! hlq !! '.reports.' !! ssid'.S04' !!  "'"
   "DELETE" oufl "PURGE"
   "ALLOC FI(OUFL) DA("oufl") NEW CATALOG REUSE" ,
   "lrecl(1800) RECFM(V B) TRACKS SPACE(200,200)"
   RcAlloc = rc
   if RcAlloc <> 0 then Do
        say "**********************************************"
        say "   Error allocating report file" oufl  RcAlloc
        say "   Abnormal end  AllocS03"
        say "**********************************************"
        Exit 8
   end
return
