/*REXX*/
numeric digits 15
/*-------------------------------------------------------------*/
/* Extract SMF 100 records - written by Nguyen Duc Tuan        */
/*                                      ndt.db2àgmail.com      */
/* Developed and tested on DB2 V11 in Guyancourt, FRANCE       */
/*   4 jan 2016     Release 1.1                                */
/*  14 jan 2016     Release 1.2 add dsnqdst ddf stats          */
/*  11 fev 2016     Release 1.2.1 correct imprecision          */
/*                  on bp figures (numeric digits)             */
/*  25 fev 2016     Release 2.0   Ifcid225 cur. threads        */
/*                  vsm=Y   option to calculate max thread     */
/*                  possible + central storage usage           */
/*  15 Apr 2016     Release 2.1   More displays for threads    */
/*                  calculation - Verification OK with values  */
/*                  from IBM Rexx MEMU                         */
/*  20 Apr 2016     Release 2.2   More columns for storage     */
/*                  monitoring                                 */
/*  03 Jul 2016     Release 2.3   Process Data Manager Section */
/*                  (DSNDQIST macro with difference)           */
/*  06 Jul 2016     Release 2.4   Correction abend in TF=...   */
/*                  when number of tasks = 0                   */
/*                  Able to process  records from several days */
/*  29 Jul 2016     Release 2.5   Minor fixes +Logs created    */
/*  13 Oct 2016     Release 2.6   Add Q3ST stats               */
/*                  (Signon, Terminate, Create Threads ..)     */
/*                  and Datasets Stats                         */
/*  16 Dec 2016     Release 2.7   PageIns buffer Stats         */
/*  02 Mar 2017     Release 3.0   Improve Bufferpool stats     */
/*  21 Mar 2017     Release 3.1   More Bufferpools stats and   */
/*                  warning messages                           */
/*  25 Apr 2017     Release 3.2   BP memory usage in Real and  */
/*                  Auxiliary                                  */
/*  11 May 2017     DSC stats (Full Prepare, Short, ...) Locks */
/*  24 May 2017     Z/OS Stats (must activate zparm) R3.4      */
/*  16 Aug 2017     Add BP simulated stats R3.5                */
/*  11 Oct 2017     Release 3.6 Add Workfile usage stats       */
/*  02 Feb 2018     Release 3.7 Add more QISE stats (DBDsteal  */
/*  02 Mar 2018     Group Buffer Pool stats + check            */
/*  25 Sep 2018     More stats (GBP...) and correction         */
/*  15 Nov 2018     Release 3.9 Correction error on QWSAPROC   */
/*  19 May 2019     Release 4.0 More columns                   */
/*  10 Sep 2019     More alerts (Latch class ..)               */
/*  19 Dec 2019     More alerts (Autobinds, Auth Cache)        */
/*  23 Mar 2020     FTB & Inserts Algo 2 - V12 Async XI        */
/*-------------------------------------------------------------*/
/*Comment : Change datasets high level identifier              */
/*-------------------------------------------------------------*/
ARG SSID hlq smforig Alert BpSim
retcode=0
/* Display Warning messages (best practices)*/
if Alert ='' then Alert='Y'
/* Bufferpool simulation */
if BpSim <> 'Y' then BpSim='N'
/* Virtual storage monitoring Yes/No */
VSM='Y'
 
say ' '
say 'Processing for Subsys' ssid
 
ifcid1_seen=0
if smforig='' then smforig='A'
if smforig='A' then
do
     /* Input file : SMF extract sorted */
     oufl = hlq !! '.SMFEXTS.OUT'
     "ALLOC DD(INP) DS('"oufl"') ,
                            SHR REU bufno(20)"
end
 
/* Report dataset on output (general stats) */
oufl = "'" !! hlq !! '.reports.' !! ssid !!  "'"
"DELETE" oufl "PURGE"
 
/* Report dataset on output (BP stats) */
oufl2= "'" !! hlq !! '.reportsb.' !! ssid !!  "'"
"DELETE" oufl2 "PURGE"
 
/* Report dataset on output (GBP stats) */
oufl5= "'" !! hlq !! '.reportsg.' !! ssid !!  "'"
"DELETE" oufl5 "PURGE"
 
/* Report dataset on output (STOR stats) */
oufl3= "'" !! hlq !! '.reportst.' !! ssid !!  "'"
"DELETE" oufl3 "PURGE"
 
/* Report dataset on output (BP Simulation stats) */
oufl4= "'" !! hlq !! '.repSimBP.' !! ssid !!  "'"
"DELETE" oufl4 "PURGE"
 
"ALLOC FI(OUFL) DA("oufl") NEW CATALOG REUSE" ,
"LRECL(1900) RECFM(V B) TRACKS SPACE(50,50)"
RcAlloc = rc
if RcAlloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl  RcAlloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end
 
"ALLOC FI(OUFL2) DA("oufl2") NEW CATALOG REUSE" ,
"LRECL(500) RECFM(V B) TRACKS SPACE(50,50)"
RcAlloc = rc
if RcAlloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl2 RcAlloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end
 
"ALLOC FI(OUFL5) DA("oufl5") NEW CATALOG REUSE" ,
"LRECL(130) RECFM(V B) TRACKS SPACE(50,50)"
RcAlloc = rc
if RcAlloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl5 RcAlloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end
 
"ALLOC FI(OUFL3) DA("oufl3") NEW CATALOG REUSE" ,
"LRECL(200) RECFM(V B) TRACKS SPACE(10,10)"
RcAlloc = rc
if RcAlloc <> 0 then Do
     say "**********************************************"
     say "   Error allocating report file" oufl3 RcAlloc
     say "   Abnormal end  "
     say "**********************************************"
     Exit 8
end
 
if BPSim = 'Y' then
do
    "ALLOC FI(OUFL4) DA("oufl4") NEW CATALOG REUSE" ,
    "LRECL(200) RECFM(V B) TRACKS SPACE(90,15)"
    RcAlloc = rc
    if RcAlloc <> 0 then Do
         say "**********************************************"
         say "   Error allocating report file" oufl3 RcAlloc
         say "   Abnormal end  "
         say "**********************************************"
         Exit 8
    end
end
/* init counters */
call init_var
/* WRITE report header */
CALL write_header
 
/* START PROCESSING */
DO FOREVER
  /* read SMF record one by one   */
  "EXECIO 1 DISKR INP"
  IF RC > 0 THEN DO
            if rc =  2 then
             do
              SAY 'End of input SMF file rc=' RC
              RcAlloc = rc
             end
             else do
              SAY 'Error while reading SMF file rc=' RC
              RcAlloc = 8
             end
              leave
            END
  PARSE PULL InpRec
  reci=reci+1
  Ofs = 1
  /* Decode SMF header */
  CALL DSNDQWST
  /* Process only SMF100 */
  IF (SM100RTY = 100  & SM100SSI = SSID  ) THEN
  DO
    /* record SMF records period   */
    if min_time > run_fmt_time then min_time=run_fmt_time
    if max_time < run_fmt_time then max_time=run_fmt_time
    if min_date > sm100dte     then min_date=sm100dte
    if max_date < sm100dte     then max_date=sm100dte
 
    /* Save  offset_self to reuse later */
    OfsSelf= Ofs
    /* go thru Self Def. section to go to Prod section*/
    Ofs = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs - 4 + 1
    /* Process Product section*/
    CALL DSNDQWHS
    Ofs=OfsSelf
    /* IFCID 1 must start the stats group */
    if   ifcid =  1 then
    do
          ifcid1_seen = 1
    end
    else if   ifcid <> 1 & ifcid1_seen = 0 then
                     do
                        iterate
                        say 'Bypass' ifcid
                        say 'Ifcid 1 must start the group'
                     end
    recs=recs+1
 
    /* record  ifcid in this smf data */
    call record_ifcid
    Select
         When ifcid     = 1  Then do
                                      CALL DSNDQWS0
                                      Ofs = QWS00PSO - 4 + 1
                                  end
         When ifcid     = 2  Then do
                                      CALL DSNDQWS1
                                      Ofs = QWS10PSO - 4 + 1
                                  end
     /*  When ifcid     = 199 Then do
                                      CALL QW0199
                                      Ofs = QWS10PSO - 4 + 1
                                  end  */
         When ifcid     = 225 Then do
                                      CALL QW0225
                                      Ofs = QWS10PSO - 4 + 1
                                  end
         Otherwise      do
                  /* add line here to avoid excessive displays */
                          /* 202 System param. attributes */
                          /* 230 DataSharing Global stats */
                          if  ifcid = 202 then nop
                          else
                              if  ifcid = 230 then nop
                          else
                              say 'ifcid ' ifcid ' not processed'
                        end
    end   /* select */
 
    /*write report when all IFCID processed */
    if ifcid = 1 & recs > 1 then
       do
          call ifcid_diff
          Call write_report
       end
    else
    do
         if ifcid = 1 & recs = 1 then
         do
              Old_Mstrtcb =       Mstrtcb
              Old_MstrSrb =       MstrSrb
              Old_MstrpSRB=       MstrpSRB
              Old_MstrpSRB_ziip = MstrpSRB_ziip
              Old_dbm1Tcb =       dbm1Tcb
              Old_dbm1srb =       dbm1srb
              Old_dbm1pSRB=       dbm1pSRB
              Old_dbm1pSRB_ziip = dbm1pSRB_ziip
              Old_irlmTcb =       irlmTcb
              Old_irlmsrb =       irlmsrb
              Old_irlmpSRB=       irlmpSRB
              Old_irlmpSRB_ziip = irlmpSRB_ziip
              Old_DistTcb =       DistTcb
              Old_Distsrb =       DistSrb
              Old_DistpSRB=       DistpSRB
              Old_DistpSRB_ziip = DistpSRB_ziip
         end
    end
  END /*    IF SM101RTY = 101  */
END
 
/* close file */
address TSO "EXECIO 0 DISKW OUFL (FINIS"
rcwrite = rc
if rcwrite<> 0 then Do
   say "**********************************************"
   say "   Error writting OUFL file: " rcwrite
   say "   Abnormal end   "
   say "**********************************************"
   Exit 8
end
"EXECIO 0 DISKR INP (FINIS"
"FREE DD(INP)"
"FREE DD(OUFL)"
 
/* report ifcid read */
call report_ifcid
say "Input records =" reci
say "Output records=" reco
say 'SMF period : ' min_date "/" max_date min_time "/" max_time
 
/*-------------------------------------------------*/
/* F20 End of program display counters and figures */
/*-------------------------------------------------*/
call DispVStor
 
EXIT retcode
 
/*---------------------------------------*/
/* End of program body- Routines section */
/*---------------------------------------*/
 
/* MAP SELF-DEFINING SECT IFCID 001 LG = 112 */
DSNDQWS0:
  /*  OFFSET TO THE PRODUCT SECTION */
  QWS00PSO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS00PSL = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS00PSN = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  /*  Following sections are provided by DSNDQWST (Stats header) */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSA CPU TIME */
  QWS00R1O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS00R1L =  C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS00R1N =  C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  SvOfs = Ofs
  /* controle de coherence */
  if  QWS00R1N  > 4 then
      do
           say 'QWS00R1N is not equal to 4, abnormal end ' QWS00R1N
           exit 8
      end
  /* Load offset to DSNDQWSA section - decode db2 stc cpu section */
  Ofs= QWS00R1O - 3  /* -4 +1 */
  i=0
  /* init DIST - DIST stats not always present   */
  DISTTcb      = 0
  DISTSrb      = 0
  DISTpSRB     = 0
  DISTpSRB_Ziip= 0
  do until i= QWS00R1N
         i = i+ 1
         call DSNDQWSA
  end
 
  /*restore offset */
  Ofs = SvOfs
 
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSB STATS COUNTERS*/
  /*  INSTRUMENTATION STATISTICS DATA ABOUT OUTPUT DESTINATION */
  QWS00R2O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSC */
  /*  IFCIDS RECORDED TO STATISTICS */
  QWS00R3O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ3ST */
  /*  Subsytem services fields */
  /*  SIGNON, IDEN, COMMITS, ABORTS ...*/
  QWS00R4O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00R4O - 3
  call DSNDQ3ST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ9ST */
  QWS00R5O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWSD */
  /*  CHECKPOINT INFO, IFI COUNT    ...*/
  QWS00R6O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00R6O - 3
  call DSNDQWSD
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQVLS */
  /*  LATCH COUNTS                  ...*/
  QWS00R7O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00R7O - 3
  call DSNDQVLS
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQVAS */
  /*  ASMC STATS NBRE DE SUSPENSIONS ..*/
  QWS00R8O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQSST */
  /*  STORAGE MANAGER */
  QWS00R9O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00R9O - 3
  call DSNDQSST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQLST */
  /*  DDF STATS BY LOCATION */
  QWS00RAO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQJST */
  /*  LOG MANAGER           */
  QWS00RBO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00RBO - 3
  call DSNDQJST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQDST */
  /*  DBAT STATS            */
  QWS00RCO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  SvOfs = Ofs
  Ofs = QWS00RCO - 3
  call DSNDQDST
  Ofs = SvOfs
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQWOS */
  /*  ZOS STATS             */
  QWS00RDO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if  QWS00RDO > 0 then
  do
    Ofs = QWS00RDO - 3
    call DSNDQWOS
    Ofs = SvOfs
  end
  else do
           QWOSLPRU=0
           QWOSDB2U=0
           QWOSLPIR=0
           QWOSDPIR=0
           QWOSLRST=0
           QWOSLRSF=0
           QWOSDRSU=0
           QWOSLUIC=0
 
  end
  /* LG = 112 = 14 SECTIONS * 8 */
 
  Return
 
/* This IFCID 199 seems not to be available with SMF
QW0199:
   numeric digits 15
       /* offset= offset of self definition section*/
       /* offset= offset + 8 : bypass pointer to Product  Section*/
       /* OfsD = offset de la 1ere data section */
       offset=offset+4+2+2 /*pointer to data section 1*/
       /*take the contents pointed by the offset */
       OfsD= C2D(SUBSTR(InpRec,Ofs,4))
       /* OfsD pointe sur la data section QW0199HE */
       if OfsD > 0 then say 'qw0199 Ofs1 present'
       /*dans tous les cas on va en data section 2 */
       Ofs=Ofs+8
       OfsD= C2D(SUBSTR(InpRec,Ofs,4))
       /* -------------- */
       /* data section 2 */
       /* -------------- */
       /* dbid */
       QW0199DB= C2D(SUBSTR(InpRec,OfsD,2))
       say 'dbid ' QW0199DB
       OfsD=OfsD+2
       /* obid */
       QW0199OB= C2D(SUBSTR(InpRec,OfsD,2))
       say 'obid' QW0199OB
       OfsD=OfsD+2
       /* dsnum*/
       QW0199DN= C2D(SUBSTR(InpRec,OfsD,2))
       say 'dsn' QW0199DN
       OfsD=OfsD+2
       /* bpid */
       QW0199BP= X2D(SUBSTR(InpRec,OfsD,1))
       say 'bpid' QW0199BP
       OfsD=OfsD+1
       /* Flags */
       QW0199DS= x2c(SUBSTR(InpRec,OfsD,1))
       OfsD=OfsD+1
       say 'QW0199DS' QW0199DS
     /*QW0199SV
       QW0199SX  */
       OfsD=OfsD+8
       /* Total I/O Synchronous*/
       QW0199SP = C2D(SUBSTR(InpRec,OfsD,4))
       say 'nb IO sync' QW0199SP
       OfsD=OfsD+4
     /*QW0199AD
       QW0199AX  */
       OfsD=OfsD+8
       /* Total I/O Pages ASynchronous*/
       QW0199AP = C2D(SUBSTR(InpRec,OfsD,4))
       say 'total io pages' QW0199AP
       OfsD=OfsD+4
       /* Total I/O Count*/
       QW0199AC = C2D(SUBSTR(InpRec,OfsD,4))
       say 'total io count' QW0199AC
       OfsD=OfsD+4
       /* Current pages count in this BP*/
       QW0199VP = C2D(SUBSTR(InpRec,OfsD,4))
       say 'current pages ' QW0199VP
       OfsD=OfsD+4
       /* Current changed pages count in this BP*/
       QW0199VD = C2D(SUBSTR(InpRec,OfsD,4))
       say 'current changed pages ' QW0199VD
       OfsD=OfsD+8
       /* Current number of getpages */
       QW0199GP = C2D(SUBSTR(InpRec,OfsD,4))
       say 'current get pages ' QW0199GP
       OfsD=OfsD+4
 
   return
*/
QW0225:
numeric digits 15
    /* offset_save=Ofs       save offset begin data section*/
       /* Ofs   = offset of self definition section*/
       /* Ofs   = Ofs    + 8 : bypass pointer to Product  Section*/
       /* OfsD = offset Data section */
       Ofs =Ofs +8     /*pointer to data section 1 4+2+2 */
       /*take the contents pointed by the offset */
       OfsD= C2D(SUBSTR(InpRec,Ofs,4))
 
       /* -------------- */
       /* data section 1 */
       /* -------------- */
       /* Data section 1 = 2 parts, DBM1 and DIST */
 
       /* offset to dbm1 */
       OfsD=OfsD -4+1
       Ofs=Ofs+4
 
   /*  say 'offs sect1'  OfsD */
       /* len of data section 1 : it will be repeated :*/
       /* One for DBM1 and one for DIST */
       len=      C2D(SUBSTR(InpRec,Ofs,2))
       Ofs=Ofs+2
       rep=      C2D(SUBSTR(InpRec,Ofs,2))
       Ofs=Ofs+2
    /* say 'len' len
       say 'rep' rep
       say 'Inprec:' InpRec */
 
       /* offset to DIST */
       OfsD2=OfsD+len
 
    /* say 'offs sect2'  OfsD2 */
 
       QW0225AN =(SUBSTR(InpRec,OfsD,4))
       if  QW0225AN <> 'DBM1' then
       do
           say 'W0225 - Mapping error'
           exit 8
       end
    /***********************************/
    /* Processing DBM1 storage section */
    /***********************************/
       if  QW0225AN =  'DBM1' & vsm ='Y'  then
       do
           OfsD=OfsD+4
           /* extended region size */
           QW0225RG = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+12
           /* 31 bit low private */
           QW0225EL = C2D(SUBSTR(InpRec,OfsD,4))
           /* say '31bit low priv' b2mb(QW0225EL)*/
           OfsD=OfsD+4
           QW0225EH = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+12
           /* storage reserved fo must complete */
           /* before V10 depends on CTHREAD and MAXDBAT zparm*/
           QW0225CR = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           /* storage reserved for open/close datasets */
           /* depends on DSMAX value */
           QW0225MV = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           QW0225SO = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           QW0225GS = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+8
           QW0225VR = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           QW0225FX = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           QW0225GM = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+4
           /* 31 bit storage available */
           QW0225AV = C2D(SUBSTR(InpRec,OfsD,4))
           OfsD=OfsD+40
           /* Number of real 4K frames in use for
                31 and 64-bit private  */
           QW0225RL_dbm1 = C2D(SUBSTR(InpRec,OfsD,8))
           /*  Real stor. frame used by the Address Space*/
           /*    this includes bufferpools storage qw0225bb */
           OfsD=OfsD+8
           QW0225AX_dbm1 = C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           /* QW0225HVPagesInReal 64 bits private Real */
           QW0225HVPagesInReal =  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           /* QW0225HVAuxSlots    64 bits private Aux */
           QW0225HVAuxSlots =  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+24
      /*   /* QW0225HWM           64 bits private Real*/
           QW0225HVGPagesInReal =  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           /* QW0225HWM           64 bits private Aux */
           QW0225HVGAuxSlots=  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8 */
           /* QW0225PagesInReal 64 bits private Real without BP */
           QW0225PriStg_Real=  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           /* QW0225PagesInAux  64 bits private Aux  without BP */
           QW0225PriStg_Aux=  C2D(SUBSTR(InpRec,OfsD,8))
           OfsD=OfsD+8
           TotalRealUsedBP = QW0225HVPagesInReal - QW0225PriStg_Real
           TotalAuxUsedBP = QW0225HVAuxSlots    - QW0225PriStg_Aux
       end  /* if  QW0225AN =  'DBM1' & vsm = 'Y' then */
 
       /* rep = 2 : there is 2 parts , DBM1 and DDF */
       if rep = 2 then
       do
          /* DIST section */
          QW0225AN =(SUBSTR(InpRec,OfsD2,4))
          if  QW0225AN <> 'DIST'  then
          do
              say 'W0225 - Mapping error DIST not found'
              exit 8
          end
          if  QW0225AN =  'DIST' & vsm='Y' then
          do
              OfsD2=OfsD2+ 104
              QW0225RL_Dist = C2D(SUBSTR(InpRec,OfsD2,8))
              OfsD2=OfsD2+8
              QW0225AX_Dist = C2D(SUBSTR(InpRec,OfsD2,8))
          end  /* if  QW0225AN =  'DIST' & vsm = 'Y' then */
       end
       else /*if rep = 2 then*/
       do
              QW0225RL_Dist = 0
              QW0225AX_Dist = 0
       end
 
       /***************************/
       /*pointer to data section 2*/
       /*  Thread information     */
       /***************************/
 
       OfsD= C2D(SUBSTR(InpRec,Ofs,4))
       OfsD=OfsD -4+1
 
 
       QW0225AT =C2D(SUBSTR(InpRec,OfsD,4))
       OfsD=OfsD+4 /*pointer on data section 2*/
       QW0225DB =C2D(SUBSTR(InpRec,OfsD,4))
 
       if (QW0225AT + qw0225DB) < MinThdSee then
          do
              MinThdSee = QW0225AT + qw0225DB
              MinThdSeeTime= run_fmt_time
              MinThdSeeDate= sm100dte
          end
       if (QW0225AT + qw0225DB) > MaxThdSee then
          do
              MaxThdSee = QW0225AT + qw0225DB
              MaxThdSeeTime= run_fmt_time
              MaxThdSeeDate= sm100dte
          end
    /* say 'threads allied=' QW0225AT
       say 'threads dbat=' QW0225DB */
 
       /********************************************************/
       /*                                                      */
       /*pointer to data section 3 : Shared and Common Storage */
       /*                                                      */
       /********************************************************/
       Ofs = Ofs+8     /* go to next pointer*/
       if vsm = 'Y' then
       do
          /* load address of section 3*/
          OfsD= C2D(SUBSTR(InpRec,Ofs,4))
          OfsD=OfsD -4+1
 
          OfsD=OfsD +136
          QW0225SHRINREAL  =C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 32
          QW0225ShrStg_Real=C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ShrStg_Aux =C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ShrStkStg_Real=C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ShrStkStg_Aux =C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ComStg_Real=C2D(SUBSTR(InpRec,OfsD,8))
          OfsD=OfsD + 8
          QW0225ComStg_Aux =C2D(SUBSTR(InpRec,OfsD,8))
 
      /*  TotalRealUsedByLPAR meaning not clear - value does not  */
      /*     corresponds with others z/OS monitoring tool         */
      /*  TotalRealUsedByLPAR= qw0225rl_dbm1+ qw0225rl_Dist +,    */
      /*       QW0225ComStg_Real + -- in redbook but no where else*/
      /*                           QW0225SHRINREAL                */
          /* QW0225ComStg_Real Real in use 64 bit shared */
          /* QW0225SHRINREAL   Real in use 64 bit common */
 
      /*  if MaxRealLPAR  <  TotalRealUsedByLPAR then */
      /*       do                                     */
      /*           MaxRealLPAR = TotalRealUsedByLPAR  */
      /*           time_MaxRealLPAR = run_fmt_time    */
      /*       end                                    */
 
          OfsD=OfsD + 40
          QW0225_REALAVAIL =C2D(SUBSTR(InpRec,OfsD,4))
          if MinQW0225_REALAVAIL > QW0225_REALAVAIL then
               do
                   MinQW0225_REALAVAIL = QW0225_REALAVAIL
                   time_MinQW0225_REALAVAIL = run_fmt_time
                   date_MinQW0225_REALAVAIL = sm100dte
               end
 
          OfsD=OfsD + 40
          QW0225_LMWrite_Real=C2D(SUBSTR(InpRec,OfsD,4))
          OfsD=OfsD + 4
          QW0225_LMWrite_Aux =C2D(SUBSTR(InpRec,OfsD,4))
          OfsD=OfsD + 4
          QW0225_LMCtrl_Real =C2D(SUBSTR(InpRec,OfsD,4))
          OfsD=OfsD + 4
          QW0225_LMCtrl_Aux  =C2D(SUBSTR(InpRec,OfsD,4))
         /* formula from    Redbook V11 Monitoring */
         /* table 13-1 13-2                        */
         /* Calculation to be updated in   V11 + Log Mgr control */
         /* in Real, Log. write buffers  - Source MEMU Excel sheet */
          TotalRealUsedByDB2 = qw0225rl_dbm1+ qw0225rl_Dist +,
                 QW0225ShrStg_Real + QW0225ShrStkStg_Real +,
                 QW0225ComStg_Real + QW0225_LMWrite_Real +,
                 QW0225_LMCtrl_Real
         /* calculation updated in V11 + Log Mgr control */
         /* in aux - check IBM excel provided with memu */
         TotalAuxlUsedByDB2 = qw0225ax_dbm1+ qw0225ax_Dist +,
               QW0225ComStg_Aux  + QW0225ShrStg_Aux  +  ,
               QW0225ShrStkStg_Aux + QW0225_LMCtrl_Aux +,
               QW0225_LMWrite_Aux
         If MaxDB2AuxUse < TotalAuxlUsedByDB2 then
                          do
                             MaxDB2AuxUse=TotalAuxlUsedByDB2
                             timeMaxDB2AuxUse=run_fmt_time
                             DateMaxDB2AuxUse=sm100dte
                          end
       end
 
       /*----------------------------*/
       /* Pointer to data section 4  */
       /* Statement Cache and        */
       /* shareable statement Detail */
       /*----------------------------*/
 
       Ofs=Ofs+8
       /* Load address of section 4*/
       OfsD= C2D(SUBSTR(InpRec,Ofs,4))
       OfsD=OfsD -4+1
 
       OfsD=OfsD+16
 
       /*£ of dynamic SQL local cache statements in
             64-bit agent local pools used by active
             threads
             (64-bit shared agent local variable pools)  */
       QW0225LC =C2D(SUBSTR(InpRec,OfsD,4))
       OfsD=OfsD+4
       /* HWM of QW225LC */
       QW0225HC =C2D(SUBSTR(InpRec,OfsD,4))
       OfsD=OfsD+4
       /* Storage requested for dynam SQL 64-bit shared agent local*/
       QW0225L2=C2D(SUBSTR(InpRec,OfsD,8))
       OfsD=OfsD+16
       /* Time of HWM */
    /* QW0225HT=SUBSTR(InpRec,OfsD,8)
       call stck QW0225HT
       say timestamp  run_fmt_time */
       OfsD=OfsD+32
       /* Allocated for dynam  64-bit shared system variable pools*/
       QW0225SC8=C2D(SUBSTR(InpRec,OfsD,8))
       OfsD=OfsD+16
       /* Allocated for static 64-bit shared system variable pools*/
       QW0225SX8=C2D(SUBSTR(InpRec,OfsD,8))
       say  QW0225L2'/' QW0225SC8 '/' QW0225SX8
       say QW0225LC '/' QW0225HC
 
 
       /*-------------------------------------------------*/
       /*pointer to data section 5 : Pool storage details */
       /*-------------------------------------------------*/
       Ofs=Ofs+8
       if  vsm = 'Y' then
       do
         OfsD= C2D(SUBSTR(InpRec,Ofs,4))
         OfsD= OfsD+4
       /* QW0225AS Total system agent storage 31 bits*/
         QW0225AS =C2D(SUBSTR(InpRec,OfsD,4))
       /* QW0225BB Total buffer manager storage blocks */
 
       /*-------------------------------*/
       /* Calculate max threads allowed */
       /*-------------------------------*/
 
         /*Ici on a eu tous les infos on peut donc calculer le */
         /* nombre de threads max theoriques*/
         /* Source : IBM formula  */
         /* (Redbook V11 subsystem monitoring Chap. Virtual Stor*/
         /* Min and Max is used in a very defensive way */
         /* The excel proposed with MEMU deoesn't use min max */
         /* I also caculate this value (thdcomp2) */
 
         /*    Thread footprint calculation : */
 
         /* Basic Storage Cushion */
         BC = QW0225CR + QW0225MV + QW0225SO
         /* Non DB2 storage, retains max value for final calculation*/
         ND = QW0225EH-QW0225GM-QW0225GS-QW0225FX-QW0225VR
         if ND > MaxND then MaxND=ND
         /* Max Allowable storage */
         AS = QW0225RG-BC-MaxND
         AS2= QW0225RG-BC-ND
         if AS < MinAS then MinAS=AS
         /* Max Allowable storage for thread use*/
         TS = MinAS-(QW0225AS + QW0225FX + QW0225GM+ QW0225EL)
         TS2= AS2-(QW0225AS + QW0225FX + QW0225GM+ QW0225EL)
         if TS < MinTS then MinTS=TS
         /* Average thread footprint */
         /*  qdstcnat and   QW0225DB  are identical */
         if (QW0225AT + qdstcnat) = 0 then
            /* if threads in system = 0 then 1 */
            TF =  QW0225VR- QW0225AS + QW0225GS
         else
            TF = (QW0225VR-QW0225AS+QW0225GS)/(QW0225AT+qdstcnat)
 
         if TF > MaxTF then MaxTF=TF
         /* Max threads supported    */
         ThdComp=MinTS/MaxTF
         ThdComp2=TS2/TF
         StorBefContract=qw0225AV-(qw0225cr+qw0225SO+qw0225MV)
         /* Storage contraction ?*/
         if qw0225AV <  qw0225cr then
                do
                    say ' Storage critical condition',
                        'à ' run_fmt_time
                end
         else do
              if qw0225AV <  (qw0225cr+ qw0225SO+qw0225MV) then
                do
                    say ' Full system contraction should happen',
                        'à ' run_fmt_time
                end
         end /* else */
 
         if ThdComp < MinThdComp then do
                                     MinThdComp =ThdComp
                                     MinThdCompTime=run_fmt_time
                                     MinThdCompDate=sm100dte
                                   end
         if ThdComp2 < MinThdComp2 then do
                                     MinThdComp2 =ThdComp2
                                     MinThdComp2Time=run_fmt_time
                                     MinThdComp2Date=sm100dte
                                   end
         if ThdComp > MaxThdComp then do
                                     MaxThdComp =ThdComp
                                     MaxThdCompTime =run_fmt_time
                                     MaxThdCompDate =sm100dte
                                   end
         if ThdComp2 > MaxThdComp2 then do
                                     MaxThdComp2 =ThdComp2
                                     MaxThdComp2Time =run_fmt_time
                                     MaxThdComp2Date =sm100dte
                                   end
 
         Real4K_dbm1=(QW0225RL_dbm1 *4096)/ 1048576    /*1MB*/
         Real4K_Dist=(QW0225RL_Dist *4096)/ 1048576    /*1MB*/
 
         If MinReal4K_dbm1 > Real4K_dbm1 then
                          do
                             MinReal4K_dbm1=Real4K_dbm1
                             time_MinReal4K_dbm1=run_fmt_time
                             Date_MinReal4K_dbm1=sm100dte
                          end
         If MaxReal4K_dbm1 < Real4K_dbm1 then
                          do
                             MaxReal4K_dbm1=Real4K_dbm1
                             time_MaxReal4K_dbm1=run_fmt_time
                             Date_MaxReal4K_dbm1=sm100dte
                          end
         If MinReal4K_Dist > Real4K_Dist then
                          do
                             MinReal4K_Dist=Real4K_Dist
                             time_MinReal4K_Dist=run_fmt_time
                             Date_MinReal4K_Dist=sm100dte
                          end
         If MaxReal4K_Dist < Real4K_Dist then
                          do
                             MaxReal4K_Dist=Real4K_Dist
                             time_MaxReal4K_Dist=run_fmt_time
                             Date_MaxReal4K_Dist=sm100dte
                          end
       end /* if vsm ... */
return
/* MAP SELF-DEFINING SECT IFCID 002 LG = 12X8 = 96 */
DSNDQWS1:
  /*  OFFSET TO THE PRODUCT SECTION */
  QWS10PSO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs= Ofs + 8
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQXST */
  /*  RDS stats block  */
  QWS10R1O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if  QWS10R1O > 0 then
  do
    SvOfs = Ofs
    Ofs = QWS10R1O - 4 + 1
    call DSNDQXST
    Ofs = SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTST */
  /*  Binds counts, Plans allocated succ ... */
  QWS10R2O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if QWS10R2O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R2O - 4 + 1
     call DSNDQTST
     Ofs = SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBST */
  /*  Buffer manager stats                          */
  QWS10R3O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS10r3L = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS10r3N = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  /* decode dsndqbst to have  buffer stats */
  if  QWS10R3O > 0 then
  do
      SvOfs= Ofs
      Ofs=QWS10R3O - 4 + 1
      call init_sum_bpstats
      /*add code here if need figures by bufferpool ID */
      m=0
      do until m= QWS10r3N
             m = m+ 1
             call dsndqbst
      end
      call comp_sum_bpstats
      /* Just read => Old bpstats */
      call switch_bpstats
      Ofs=SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQIST */
  /*  Data   manager stats                          */
  QWS10R4O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if QWS10R4O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R4O - 4 + 1
     call DSNDQIST
     Ofs = SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTXA */
  /*  Lock   manager stats                          */
  QWS10R5O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 8
  if QWS10R5O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R5O - 4 + 1
     call DSNDQTXA
     Ofs = SvOfs
  end
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQISE */
  /*  EDM Pool stats                                */
  QWS10R6O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS10R6L = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS10R6N = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  if QWS10R6O > 0 then
  do
     SvOfs = Ofs
     Ofs = QWS10R6O - 4 + 1
     call DSNDQISE
     Ofs = SvOfs
  end
  /*  Stop here if not BP Simul. */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBGL */
  /*  Group BufferPool stats                        */
  QWS10R7O = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 6
  QWS10R7N = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  if  QWS10R7O > 0 then
  do
       SvOfs = Ofs
       Ofs = QWS10R7O - 4 + 1
       call init_gbpstats
       m=0
       do until m= QWS10r7N
           m = m+ 1
           call DSNDQBGL
       end /* do until */
       call comp_diff_gbpstats
       call switch_gbpstats
       Ofs = SvOfs
  end  /* QWS10R7O > 0  */
  /*  Others sections ...                           */
  /*  Jump to BP Simulated data */
  Ofs = Ofs + 32
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQTGS */
  /*  Global Locking                                */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQLES */
  /*  Language Envt Stats                           */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQISJ */
  /*  Start Join    Stats                           */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQ8ST */
  /*  Accelerator Services Stats                    */
  /*  */
  /*  OFFSET TO THE DATA SECTION MAPPED BY DSNDQBSP */
  /*  Simulated Buffer Pool Stats                   */
  if BPSim = 'N' then return /* haha */
  QWS10RCO = C2D(SUBSTR(InpRec,Ofs,4))
  Ofs = Ofs + 4
  QWS10RCL = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  QWS10RCN = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 2
  /* continuation flag from DSNDQBSP data */
  if  QWS10RCO > 0 then
  do
      SvOfs= Ofs
      Ofs=QWS10RCO - 4 + 1
 /*  say SUBSTR(InpRec,OFFSET,104)
  say SUBSTR(InpRec,Ofs+104,104) */
      m=0
      do until m= QWS10RCN
             m = m+ 1
             call DSNDQBSP
      end
      Ofs=SvOfs
  end
  else
  do
      Simbp_entry.0=0
  end
  /*************************************/
  /* End of IFCID002 (for this moment) */
  /*************************************/
  return
 
 
/* MAP STANDARD HEADER PRODUCT SECTION */
DSNDQWHS:
  Ofs = Ofs + 4
  /* QWHSIID DS XL2 IFCID */
  IFCID   = C2D(SUBSTR(InpRec,Ofs,2))
  Ofs = Ofs + 3
  /* release number */
  QWHSRN = C2X(SUBSTR(InpRec,Ofs,1))
  /* TOTAL LENGTH = 76 */
  RETURN
 
/* STATISTICS CPU TIME MAPPING MACRO LG = 52*4*/
DSNDQWSA:
    numeric digits 15
    QWSAPROC =(SUBSTR(InpRec,Ofs,4))
    /* Temporaire possible bug socle 48 */
    /* say 'QWSAPROC=<'QWSAPROC'>'  Ofs */
    if wordpos(QWSAPROC,'MSTR DBM1 IRLM DIST')=0 then
    do
      Ofs = Ofs + 8
      signal DSNDQWSA
    end
    Ofs = Ofs + 4
    /*CONVERT INTO HEX VALUE*/
    QWSAEJST = C2X(SUBSTR(InpRec,Ofs,8))
    /*ELIMINATE 1.5 BYTES */
    QWSAEJST = X2D(SUBSTR(QWSAEJST,1,13))
    QWSAEJST = QWSAEJST/1000000
    Ofs = Ofs + 8
 
    QWSASRBT = C2X(SUBSTR(InpRec,Ofs,8))
    QWSASRBT = X2D(SUBSTR(QWSASRBT,1,13))
    QWSASRBT = QWSASRBT/1000000
    Ofs = Ofs + 16
 
    QWSAPSRB = C2X(SUBSTR(InpRec,Ofs,8))
    QWSAPSRB = X2D(SUBSTR(QWSAPSRB,1,13))
    QWSAPSRB = QWSAPSRB/1000000
    Ofs = Ofs + 8
 
    QWSAPSRB_zIIP = C2X(SUBSTR(InpRec,Ofs,8))
    QWSAPSRB_ziip = X2D(SUBSTR(QWSAPSRB_zIIP,1,13))
    QWSAPSRB_ziip = QWSAPSRB_ziip/1000000
    Ofs = Ofs + 16
 
    Select
         When qwsaproc  = 'MSTR' Then do
                    MstrTcb      =QWSAEJST
                    MstrSrb      =QWSAsrbt
                    MstrpSRB     =QWSApsrb
                    MstrpSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'DBM1' Then do
                    DBM1Tcb      =QWSAEJST
                    DBM1Srb      =QWSAsrbt
                    DBM1pSRB     =QWSApsrb
                    DBM1pSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'DIST' Then do
                    DISTTcb      =QWSAEJST
                    DISTSrb      =QWSAsrbt
                    DISTpSRB     =QWSApsrb
                    DISTpSRB_Ziip=QWSApsrb_ziip
                 end
         When qwsaproc  = 'IRLM' Then do
                    IRLMTcb      =QWSAEJST
                    IRLMSrb      =QWSAsrbt
                    IRLMpSRB     =QWSApsrb
                    IRLMpSRB_Ziip=QWSApsrb_ziip
                 end
         Otherwise      do
                          say 'qwsaproc NOT correct' qwsaproc
                          exit 8
                        end
    end   /* select */
RETURN
 
DSNDQISE:
    /* EDMPOOL STATS */
    numeric digits 15
    /* Fields from IFCID002  : all cumulative */
    /* calculate difference between interval */
 
    /*£ OF REQ FOR CT SECTIONS*/
    Ofs = Ofs + 8
    QISECTG = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF LOAD CT SECT FROM DASD*/
    Ofs = Ofs + 4
    QISECTL = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF REQUESTS FOR DBD*/
    Ofs = Ofs + 20
    QISEDBDG = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF LOAD DBD FROM DASD*/
    Ofs = Ofs + 4
    QISEDBDL = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF REQ FOR PT SECTIONS*/
    Ofs = Ofs + 4
    QISEKTG  = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF LOAD PT SECT FROM DASD*/
    Ofs = Ofs + 4
    QISEKTL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 12
    /*£ OF Inserts  FOR DYN CACHE*/
    QISEDSI  = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF REQUESTS FOR DYN CACHE*/
    Ofs = Ofs +        4
    QISEDSG  = C2D(SUBSTR(InpRec,Ofs,4))
    /*NUMBER OF PAGES IN DBD POOL*/
    Ofs = Ofs + 12
    QISEDPGE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FREE PG IN DBD FREE CHAIN*/
    Ofs = Ofs + 4
    QISEDFRE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FAIL DUE TO DBD POOL FULL*/
    Ofs = Ofs - 8
    QISEDFAL = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF PGS IN DYN STMT POOL*/
    Ofs = Ofs + 20
    QISECPGE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FREE PG IN STMT FREE CHAIN*/
    Ofs = Ofs + 4
    QISECFRE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FAIL DUE TO STMT POOL FULL*/
    Ofs = Ofs - 8
    QISECFAL = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF PAGES IN SKEL EDM POOL*/
    Ofs = Ofs + 24
    QISEKPGE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FREE PG IN SKEL EDM POOL FREE CHAIN */
    Ofs = Ofs + 4
    QISEKFRE = C2D(SUBSTR(InpRec,Ofs,4))
    /*£ OF FAIL DUE TO STMT SKEL POOL FULL*/
    Ofs = Ofs - 8
    QISEKFAL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 52
    /* Total stealable SKEL pages*/
    QISEKLRU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Total stealable DBD  pages*/
    QISEDLRU = C2D(SUBSTR(InpRec,Ofs,4))
 
return
DSNDQWSD:
    /* Nbr of checkpoints cumulative value */
    QWSDCKPT = C2D(SUBSTR(InpRec,Ofs,4))
 return
DSNDQSST:
    Ofs= Ofs+4
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QSST' ) then
                  do
                      say 'DSNDQSST eye catcher not met, error'
                      exit(8)
                  end
    Ofs= Ofs+4*14
    /* full storage contraction*/
    QSSTCONT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    QSSTCRIT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    QSSTABND = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
 return
DSNDQVLS:
    Ofs= Ofs+52   /*4*13*/
    /* Bufferpool LRU  */
    QVLSLC14 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4*5
    /* Log Write       */
    QVLSLC19 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4*5
    /* EDM pool or prefetch*/
    QVLSLC24 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4*7
    /* Storage Manager */
    QVLSLC31 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Storage Manager */
    QVLSLC32 = C2D(SUBSTR(InpRec,Ofs,4))
 return
DSNDQTXA:
    /* Deadlocks */
    QTXADEA  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Susp Locks*/
    QTXASLOC = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* TimeOuts  */
    QTXATIM  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Lock Escal Share  */
    QTXALES  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Lock Escal Excl   */
    QTXALEX  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Max numb of rows and pages lock */
    QTXANPL  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 24
    /* Suspend Latch conflict */
    QTXASLAT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Suspend Latch Other    */
    QTXASOTH = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Lock requests          */
    QTXALOCK = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 20
    /* Claim requests         */
    QTXACLNO = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Drain requests         */
    QTXADRNO = C2D(SUBSTR(InpRec,Ofs,4))
 return
 
DSNDQTST:
    /* Service Controler Stats */
    Ofs= Ofs+4
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QTST' ) then
                  do
                      say 'DSNDQTST eye catcher not met, error'
                      exit(8)
                  end
    Ofs= Ofs+12
    /* Autobind Plan Attempts*/
    QTABINDA =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Autobind Plan Success */
    QTABIND  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs= Ofs+48
    /* Plan Auth attempts    */
    QTAUCHK  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs= Ofs+4
    /* Plan Auth Succ        */
    QTAUSUC  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs= Ofs+4
    /* Datasets opened (snapshot)*/
    QTDSOPN  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Plans Auth Succ with Plan Auth Cache */
    QTAUCCH  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 12
    /* Pack authh Succ with Pack Auth Cache */
    QTPACAUT =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Pack auth can't use  Pack Auth Cache */
    QTPACNOT =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 20
    /* DS closed by drain DSMAX reached */
    QTDSDRN  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* RWRO Convert */
    QTPCCT   =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 44
    /* Autobind Package Attemps */
    QTAUTOBA =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Autobind Package Succ    */
    QTPKABND =  C2D(SUBSTR(InpRec,Ofs,4))
 
 return
DSNDQ3ST:
    /* DB2 Subsystem services fields */
    Ofs= Ofs+4
    /* Signon, meaningful only with CICS or IMS */
    /* Nbr of signon for new user of an EXISTING thread*/
    /* If Signon > CrtThread then there is Thread reuse */
    Q3STSIGN = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Create thread (does not include DBAT) */
    Q3STCTHD = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Terminate     */
    Q3STTERM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Commit1 */
    Q3STPREP = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Commit2 */
    Q3STCOMM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Aborts */
    Q3STABRT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4*9
    /* HWM   IDBACK*/
    Q3STHWIB = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* HWM   IDFORE*/
    Q3STHWIF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* HWM   CTHREAD*/
    Q3STHWCT = C2D(SUBSTR(InpRec,Ofs,4))
 return
 
DSNDQJST:
    Ofs=Ofs+4
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QJST' ) then
                  do
                      say 'DSNDQJST eye catcher not met, error'
                      exit(8)
                  end
    Ofs=Ofs+4
    /* Write Wait   */
    QJSTWRW = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Write No wait = nb log records  (good) */
    QJSTWRNW = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Write Force  (Not Good as does not include force to commit) */
    QJSTWRF= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Wait Output Buffer unavailable   */
    QJSTWTB  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from OutBuf */
    QJSTRBUF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from Active */
    QJSTRACT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read from Archive*/
    QJSTRARH = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Delays from Tape volume contention */
    QJSTTVC  = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* Read BSDS */
    QJSTBSDS = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs=Ofs+4
    /* active log output CI created */
    QJSTBFFL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 16
    /* CI offloaded */
    QJSTCIOF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 36
    /* Page In Log Output Buff*/
    QJSTBPAG = C2D(SUBSTR(InpRec,Ofs,4))
    return
DSNDQDST:
    if QWS00RCO = 0 then
    /* No DDF information */
      do
          if tsayNoDDF = 0 then do
             say 'There is no DDF information in this trace'
             tsayNoDDF=1
             say ' '
          end
          QDSTQDBT =0
          QDSTQCRT =0
          QDSTQCIT =0
          QDSTQMIT =0
          QDSTCNAT =0
          QDSTHWAT =0
          QDSTHWDT =0
          QDSTCIN2 =0
          QDSTMIN2 =0
          QDSTNQMN =0
          QDSTNQMX =0
          QDSTNQAV =0
          QDSTNQR2 =0
          QDSTMQR2 =0
          QDSTNDBA =0
          QDSTPOOL =0
          return
      end
    /* dbat queued  */
    QDSTQDBT = C2D(SUBSTR(InpRec,Ofs,4))
    ofs    = Ofs    + 20 /* 4x 5 */
    /* dbat rejected condbat reached */
    QDSTQCRT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Inactive 1 Private Protocol only  */
    /* Inactive 1 : not exec. but the VTAM conn. is kept */
    /* current inact 1 */
    QDSTQCIT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* max     inact 1 - max is CONDBAT */
    QDSTQMIT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* curr pooled dbat : active and disconnect */
    QDSTCNAT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* max  pooled dbat : active and disconnect */
    QDSTHWAT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* max  dbat        : max active + inact    */
    QDSTHWDT = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Type 2 : Upon Commit the DBAT is marked as Disconn and pooled*/
    /* cur inact 2        */
    QDSTCIN2 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* max inact 2        */
    QDSTMIN2 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    /* Cur type 2 queued  */
    QDSTNQR2 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* HWM type 2 queued  */
    QDSTMQR2 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 12
    /* Requests that required DBAT creation Type 2 */
    QDSTNDBA = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Requests that reuse a disconnected DBAT (Pooled DBAT)*/
    QDSTPOOL = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 16
    /* Min time wait QDSTNQR2 */
    QDSTNQMN = C2X(SUBSTR(InpRec,Ofs,8))
    /*ELIMINATE 1.5 BYTES */
    QDSTNQMN = X2D(SUBSTR(QDSTNQMN,1,13))
    QDSTNQMN = QDSTNQMN/1000000
    Ofs = Ofs + 8
    /* Max time wait QDSTNQR2 */
    QDSTNQMX = C2X(SUBSTR(InpRec,Ofs,8))
    /*ELIMINATE 1.5 BYTES */
    QDSTNQMX = X2D(SUBSTR(QDSTNQMX,1,13))
    QDSTNQMX = QDSTNQMX/1000000
    Ofs = Ofs + 8
    /* Avg time wait QDSTNQR2 */
    QDSTNQAV = C2X(SUBSTR(InpRec,Ofs,8))
    /*ELIMINATE 1.5 BYTES */
    QDSTNQAV = X2D(SUBSTR(QDSTNQAV,1,13))
    QDSTNQAV = QDSTNQAV/1000000
    Ofs = Ofs + 8
    return
 
DSNDQXST:
    /*************************************************/
    /*  RDS STATISTICS BLOCK  DSNDQXST               */
    /*************************************************/
    /* Fields from IFCID002 : cumulative */
    /* calculate difference between interval */
    Ofs=Ofs+4
    /* eye catcher */
    eyec     = SUBSTR(InpRec,Ofs,4)
    if ( eyec     <> 'QXST' ) then
                  do
                      say 'Ofs=' Ofs
                      eyec = SUBSTR(InpRec,1,100)
                      say 'eyec' eyec
                      say 'DSNDQXST eye catcher not met, error'
                      exit(8)
                  end
    Ofs     =  Ofs + 4
    /* Selects     */
    QXSELECT = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /* Inserts     */
    QXINSRT  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /* Update      */
    QXUPDTE  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /* Delete      */
    QXDELET  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 160
    /* Fetch       */
    QXFETCH  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 112
    /*---*/
    /*£RID List failed No storage */
    QXNSMIAP = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Failed Limit exceeded */
    QXMRMIAP = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 248
    /*£ Short Prepare */
    QXSTFND  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Full Prepare */
    QXSTNFND  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Implicit Prepare = FULL prepare */
    QXSTIPRP  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Avoided  Prepare */
    QXSTNPRP  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Stmt discarded - MAXKEEPD */
    QXSTDEXP  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 496
    /* (...) */
    /*£ RID list Overflowed to Workfile No storage in RIDPOOL */
    QXWFRIDS = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ RID list overflowed to wKk Limit Exceeded   */
    QXWFRIDT = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ RID list append for a hybrid join was interrupt No Storage*/
    QXHJINCS = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ RID list append for a hybrid join Limit exceeded*/
    QXHJINCT = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 136
    /*£ IWF not created for sparse index NO storage */
    QXSISTOR = C2D(SUBSTR(InpRec,Ofs,8))
    if  QWHSRN = 'B1' then return /* V11*/
    Ofs     =  Ofs + 32
    /*£ Insert Algorithm 1 */
    QXRWSINSRTDAlg1=C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 8
    /*£ Insert Algorithm 2 */
    QXRWSINSRTDAlg2=C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 24
    /*£ Runtime Adaptive Index used :RID List not used*/
    QXRSDMAD=C2D(SUBSTR(InpRec,Ofs,8))
    Ofs     =  Ofs + 096
    /*£ MIAP not used RID List could not be used */
    QXRFMIAP=C2D(SUBSTR(InpRec,Ofs,8))
return
DSNDQXST0:
    QXSELECT = 0
    QXINSRT  = 0
    QXUPDTE  = 0
    QXDELET  = 0
    QXFETCH  = 0
    QXNSMIAP = 0
    QXSTFND  = 0
    QXSTNFND = 0
    QXSTIPRP = 0
    QXSTNPRP = 0
    QXSTDEXP = 0
    QXWFRIDS = 0
    QXWFRIDT = 0
    QXHJINCS = 0
    QXHJINCT = 0
    QXMRMIAP = 0
    QXSISTOR = 0
    QXRWSINSRTDAlg1=0
    QXRWSINSRTDAlg2=0
    QXRSDMAD = 0
    QXRFMIAP = 0
return
 
GET_FMT_TIME:
  RUN_HH = SM100TME % 360000
  RUN_HH = RIGHT(RUN_HH,2,'0')
  RUN_MIN = SM100TME % 6000 - RUN_HH*60
  RUN_MIN = RIGHT(RUN_MIN,2,'0')
  RUN_SEC = SM100TME % 100 - RUN_HH *3600 - RUN_MIN*60
  RUN_SEC = RIGHT(RUN_SEC,2,'0')
  RUN_FMT_TIME = RUN_HH!!':'!!RUN_MIN!!':'!!RUN_SEC
  RETURN
 
 
write_header:
  say 'CSV file ' oufl     ' will be produced'
  outrec.0= 1
  outrec.1= ,
        "Lpar,ssid,date,time,Hour,MstrTCB,MstrSRB,MstrPSRB,"!!,
         "MstrPSRB_Ziip,Dbm1TCB,DBm1SRB,DBm1PSRB,Dbm1PSRB_Ziip,"!!,
                       "IrlmTCB,IrlmSRB,IrlmPSRB,IrlmPSRB_Ziip,"!!,
                       "DistTCB,DistSRB,DistPSRB,DistPSRB_Ziip,"!!,
         "Chkpt,"!!,
         "CrtThd,Sign,Term,Comm1,Comm2,Abort,MaxIDBACK,"!!,
         "MaxIDFOR,MaxCTHREAD,"!!,
         "AutBndPlA,AutBndPlS,AutBndPkA,AutBndPkS,"!!,
         "DSCur,DSClose,RWROSwitch,DSOpen,"!!,
         "Getpage,GpSeq,Syncio,Pgwritten,SyncWr,AsyncWr,"!!,
         "PageInR,PageInW,"!!,
         "CastPg,CastIO,SprefIO,DynPrfIO,LstPrfIO,BpSio,"!!,
         "NbSQLLocalCach,HWMLocCach,AlloLocCach,"!!,
         "AlloGlobCachDyn,AlloGlobCachStatic,"!!,
       /* Distributed data */,
         "DbatRejConMax,"!!,
         "CurInac1,MaxInac1,CurActDbat,MaxActDbat,MaxAllDbat,"!!,
         "CurInac2Con,MaxInac2Con,CurT2Qd,MaxT2Qd,"!!,
         "MinQTime,MxQTime,AvgQTime,"!!,
         "ThdCrDbat,ThdReuDbat,"!!,
         "CurAldThds,ThdMaxComp,ThdMaxComp2,"!!,
       /* Storage data*/,
         "TotRealUsedDB2,TotAuxUsedDB2,"!!,
         "TotRealUsedBP,TotAuxUsedBP,RealAvail,"!!,
         "ExtRegionSz,31bAvail,StorBefContrac,"!!,
         "FullContractions,StorCrit,NbAbndsStor,"!!,
         "NotOptColProc,"!!,
      /* Workfiles block */ ,
         "32KbUsed4Prf,4KbUsed32Prf,MaxWfKB,"!!,
         "CurWfKB,Cur4KWfKB,Cur32KWfKB,"!!,
         "CurDMInMemWfNb,CurDMInMemWfKB,"!!,
         "CurSRInMemWfNb,CurSRInMemWfKB,"!!,
         "CurRIDsOvfWf,CurNonSRTWfNb,"!!,
         "NbPhysWfCrt,MaxWfUsedThdKB,"!!,
         "AllWfConfKB,DGTTWfConfKB,"!!,
         "OthWfConfKB,"!!,
         "CurDGTTUseKB,MaxDGTTUseKB,"!!,
         "CurOthUseKB,MaxOthUseKB,"!!,
     ,/* EDM Pool block  */
        "MaxRIDBlocks,"!!,
        "ReqCT,LoadCT,ReqDBD,LoadDBD,ReqPT,LoadPT,ReqDynCach,"!!,
         "InsDynC,"!!,
         "DBDPg,DBDFree,DBDStealable,FailDBDFul,STMPoolPg,"!!,
         "StmtFree,"!!,
         "FailStmFul,SKelPg,SKelFree,SkelStealable,FailSkFul,"!!,
    ,/* Locks           */
         "DdLock,TimO,EscS,EscX,MaxPgRLckd,SuspLtch,SuspOth,"!!,
         "SupLok,LockRq,ClaimRq,DrainRq,"!!,
    ,/* RID Pool block  */
         "Sel,Ins,Upd,Del,Fetch,"!!,
         "Prepare,ShortP,ImplP,AvoidP,PrepMAXKD,"!!,
         "RIDFailStor,RIDFailLim,RIDOvflStor,RIDOvflLim,"!!,
         "RIDHybFailStor,RIDHybFailLim,"!!,
         "RIDTrmRDS,RIDTrmDM,"!!,
         "IWFNoStor,IAG1,IAG2,RIDLstNO,"!!,
    ,/* FTB & IAG2 V12 features */
         "IAG2Alloc,IAG2Dis,FTBMinThres,FTBElig,FTBCand,"!!,
         "FTBSize,FTBPrev,FtbCur,IAG2EnabAtt,IAG2AttSuc,"!!,
    ,/* Logging */
         "LogRec-WrNW,WriteW,WriteForce,ActLogCI,CIOff,"!!,
         "LogRBuf,LogRAct,LogRArc,TapeCont,BSDSRead,"!!,
    ,/*ZOS Stats*/
         "CpuLpar,CpuDB2,PageInLpar,PageInDB2,RealLpar,RealFree,"!!,
         "RealDB2,UIC"
     /*  Zones below correspond to the ibm provided excel columns */
     /*  "Z,BE,CV,CX,CZ,CU,CW,CY,CQ,Y,BD"  */
 
  "EXECIO 1 DISKW OUFL (STEM OUTREC. "
 
  /*------------------------------*/
  /* Header for Buffer pool stats */
  /*------------------------------*/
  outrec.1= ,
        "Lpar,Ssid,Date,Time,Hour,BP,Size,"!!,
                  "Gp,GpSeq,SyncIo,PgWr,SyncWr,AsyncWr,"!!,
                  "PgInR,PgInW,"!!,
          "SPfIo,CastPg,CastIo,DynPfIo,LPfIo,BpSio,"!!,
                  "MinSRLU,MaxSLRU,NbSLRUFull,NbRandSLRU"
 
  "EXECIO 1 DISKW OUFL2 (STEM OUTREC. "
 
  /*------------------------------*/
  /* Header for GBP         stats */
  /*------------------------------*/
  outrec.1= ,
      "Lpar,Ssid,Date,Time,Hour,GBP,Gp,"!!,
      "GBPGp,XIRdFnd,XIRdNFnd,XIMissRatio,PgAsyncW,PgSyncW,"!!,
      "PgCast,PgWrAro,AsynXI,SuspAsynXI"
 
  "EXECIO 1 DISKW OUFL5 (STEM OUTREC. "
 
  /*------------------------------*/
  /* Header for Storage     stats */
  /*------------------------------*/
  outrec.1= ,
        "Lpar,ssid,date,time,Hour,TotalRealDB2,"!!,
           "RealDBM1,RealDist,ShrReal,StkReal,ComReal," !!,
           "AuxDBM1,AuxDist,ShrAux,StkAux,ComAux," !!,
           "ShrRealLPAR," !!,
           "TotAuxDB2,TotRealBP,TotAuxBP,RealAvLPAR," !!,
           "ExtRegSz,StoAvDB2"
 
  "EXECIO 1 DISKW OUFL3 (STEM OUTREC. "
 
  if BPSim = 'N' then return
  /*--------------------------------*/
  /* Header for BP Simulation Stats */
  /*--------------------------------*/
  outrec.1= ,
        "Lpar,Ssid,Date,Time,Hour,BP,"!!,
           "SimSize,SeqPage,SyncIOAvoid,SeqSyncIO,AsyncPgRd," !!,
           "GSyncIO,GSeqSyncIO,GAsyncPgRd," !!,
           "PgMov,SyncIOWaitAvoid"
 
  "EXECIO 1 DISKW OUFL4 (STEM OUTREC. "
 
  return
 
 
write_report:
    reco= reco+ 1
    /* bypass first record because off difference calculation */
    if reco = 1 then return
    /* Warning messages or not ? */
    if Alert='Y' then call CheckForAlert
    /*---*/
    outrec.0= 1
    outrec.1= sm100sid  !! ',' !! sm100ssi !! ','  ,
    !! '"'sm100dtex'"'   !! ','   ,
    !! run_fmt_time     !! ','   ,
    !! run_hh           !! ','   ,
    !! dif_MstrTcb      !! ','   ,
    !! dif_MstrSrb      !! ','   ,
    !! dif_MstrpSRB     !! ','   ,
    !! dif_MstrpSRB_ziip !! ','   ,
    !! dif_dbm1Tcb      !! ','   ,
    !! dif_dbm1Srb      !! ','   ,
    !! dif_dbm1pSRB     !! ','   ,
    !! dif_dbm1pSRB_ziip !! ','   ,
    !! dif_IrlmTcb      !! ','   ,
    !! dif_IrlmSrb      !! ','   ,
    !! dif_IrlmpSRB     !! ','   ,
    !! dif_IrlmpSRB_ziip !! ','  ,
    !! dif_DistTcb      !! ','   ,
    !! dif_DistSrb      !! ','   ,
    !! dif_DistpSRB     !! ','    ,
    !! dif_DistpSRB_ziip !! ','   ,
    !! Dif_QWSDCKPT      !! ','   ,     /* Checkpoints */
    !! Dif_Q3STCTHD  !! ','        ,     /* Create Thd */
    !! Dif_Q3STSIGN  !! ','        ,     /* Signon  */
    !! Dif_Q3STTERM  !! ','        ,     /* Terminate*/
    !! Dif_Q3STPREP  !! ','        ,     /* Commit phase 1 */
    !! Dif_Q3STCOMM  !! ','        ,     /* Commit Ph 2*/
    !! Dif_Q3STABRT  !! ','        ,     /* Aborts */
    !!     Q3STHWIB  !! ','        ,     /* Max IDBACK */
    !!     Q3STHWIF  !! ','        ,     /* Max IDFORE */
    !!     Q3STHWCT  !! ','        ,     /* Max CTHREAD */
    !! Dif_QTABINDA  !! ','        ,     /* Autobind Plan*/
    !! Dif_QTABIND   !! ','        ,
    !! Dif_QTAUTOBA  !! ','        ,     /* Auto bind Pack */
    !! Dif_QTPKABND  !! ','        ,
    !! QTDSOPN       !! ','        ,     /* DS Current  */
    !! Dif_QTDSDRN   !! ','        ,     /* Close Drain */
    !! Dif_QTPCCT    !! ','        ,     /* RWRO switch */
    !! Sum_QBSTDSO   !! ','        ,     /* OPEN DS     */
    !! Sum_QBSTGET   !! ','        ,
    !! Sum_QBSTSGT   !! ','        ,     /* Sequential Getp */
    !! Sum_QBSTRIO   !! ','        ,
    !! Sum_QBSTPWS   !! ','        ,
    !! Sum_QBSTIMW   !! ','        ,
    !! Sum_QBSTWIO   !! ','        ,
    !! Sum_QBSTRPI   !! ','        ,
    !! Sum_QBSTWPI   !! ','        ,
    !! Sum_QBSTPCO   !! ','        ,
    !! Sum_QBSTCIO   !! ','        ,
    !! Sum_QBSTPIO   !! ','        ,
    !! Sum_QBSTDIO   !! ','        ,
    !! Sum_QBSTLIO   !! ','        ,
    !! Sum_QBSTSIO   !! ','        ,
    !! QW0225LC      !! ','        ,
    !! QW0225HC      !! ','        ,
    !! QW0225L2      !! ','        ,
    !! QW0225SC8     !! ','        ,
    !! QW0225SX8     !! ','        ,
    !! Dif_QDSTQCRT  !! ','  , /* Conn. rejected CONDBAT reached */
    !! QDSTQCIT      !! ','        ,     /* curr. inact type 1*/
    !! QDSTQMIT      !! ','        ,     /* max . inact type 1*/
    !! QDSTCNAT      !! ','        ,     /* curr. active dbat */
    !! QDSTHWAT      !! ','        ,     /* max active dbat */
    !! QDSTHWDT      !! ','        ,     /* max act & inact dbat */
    !! QDSTCIN2      !! ','        ,     /* current inactive Conn*/
    !! QDSTMIN2      !! ','        ,     /* hwm inactive  conn */
    !! QDSTNQR2      !! ','        ,     /* Type 2 queued      */
    !! QDSTMQR2      !! ','        ,     /* HWM type 2 queued  */
    !! QDSTNQMN      !! ','        ,
    !! QDSTNQMX      !! ','        ,
    !! QDSTNQAV      !! ','        ,
    !! Dif_QDSTNDBA      !! ','        ,
    !! Dif_QDSTPOOL      !! ','        ,
    !! QW0225AT      !! ','        ,     /* curr. allied threads*/
    !! strip(format(ThdComp ,6,0))   !! ',' ,
    !! strip(format(ThdComp2,6,0))   !! ',' ,
    !! f2mb(TotalRealUsedByDB2)     !! ',' ,
    !! f2mb(TotalAuxlUsedByDB2)     !! ',' ,
    !! f2mb(TotalRealUsedBP)        !! ',' ,
    !! f2mb(TotalAuxUsedBP)         !! ',' ,
    !! f2mb(QW0225_REALAVAIL)       !! ',' ,
    !! b2mb(QW0225RG)               !! ',' ,
    !! b2mb(QW0225AV)               !! ',' ,
    !! b2mb(StorBefContract)        !! ',' ,
    !!             QSSTCONT         !! ',' ,
    !!             QSSTCRIT         !! ',' ,
    !!             QSSTABND         !! ',' ,
    !!         Dif_QISTCOLS         !! ',' ,
  /* Workfiles block */ ,
    !!         Dif_QISTWFP1         !! ',' ,
    !!         Dif_QISTWFP2         !! ',' ,
    !!             QISTWMXU         !! ',' ,
    /* Current all workfile usage in KB : DGTT and Sort */,
    !! QISTWCTO     !! ',' ,
    /* Current 4K wrkfile storage usage in KB*/ ,
    !! QISTW4K      !! ',' ,
    /* Current 32K wrkfile storage usage in KB*/,
    !! QISTW32K     !! ',' ,
    /* Nb DM in memory   wrkfiles active currently */ ,
    !! QISTIMAC     !! ',' ,
    /* Space DM in memory active currently in KB*/ ,
    !! QISTIMSC     !! ',' ,
    /* Nb SRT in memory   wrkfiles active currently */ ,
    !! QISTSIAC     !! ',' ,
    /* Space SRT in memory active currently in KB */ ,
    !! QISTSISC     !! ',' ,
    /* Current RID blocks overflowed (stored) in wrkfiles*/ ,
    !! QISTWFRCUR   !! ',' ,
    /* Current NON Sort related workfiles active */,
    !! QISTI2AC     !! ',' ,
    /* Physical  workfiles created */,
    !! Dif_QISTI2OF !! ',' ,
    /* HWM wkfile storage used by an agent */ ,
    !! QISTAMXU     !! ','  ,
    /* Current storage configured for wkfiles*/ ,
    !! QISTWSTG     !! ','  ,
    /* Current DGTT  configured for wkfile KB*/ ,
    !! QISTDGTTSTG  !! ',' ,
    /* Current others  configured for wkfile KB*/,
    !! QISTWFSTG    !! ',' ,
    /* Current DGTT  used  KB*/,
    !! QISTDGTTCTO  !! ',' ,
    /* HWM     DGTT  used  KB*/ ,
    !! QISTDGTTMXU  !! ',' ,
    /* Current others used  KB*/ ,
    !! QISTWFCTO    !! ',' ,
    /* HWM    others used KB*/ ,
    !! QISTWFMXU    !! ',' ,
  /* EDMPOOL block */ ,
    !! QISTRHIG                     !! ',' ,    /* Max RID blocks*/
    !! Dif_QISECTG                  !! ',' ,    /* requests CT*/
    !! Dif_QISECTL                  !! ',' ,    /* Load CT    */
    !! Dif_QISEDBDG                 !! ',' ,    /* Req DBD    */
    !! Dif_QISEDBDL                 !! ',' ,    /* Load DBD   */
    !! Dif_QISEKTG                  !! ',' ,    /* Req PT     */
    !! Dif_QISEKTL                  !! ',' ,    /* Load PT    */
    !! Dif_QISEDSG                  !! ',' ,    /* Req Dyn Cache */
    !! Dif_QISEDSI                  !! ',' ,    /* Ins Dyn Cache */
    !!     QISEDPGE                 !! ',' ,    /* DBDPool used pages */
    !!     QISEDFRE                 !! ',' ,    /* DBDPOOL free pages */
    !!     QISEDLRU                 !! ',' ,    /* DBDPOOL stealable  */
    !!     QISEDFAL                 !! ',' ,    /* Failed DBDPool Full*/
    !!     QISECPGE                 !! ',' ,    /* Pages STMTPool */
    !!     QISECFRE                 !! ',' , /* Pages STMTPool free */
    !!     QISECFAL                 !! ',' , /* Failed STMTool Full*/
    !!     QISEKPGE                 !! ',' , /* Pages in SkelPool */
    !!     QISEKFRE                 !! ',' , /* Free pages SKELPool*/
    !!     QISEKLRU                 !! ',' ,  /* Skel pages stealable*/
    !!     QISEKFAL                 !! ',' ,  /* Failed SkelPoolFull*/
  /* Locks                              */,
    !!  Dif_QTXADEA                 !! ',' ,
    !!  Dif_QTXATIM                 !! ',' ,
    !!  Dif_QTXALES                 !! ',' ,
    !!  Dif_QTXALEX                 !! ',' ,
    !!  Dif_QTXANPL                 !! ',' ,
    !!  Dif_QTXASLAT                !! ',' ,
    !!  Dif_QTXASOTH                !! ',' ,
    !!  Dif_QTXASLOC                !! ',' ,
    !!  Dif_QTXALOCK                !! ',' ,
    !!  Dif_QTXACLNO                !! ',' ,
    !!  Dif_QTXADRNO                !! ',' ,
  /* RID LIST BLOCK RID List processing */,
    !!  Dif_QXSELECT                !! ',' ,
    !!  Dif_QXINSRT                 !! ',' ,
    !!  Dif_QXUPDTE                 !! ',' ,
    !!  Dif_QXDELET                 !! ',' ,
    !!  Dif_QXFETCH                 !! ',' ,
    !!  Dif_QXSTNFND                !! ',' , /* Full  Prepare */
    !!  Dif_QXSTFND                 !! ',' , /* Short Prepare */
    !!  Dif_QXSTIPRP                !! ',' , /* Impl  Prepare */
    !!  Dif_QXSTNPRP                !! ',' , /* Avoided Prepare */
    !!  Dif_QXSTDEXP                !! ',' , /* Prepare MAXKEEPD reach*/
    !!  Dif_QXNSMIAP                !! ',' ,  /*Failed Limit no Stor */
    !!  Dif_QXMRMIAP                !! ',' ,  /*Failed Limit exc*/
    !!  Dif_QXWFRIDS                !! ',' ,  /*Overflow no Stor. */
    !!  Dif_QXWFRIDT                !! ',' ,  /*Overflow Limit    */
    !!  Dif_QXHJINCS                !! ',' ,  /*Failed Hybrid Stor*/
    !!  Dif_QXHJINCT                !! ',' ,  /*Failed Hybrid Limit*/
    !!  Dif_QISTRLLM                !! ',' ,  /*RID interrupted */
                 /* RDS Limit = MAX(25% table size, rid storage) */,
                 /* but can be others reason */,
    !!  Dif_QISTRPLM                !! ',' ,  /*RID interrupt > 16M */
    !!  Dif_QXSISTOR                !! ',' ,  /*IWF no storage    */
    !!  Dif_QXRWSINSRTDAlg1         !! ',' ,  /*Insert Algo 1     */
    !!  Dif_QXRWSINSRTDAlg2         !! ',' ,  /*Insert Algo 2     */
    !!  Dif_QXRFMIAP                !! ',' ,  /*RID not used      */
  /* V12 features: FTB & IAG2 */ ,
    !!  QISTINPA  !! ',' ,              /* IAG2 Alloc */
    !!  QISTINPD  !! ',' ,              /* IAG2 Dealloc */
    !!  QISTTRAVMIN  !! ',' ,           /* FTB Min traverse count*/
    !!  QISTFTBCANT !! ',' ,            /* FTB Eligible */
    !!  QISTFTBCAN !! ',' ,             /* FTB Candidate */
    !!  QISTFTBSIZE !! ',' ,            /* FTB Size */
    !!  QISTFTBNUMP !! ',' ,            /* Prev Interval FTB usage */
    !!  QISTFTBNUMC !! ',' ,            /* Current Ix using FTB */
    !!  QISTINPR !! ',' ,               /* IAG2 reenable attempts*/
    !!  QISTINPE !! ',' ,               /* IAG2 attempts succ.*/
  /*Logging */ ,
    !!     Dif_QJSTWRNW             !! ',' ,  /*Log rec -WriteNWoW*/
    !!     Dif_QJSTWRW             !! ',' ,  /*Write Waits */
    !!     Dif_QJSTWRF              !! ',' ,  /*Write Force*/
    !!     Dif_QJSTBFFL             !! ',' ,  /*Log CI created*/
    !!     Dif_QJSTCIOF             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTRBUF             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTRACT             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTRARH             !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTTVC              !! ',' , /* Log CI Offloaded */
    !!     Dif_QJSTBSDS             !! ',' , /* Log CI Offloaded */
    !!     QWOSLPRU                 !! ',' ,  /* CPU util. LPAR */
    !!     QWOSDB2U                 !! ',' ,  /* CPU util. DB2 */
    !!     QWOSLPIR                 !! ',' ,  /* Page in rate LPAR */
    !!     QWOSDPIR                 !! ',' ,  /* Page in DB2 */
    !!     QWOSLRST                 !! ',' ,  /* Storage LPAR */
    !!     QWOSLRSF                 !! ',' ,  /* Storage Free */
    !!     QWOSDRSU                 !! ',' , /* Stor used by this Db2*/
    !!     QWOSLUIC                 !! ','    /* UIC */
  /*!! f2mb(qw0225ax_dbm1)          !! ',' ,
    !! f2mb(qw0225ax_Dist)          !! ',' ,
    !! f2mb(QW0225ShrStg_Aux)       !! ',' ,
    !! f2mb(QW0225ShrStkStg_Aux)    !! ',' ,
    !! f2mb(QW0225ComStg_Aux)       !! ',' ,
    !! f2mb(QW0225ShrStg_Real)      !! ',' ,
    !! f2mb(QW0225ShrStkStg_Real)   !! ',' ,
    !! f2mb(QW0225ComStg_Real)      !! ',' ,
    !! f2mb(QW0225SHRINREAL)        !! ',' ,
    !! f2mb(qw0225rl_dbm1)          !! ',' ,
    !! f2mb(qw0225rl_Dist)          !! ','    */
    /* active thread =  QDSTCNAT +  QW0225AT */
  "EXECIO 1 DISKW OUFL (STEM OUTREC. "
 
 
  /*************************************/
  /* Second record for Detail Bufstats */
  /* Loop  for each bufferpool ID      */
  /*************************************/
  do i = 1 to NbBPEnt.0
        j = NbBPEnt.i
        /* decode BPID to BP name */
        Select
             When j >='0'   & j <= '50'    Then BPNm = 'BP'j
             When j >='100' & j <= '109'   Then do
                                                  k    = j-100
                                                  BPNm = 'BP8K'k
                                                end
             When j >='120' & j <= '129'   Then do
                                                  k    = j-120
                                                  BPNm = 'BP16K'k
                                                end
             When j >='80'  & j <= '89'    Then do
                                                  k    = j-80
                                                  BPNm = 'BP32K'k
                                                end
             Otherwise do
                         say 'Buffer pool ID ??? 'j
                         BPNm = '?'j
                       end
        end
    /* SLRU full   */
/*      if Det_HST.j >0 then
             do
               say 'Warning : SLRU chain = VPSEQT for' BPNm,
                   'à' run_fmt_time
               retcode=4
             end */
        if BPNm = 'BP32K0' then BPNm = 'BP32K'
        outrec.1= sm100sid !! ',' !! sm100ssi !! ','  ,
        !! '"'sm100dtex'"'  !! ','   ,
        !! run_fmt_time    !! ','   ,
        !! run_hh          !! ','   ,
        !! BPNm            !! ','   ,
        !! BufVPL.j      !! ','  ,
        !! Det_GET.j     !! ','  ,
        !! Det_SGT.j     !! ','  ,
        !! Det_RIO.j     !! ','  ,
        !! Det_PWS.j     !! ','  ,
        !! Det_IMW.j     !! ','  ,
        !! Det_WIO.j     !! ','  ,
        !! Det_RPI.j     !! ','  ,
        !! Det_WPI.j     !! ','  ,
        !! Det_PIO.j     !! ','  ,
        !! Det_PCO.j     !! ','  ,
        !! Det_CIO.j     !! ','  ,
        !! Det_DIO.j     !! ','  ,
        !! Det_LIO.j     !! ','  ,
        !! Det_SIO.j     !! ','  ,
        !! BufMIN.j      !! ','  ,
        !! BufMAX.j      !! ','  ,
        !! Det_HST.j     !! ','  ,
        !! Det_RHS.j
        "EXECIO 1 DISKW OUFL2 (STEM OUTREC. "
  end
  /***************************************************/
  /* Another record for Detail Group Bufferpool stats*/
  /* Loop  for each bufferpool ID                    */
  /***************************************************/
  do i = 1 to NbGBPEnt.0
        j = NbGBPEnt.i
        /* decode BPID to BP name */
        Select
             When j >='0'   & j <= '50'    then BPNm = 'GBP'j
             When j >='100' & j <= '109'   then do
                                              k    = j-100
                                              BPNm = 'GBP8K'k
                                           end
             When j >='120' & j <= '129'   then do
                                              k    = j-120
                                              BPNm = 'GBP16K'k
                                           end
             When j >='80'  & j <= '89'    then do
                                              k    = j-80
                                              BPNm = 'GBP32K'k
                                           end
             Otherwise do
                         BPNm = '?'j
                       end
        end
        if BPNm = 'GBP32K0' then BPNm = 'GBP32K'
 
        outrec.1= sm100sid !! ',' !! sm100ssi !! ','  ,
        !! '"'sm100dtex'"'  !! ','   ,
        !! run_fmt_time    !! ','   ,
        !! run_hh          !! ','   ,
        !! BPNm            !! ','   ,
        !! Det_GET.j       !! ','   ,      /* getpage */
        !! Dif_GBPGetPage.j     !! ','  ,
        !! Dif_GBPXIReadRet.j     !! ','  ,
        !! Dif_GBPXIReadNoRet.j   !! ','  ,
        !! format(GBPXIMissRatio.j,4,2) !! ','  ,
        !! Dif_QBGLAW.j   !! ','  ,
        !! Dif_QBGLSW.j   !! ','  ,
        !! Dif_QBGLRC.j   !! ','  ,
        !! Dif_QBGLWA.j   !! ','  ,
        !! Dif_QBGLWX.j   !! ','  ,
        !! Dif_QBGLAS.j
        "EXECIO 1 DISKW OUFL5 (STEM OUTREC. "
  end
 
  /**************************************/
  /* Another record for Storage stats   */
  /*************************************/
        /* Buid output record */
        outrec.1= sm100sid !! ',' !! sm100ssi !! ','  ,
        !! '"'sm100dtex'"'  !! ','   ,
        !! run_fmt_time    !! ','   ,
        !! run_hh          !! ','   ,
        !! f2mb(TotalRealUsedByDB2) !! ','   ,
        !! f2mb(qw0225rl_dbm1)   !! ','   ,
        !! f2mb(qw0225rl_Dist)   !! ','   ,
        !! f2mb(qw0225ShrStg_Real)    !! ','   ,
        !! f2mb(qw0225ShrStkStg_Real) !! ','   ,
        !! f2mb(QW0225ComStg_Real) !! ','   ,
    !! f2mb(qw0225ax_dbm1)          !! ',' ,
    !! f2mb(qw0225ax_Dist)          !! ',' ,
    !! f2mb(QW0225ShrStg_Aux)       !! ',' , /* ShAux slots used SSID */
    !! f2mb(QW0225ShrStkStg_Aux)    !! ',' , /* ShStak slots SSID */
    !! f2mb(QW0225ComStg_Aux)       !! ',' , /* Common Aux SSID*/
    !! f2mb(QW0225SHRINREAL)   !! ',',       /* Share backed by Real*/
    !! f2mb(TotalAuxlUsedByDB2)     !! ',' ,        /*for LPAR*/
    !! f2mb(TotalRealUsedBP)        !! ',' ,
    !! f2mb(TotalAuxUsedBP)         !! ',' ,
    !! f2mb(QW0225_REALAVAIL)       !! ',' ,  /* Real Available LPAR */
    !! b2mb(QW0225RG)               !! ',' ,
    !! b2mb(QW0225AV) /* How much DB2 thinks it is avail*/
 
        "EXECIO 1 DISKW OUFL3 (STEM OUTREC. "
  if BPSim  = 'Y' then
  do
  /*************************************/
  /* Simulation  Bufstats              */
  /* Loop  for each bufferpool ID      */
  /*************************************/
      do i = 1 to Simbp_entry.0
            j = Simbp_entry.i
            /* decode BPID to BP name */
            Select
                 When j >='0'   & j <= '50'    Then BPNm = 'BP'j
                 When j >='100' & j <= '109'   Then do
                                                      k    = j-100
                                                      BPNm = 'BP8K'k
                                                    end
                 When j >='120' & j <= '129'   Then do
                                                      k    = j-120
                                                      BPNm = 'BP16K'k
                                                    end
                 When j >='80'  & j <= '89'    Then do
                                                      k    = j-80
                                                      BPNm = 'BP32K'k
                                                    end
                 Otherwise do
                             BPNm = '?'j
                           end
            end
            if BPNm = 'BP32K0' then BPNm = 'BP32K'
            /* Buid output record */
            outrec.1= sm100sid !! ',' !! sm100ssi !! ','  ,
            !! '"'sm100dtex'"'  !! ','   ,
            !! run_fmt_time    !! ','   ,
            !! run_hh          !! ','   ,
            !! BPNm            !! ','   ,
            !! DifSimPage.i         !! ','   ,
            !! DifSimSeqPage.i      !! ','   ,
            !! DifSimSyncIO.i       !! ','   ,
            !! DifSimSeqSyncIO.i    !! ','   ,
            !! DifSimAsyncPage.i    !! ','   ,
            !! DifSimGBPSyncIO.i    !! ','   ,
            !! DifSimGBPSeqSyncIO.i !! ','   ,
            !! DifSimGBPAsyncPage.i !! ','   ,
            !! DifSimPageMov.i      !! ','   ,
            !! DifSimWaitSyncIO.i
            "EXECIO 1 DISKW OUFL4 (STEM OUTREC. "
      end
  end  /* If BPSim='Y' */
 
return
 
 
/* SMF HEADER */
DSNDQWST:
   Ofs = Ofs + 1
   /* Smf record type   = X'64' =  100 */
   SM100RTY = C2D(SUBSTR(InpRec,Ofs,1))
   /* stop processing if not 100 */
   if sm100rty <> 100 then return
   Ofs = Ofs + 9
   /* Optimisation : Get Subsystem ID first */
   /* System Id = SMF ID */
   sm100sid = SUBSTR(InpRec,Ofs,4)
   Ofs = Ofs + 4
   /* Subsystem Id  */
   sm100ssi = SUBSTR(InpRec,Ofs,4)
   if sm100ssi <> ssid then return
   /* Go back to get time */
   Ofs = Ofs -12
   /* SM100TME DS XL4 TIME SMF MOVED RECORD */
   SM100TME = C2D(SUBSTR(InpRec,Ofs,4))
   Ofs = Ofs + 4
   if  sm100tme <> old_sm100tme then
   do
       CALL GET_FMT_TIME
       old_sm100tme=sm100tme
   end
   /* compute date only if there is a change */
   sm100dte_0 = C2X(SUBSTR(InpRec,Ofs,4))
   Ofs = Ofs + 18
   if sm100dte_0 = sm100dte_0Old then
                                      return
   sm100dte_0Old = sm100dte_0
   parse value sm100dte_0 with 1 . 2 c 3 yy 5 ddd 8 .
  /* if (c = 0) then
       yyyy = '19'!!yy
     else
       yyyy = '20'!!yy */
   sm100dte    = '20'yy!!'.'!!ddd
   /* get day of week : easier to select days */
   test_date = '20'yy ddd
   sm100dtex=DAT_MVS2SD(test_date)
   /* save date of smf records processed */
   if reco = 0 then save_date=sm100dte
   else do
     if save_date <> sm100dte & displ = 0 then do
        displ=1
        say 'There is 2 different dates in this SMF extract'
        say '             '  save_date sm100dte
        say ' '
     end
   end
   /* TOTAL LENGTH = 28 */
   Return
DSNDQWOS:
    /* Nb CPU */
    QWOSLNCP =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* CPU use. LPAR      */
    QWOSLPRU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* CPU use. DB2       */
    QWOSDB2U = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 12
    /* Page in rate LPAR       */
    QWOSLPIR = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Page in rate DB2        */
    QWOSDPIR = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Real Stor. LPAR         */
    QWOSLRST = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Real Stor. Free LPAR    */
    QWOSLRSF = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Real Stor. used by this DB2 */
    QWOSDRSU = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 16
    /* Real Stor. used by this DB2 */
    QWOSLUIC = C2D(SUBSTR(InpRec,Ofs,4))
    return
 
dsndqist:
    numeric digits 15
    Ofs     =  Ofs +4
    /* Fields of these macro seems to be all cumulative */
    /* calculate difference between interval */
    /* check QIEYE */
      if  SUBSTR(InpRec,Ofs,4) <> 'QIST' then
        do
              say 'Mapping error QIST eye catcher not found'
              exit(8)
        end
 
    Ofs = Ofs + 4
    /* RID Interrupted  RDS Limit */
    /*  when Db2 facilitates incremental processing of the RIDs by */
    /*  retrieving one RID block of RIDs in advance (eg. used by */
    /*  adaptive index processing).  When more than one RID block is*/
    /*  required this is also considered as RDS limit exceeded */
    QISTRLLM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* RID Interrupted DM  Limit */
    /* (Physical limit of 16.6M Rids) */
    QISTRPLM = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Highest RID blocks */
    QISTRHIG = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 16
    /* not optimal column proc */
    QISTCOLS = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    Ofs = Ofs + 36
    /* 32KB Wrkfile used instead of 4KB */
    QISTWFP1 = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* 4 KB Wrkfile used instead of 32 KB */
    QISTWFP2 = C2D(SUBSTR(InpRec,Ofs,4))
  if QWHSRN= 'A1' then /* zones not available V10 */
  do
     QISTWMXU=0
     QISTWCTO=0
     QISTW4K=0
     QISTW32K=0
     QISTIMAC=0
     QISTIMSC=0
     QISTSIAC=0
     QISTSISC=0
     QISTWFRCUR=0
     QISTI2AC=0
     QISTI2OF=0
     QISTAMXU=0
     QISTWSTG=0
     QISTDGTTSTG=0
     QISTWFSTG=0
     QISTDGTTCTO=0
     QISTDGTTMXU=0
     QISTWFCTO=0
     QISTWFMXU=0
     QISTINPA =0
     QISTINPD =0
     QISTTRAVMIN =0
     QISTFTBCANT =0
     QISTFTBCAN =0
     QISTFTBSIZE =0
     QISTFTBNUMP =0
     QISTFTBNUMC =0
     QISTINPR =0
     QISTINPE =0
    return
  end
    Ofs = Ofs + 28
    /* hwm storage used by workfiles in KB */
    QISTWMXU = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current all workfile usage in KB : DGTT and Sort */
    QISTWCTO = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current 4K wrkfile storage usage in KB*/
    QISTW4K  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current 32K wrkfile storage usage in KB*/
    QISTW32K = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Nb DM in memory   wrkfiles active currently */
    QISTIMAC = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Space DM in memory active currently in KB*/
    QISTIMSC = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 24
    /* Nb SRT in memory   wrkfiles active currently */
    QISTSIAC = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Space SRT in memory active currently in bytes */
    QISTSISC = C2D(SUBSTR(InpRec,Ofs,8))
    QISTSISC = trunc(QISTSISC/1024) /* in KB */
    Ofs = Ofs + 32
    /* Current RID blocks overflowed (stored) in wrkfiles*/
    QISTWFRCUR=  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current NON Sort related workfiles active */
    QISTI2AC =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* Physical  workfiles created */
    QISTI2OF =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 24
    /* HWM wkfile storage used by an agent */
    QISTAMXU =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current storage configured for wkfiles*/
    QISTWSTG =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current DGTT  configured for wkfile KB*/
    QISTDGTTSTG = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current DGTT  used  KB*/
    QISTDGTTCTO = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* HWM     DGTT  used  KB*/
    QISTDGTTMXU = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current others  configured for wkfile KB*/
    QISTWFSTG = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Current others used  KB*/
    QISTWFCTO = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* HWM    others used KB*/
    QISTWFMXU = C2D(SUBSTR(InpRec,Ofs,8))
    if  QWHSRN = 'B1' then        /* V11*/
       do
          QISTINPA =0
          QISTINPD =0
          QISTTRAVMIN =0
          QISTFTBCANT =0
          QISTFTBCAN =0
          QISTFTBSIZE =0
          QISTFTBNUMP =0
          QISTFTBNUMC =0
          QISTINPR =0
          QISTINPE =0
          return
       end
    Ofs = Ofs + 8
    /* Fast Insert allocated */
    QISTINPA  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Fast Insert disabled  */
    QISTINPD  = C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* FTB Traverse count threshold (hidden zparm) */
    QISTTRAVMIN= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Indexes Eligible to FTB (Unique,key size <64 ...*/
    QISTFTBCANT= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Indexes Candidate to FTB (Eligible AND meet FTB  Threshold*/
    QISTFTBCAN = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* FTB Size                         */
    QISTFTBSIZE= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* FTB Indexes prev interval*/
    QISTFTBNUMP= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* FTB Indexes Used         */
    QISTFTBNUMC= C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Fast Insert re-enabled attempt */
    QISTINPR   = C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    /* Fast Insert attempt success */
    QISTINPE   = C2D(SUBSTR(InpRec,Ofs,4))
    return
 
/***************************/
/* Group buffer pool stats */
/***************************/
dsndqbgl:
    numeric digits 15
    /* Group BPID */
    QBGLGN  =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    QBGLFLG  =  SUBSTR(InpRec,Ofs,1)
    Ofs = Ofs + 1 + 3
    /* GBP Dependent Getpage */
    QBGLGG  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Syn.Read(XI)-Data returned (A in the formula ) */
    QBGLXD  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Syn.Read(XI)-No Data Return (B in the formula) */
    QBGLXR  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 24
    /* Sync Write  (from local BP to GBP) called User Write */
    QBGLSW  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 56
    /* ASync Write  (from local BP to GBP) called Syst Write */
    QBGLAW  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Pages castout (written from GBP to DASD) */
    QBGLRC  =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 32
    /* Write requests failed no storage */
    /* QBGLWF  =  C2D(SUBSTR(InpRec,OFFSET,8)) */
    Ofs = Ofs + 104
    /* Write requests failed no storage secondary GBP */
    /* QBGL2F  =  C2D(SUBSTR(InpRec,OFFSET,8)) */
    /* Write Around */
    Ofs = Ofs + 136
    /* Page in write around  */
    QBGLWA  =  C2D(SUBSTR(InpRec,Ofs,8))
    if  QWHSRN > 'B1' then  /*v12*/
    do
       Ofs = Ofs + 8
       /* Asynchronous XI   */
       QBGLWX  =  C2D(SUBSTR(InpRec,Ofs,8))
       Ofs = Ofs + 16
       /* Suspensions due to Asyn XI */
       QBGLAS  =  C2D(SUBSTR(InpRec,Ofs,8))
       Ofs = Ofs + 8
    end
    else
    do
       QBGLWX =0;QBGLAS =0
       Ofs = Ofs + 32
    end
    /* End of macro QBGL */
    /*------------------------------------------------------------- */
    /* For GBP changed data pages estimation :                      */
    /* Tot changed pages = Pages Async Written + Pages Sync Written */
    /*                   + Pages Written around                     */
    /* Or  ???           = Pages Castout + Pages Wriiten around     */
    /*------------------------------------------------------------- */
 
    /*****************************/
    /* Processing the data read  */
    /*****************************/
 
    /* if there is a new bufferpool in the list */
    if qws10r7n > NbGBPEnt.0 then call record_gbp
    GBPGetPage.QBGLGN    = QBGLGG
    GBPXIReadRet.QBGLGN    = QBGLXD
    GBPXIReadNoRet.QBGLGN  = QBGLXR
    QBGLAW.QBGLGN  = QBGLAW
    QBGLSW.QBGLGN  = QBGLSW
    QBGLRC.QBGLGN  = QBGLRC
    QBGLWA.QBGLGN  = QBGLWA
    QBGLWX.QBGLGN  = QBGLWX
    QBGLAS.QBGLGN  = QBGLAS
 
    return
 
dsndqbst:
    numeric digits 15
    QBSTPID =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 8
    QBSTGET =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTRIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 40
    QBSTPWS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTWIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    QBSTRPI =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTWPI =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Open Dataset */
    QBSTDSO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTIMW =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* Pages read seq Prefetch */
    QBSTSPP =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 56
    /* OF SEQ PREFETCH (ASYNCHRONOUS) READ*/
    QBSTPIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* nb wkfile not created due to buffers resource */
    QBSTMAX =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 48
    /* nb of workfiles denied during sort/merge */
    QBSTWFD =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* nb of time sort not optimized due to BP shortage*/
    QBSTWFF =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 32
    /* nb of pages cast out  */
    QBSTPCO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* nb of cast out IO */
    QBSTCIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTVPL =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 24
    QBSTDIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTLIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTSGT =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    QBSTSIO =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs    =  Ofs +   112 /* 8*14*/
    /* Min SRLU */
    QBSTSMIN=  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Max SRLU */
    QBSTSMAX=  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Nb times SLRU = VPSEQT */
    QBSTHST =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Nb times Random getpage found in SRLU chain */
    QBSTRHS =  C2D(SUBSTR(InpRec,Ofs,8))
    if QWHSRN = 'B1' then /* V11*/
        Ofs = Ofs + 8
    else
        Ofs = Ofs + 40 /*V12*/
 
    /******************************/
    /* End of macro QBST DSNDQBST */
    /******************************/
 
         /* if there is a new bufferpool in the list */
         if qws10r3n > NbBPEnt.0 then call record_bp
         BufGet.QBSTPID = QBSTGET
         BufRIO.QBSTPID=  QBSTRIO
         BufPWS.QBSTPID=  QBSTPWS
         BufWIO.QBSTPID=  QBSTWIO
         BufRPI.QBSTPID=  QBSTRPI
         BufWPI.QBSTPID=  QBSTWPI
         BufIMW.QBSTPID=  QBSTIMW
         BufDSO.QBSTPID=  QBSTDSO
         BufPIO.QBSTPID=  QBSTPIO
         BufPCO.QBSTPID=  QBSTPCO
         BufCIO.QBSTPID=  QBSTCIO
         BufVPL.QBSTPID=  QBSTVPL
         BufDIO.QBSTPID=  QBSTDIO
         BufLIO.QBSTPID=  QBSTLIO
         BufSIO.QBSTPID=  QBSTSIO
         BufSGT.QBSTPID=  QBSTSGT
         BufMIN.QBSTPID=  QBSTSMIN
         BufMAX.QBSTPID=  QBSTSMAX
         BufHST.QBSTPID=  QBSTHST
         BufRHS.QBSTPID=  QBSTRHS
    /*        'QBSTRIO=' QBSTRIO,     */
    /*        'QBSTWIO=' QBSTWIO,     */
    /*        'QBSTIMW=' QBSTIMW,     */
    /*    say 'QBSTPIO=' QBSTPIO,     */
    /*        'QBSTCIO=' QBSTCIO,     */
    /*        'QBSTDIO=' QBSTDIO,     */
    /*        'QBSTLIO=' QBSTLIO,     */
    /*        'QBSTSIO=' QBSTSIO      */
    return
/*--------------------*/
/* Simulated BP stats */
/*--------------------*/
DSNDQBSP:
    numeric digits 20
    /* Bpool ID */
    QBSPPID =  C2D(SUBSTR(InpRec,Ofs,4))
    Ofs = Ofs + 4
    QBSPCON = C2X(SUBSTR(InpRec,Ofs,1))
    Ofs = Ofs + 4
    /* Current Number of pages simulated */
    QBSPIUS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* Current number of seq pages simulated */
    QBSPSUS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 16
    /* Random Sync read  */
    QBSPDRR =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Seq    Sync read  */
    QBSPDRS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Pages Async Reads */
    QBSPDRA =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* GBP Random Sync read  */
    QBSPGRR =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* GBP Seq Sync read  */
    QBSPGRS =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* GBP Pages Async Reads */
    QBSPGRA =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Pages moved into Simulated pool */
    QBSPMVI =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs = Ofs + 8
    /* Total wait for sync/IO  */
    QBSPDTM =  C2D(SUBSTR(InpRec,Ofs,8))
    Ofs    = Ofs    + 16 /* Yes, there is a bug */
 
    /* Check in simulated BP list */
    do i = 1 to Simbp_entry.0
              if QBSPPID = Simbp_entry.i then leave
    end
    /* not found => new entry */
    if i > Simbp_entry.0 then
           do
               Simbp_entry.0 = Simbp_entry.0 + 1
               j            = Simbp_entry.0
               Simbp_entry.j = QBSPPID
 
               SimPage.j = 0
               SimSeqPage.j = 0
               SimSyncIO.j = 0
               SimSeqSyncIO.j = 0
               SimAsyncPage.j = 0
               SimGBPSyncIO.j = 0
               SimGBPSeqSyncIO.j = 0
               SimGBPAsyncPage.j = 0
               SimPageMov.j = 0
               SimWaitSyncIO.j = 0
           end
 
    /* Check in simulated BP list */
    do i = 1 to Simbp_entry.0
              if QBSPPID = Simbp_entry.i then leave
    end
    /* not found => error  */
    if i > Simbp_entry.0 then
           do
               say 'Abnormal error '
               exit 8
           end
    /*-----------------------------------------------*/
    /* Difference between current and previous value */
    /*-----------------------------------------------*/
 
    /* Current Number of pages simulated */
    DifSimPage.i = QBSPIUS
    /* Current Number of seq pages simulated */
    DifSimSeqPage.i = QBSPSUS
    /* Random Sync read  */
    DifSimSyncIO.i = QBSPDRR - SimSyncIO.i
    /* Seq    Sync read  */
    DifSimSeqSyncIO.i = QBSPDRS - SimSeqSyncIO.i
    /* Pages Async Reads */
    DifSimAsyncPage.i = QBSPDRA - SimAsyncPage.i
    /* GBP Random Sync read  */
    DifSimGBPSyncIO.i = QBSPGRR - SimGBPSyncIO.i
    /* GBP Seq Sync read  */
    DifSimGBPSeqSyncIO.i = QBSPGRS - SimGBPSeqSyncIO.i
    /* GBP Pages Async Reads */
    DifSimGBPAsyncPage.i = QBSPGRA - SimGBPAsyncPage.i
    /* Pages moved into Simulated pool */
    DifSimPageMov.i = QBSPMVI - SimPageMov.i
    /* Total wait for sync/IO in ms  */
    DifSimWaitSyncIO.i = QBSPDTM - SimWaitSyncIO.i
 
    /*------------------------------------*/
    /* Save the values for next iteration */
    /* New => Previous                    */
    /*------------------------------------*/
    SimPage.i = QBSPIUS
    SimSeqPage.i = QBSPSUS
    SimSyncIO.i = QBSPDRR
    SimSeqSyncIO.i = QBSPDRS
    SimAsyncPage.i = QBSPDRA
    SimGBPSyncIO.i = QBSPGRR
    SimGBPSeqSyncIO.i = QBSPGRS
    SimGBPAsyncPage.i = QBSPGRA
    SimPageMov.i = QBSPMVI
    SimWaitSyncIO.i = QBSPDTM
 
    /******************************/
    /* End of macro QBST DSNDQBST */
    /******************************/
 
    return
ifcid_diff:
       /* Cumulative values, report only the difference */
       /* When diff is negative, this means that the value have been*/
       /* reset (Seen at DB2 restart , but probably also if they    */
       /* reach their max)                                          */
              Dif_QDSTPOOL=       QDSTPOOL      - Old_QDSTPOOL
              Dif_QDSTQDBT=       QDSTQDBT      - Old_QDSTQDBT
              Dif_QDSTQCRT=       QDSTQCRT      - Old_QDSTQCRT
              Dif_QDSTNDBA=       QDSTNDBA      - Old_QDSTNDBA
              Dif_MstrTcb =       MstrTcb       - Old_MstrTcb
              Dif_MstrSrb =       MstrSrb       - Old_MstrSrb
              Dif_MstrpSRB=       MstrpSRB      - Old_MstrpSRB
              Dif_MstrpSRB_ziip = MstrpSRB_ziip - Old_MstrpSRB_ziip
              Dif_dbm1Tcb =       dbm1Tcb       - Old_dbm1Tcb
              Dif_dbm1srb =       dbm1srb       - Old_dbm1srb
              Dif_dbm1pSRB=       dbm1pSRB      - Old_dbm1pSRB
              Dif_dbm1pSRB_ziip = dbm1pSRB_ziip - Old_dbm1pSRB_ziip
              Dif_irlmTcb =       irlmTcb       - Old_irlmTcb
              Dif_irlmsrb =       irlmsrb       - Old_irlmsrb
              Dif_irlmpSRB=       irlmpSRB      - Old_irlmpSRB
              Dif_irlmpSRB_ziip = irlmpSRB_ziip - Old_irlmpSRB_ziip
              Dif_DistTcb =       distTcb       - Old_DistTcb
              Dif_Distsrb =       distsrb       - Old_Distsrb
              Dif_DistpSRB=       distpSRB      - Old_DistpSRB
              Dif_DistpSRB_ziip = distpSRB_ziip - Old_DistpSRB_ziip
 
        if    Dif_MstrTcb < 0 then
        do
              say '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!§'
              say 'Cumulative fields reset, possible DB2 RECYCLE'
              say '      at' sm100dte run_fmt_time
              say '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!§'
              say ''
 
 
              Dif_QDSTPOOL=       QDSTPOOL
              Dif_QDSTQDBT=       QDSTQDBT
              Dif_QDSTQCRT=       QDSTQCRT
              Dif_QDSTNDBA=       QDSTNDBA
              Dif_MstrTcb =       MstrTcb
              Dif_MstrSrb =       MstrSrb
              Dif_MstrpSRB=       MstrpSRB
              Dif_MstrpSRB_ziip = MstrpSRB_ziip
              Dif_dbm1Tcb =       dbm1Tcb
              Dif_dbm1srb =       dbm1srb
              Dif_dbm1pSRB=       dbm1pSRB
              Dif_dbm1pSRB_ziip = dbm1pSRB_ziip
              Dif_irlmTcb =       irlmTcb
              Dif_irlmsrb =       irlmsrb
              Dif_irlmpSRB=       irlmpSRB
              Dif_irlmpSRB_ziip = irlmpSRB_ziip
              Dif_DistTcb =       distTcb
              Dif_Distsrb =       distsrb
              Dif_DistpSRB=       distpSRB
              Dif_DistpSRB_ziip = distpSRB_ziip
 
        end
              Old_QDSTPOOL=       QDSTPOOL
              Old_QDSTQDBT=       QDSTQDBT
              Old_QDSTQCRT=       QDSTQCRT
              Old_QDSTNDBA=       QDSTNDBA
              Old_Mstrtcb =       Mstrtcb
              Old_MstrSrb =       MstrSrb
              Old_MstrpSRB=       MstrpSRB
              Old_MstrpSRB_ziip = MstrpSRB_ziip
              Old_dbm1Tcb =       dbm1Tcb
              Old_dbm1srb =       dbm1srb
              Old_dbm1pSRB=       dbm1pSRB
              Old_dbm1pSRB_ziip = dbm1pSRB_ziip
              Old_irlmTcb =       irlmTcb
              Old_irlmsrb =       irlmsrb
              Old_irlmpSRB=       irlmpSRB
              Old_irlmpSRB_ziip = irlmpSRB_ziip
              Old_DistTcb =       distTcb
              Old_Distsrb =       distsrb
              Old_DistpSRB=       distpSRB
              Old_DistpSRB_ziip = distpSRB_ziip
 
       /*********************************/
       /* Subsystem services stats QTDS */
       /*********************************/
          Dif_QTABINDA=   QTABINDA -Old_QTABINDA
          Dif_QTABIND =   QTABIND  -Old_QTABIND
          Dif_QTAUCHK =   QTAUCHK  -Old_QTAUCHK
          Dif_QTAUSUC =   QTAUSUC  -Old_QTAUSUC
          Dif_QTAUCCH =   QTAUCCH  -Old_QTAUCCH
          Dif_QTPACAUT=   QTPACAUT -Old_QTPACAUT
          Dif_QTPACNOT=   QTPACNOT -Old_QTPACNOT
          Dif_QTAUTOBA=   QTAUTOBA -Old_QTAUTOBA
          Dif_QTPKABND=   QTPKABND -Old_QTPKABND
          Dif_QTDSDRN =     QTDSDRN-Old_QTDSDRN
          Dif_QTPCCT  =     QTPCCT -Old_QTPCCT
          Dif_QVLSLC14=    QVLSLC14-Old_QVLSLC14
          Dif_QVLSLC19=    QVLSLC19-Old_QVLSLC19
          Dif_QVLSLC24=    QVLSLC24-Old_QVLSLC24
          Dif_QVLSLC31=    QVLSLC31-Old_QVLSLC31
          Dif_QVLSLC32=    QVLSLC32-Old_QVLSLC32
          if  Dif_QTDSDRN < 0 then
          do
              Dif_QTABINDA=   QTABINDA
              Dif_QTABIND =   QTABIND
              Dif_QTAUCHK =   QTAUCHK
              Dif_QTAUSUC =   QTAUSUC
              Dif_QTAUCCH =   QTAUCCH
              Dif_QTPACAUT=   QTPACAUT
              Dif_QTPACNOT=   QTPACNOT
              Dif_QTAUTOBA=   QTAUTOBA
              Dif_QTPKABND=   QTPKABND
              Dif_QTDSDRN =   QTDSDRN
              Dif_QTPCCT  =   QTPCCT
              Dif_QVLSLC14=    QVLSLC14
              Dif_QVLSLC19=    QVLSLC19
              Dif_QVLSLC24=    QVLSLC24
              Dif_QVLSLC31=    QVLSLC31
              Dif_QVLSLC32=    QVLSLC32
          end
          Old_QTABINDA=   QTABINDA
          Old_QTABIND =   QTABIND
          Old_QTAUCHK =   QTAUCHK
          Old_QTAUSUC =   QTAUSUC
          Old_QTAUCCH =   QTAUCCH
          Old_QTPACAUT=   QTPACAUT
          Old_QTPACNOT=   QTPACNOT
          Old_QTAUTOBA=   QTAUTOBA
          Old_QTPKABND=   QTPKABND
          Old_QTDSDRN =   QTDSDRN
          Old_QTPCCT  =   QTPCCT
          Old_QVLSLC14=    QVLSLC14
          Old_QVLSLC19=    QVLSLC19
          Old_QVLSLC24=    QVLSLC24
          Old_QVLSLC31=    QVLSLC31
          Old_QVLSLC32=    QVLSLC32
       /*********************************/
       /* Subsystem services stats Q3ST */
       /*********************************/
              Dif_Q3STSIGN =     Q3STSIGN-Old_Q3STSIGN
              Dif_Q3STTERM =     Q3STTERM-Old_Q3STTERM
              Dif_Q3STCTHD =     Q3STCTHD-Old_Q3STCTHD
              Dif_Q3STPREP =     Q3STPREP-Old_Q3STPREP
              Dif_Q3STCOMM =     Q3STCOMM-Old_Q3STCOMM
              Dif_Q3STABRT =     Q3STABRT-Old_Q3STABRT
 
          if  Dif_Q3STCTHD < 0 then
          do
              Dif_Q3STSIGN = Q3STSIGN
              Dif_Q3STTERM = Q3STTERM
              Dif_Q3STCTHD = Q3STCTHD
              Dif_Q3STPREP = Q3STPREP
              Dif_Q3STCOMM = Q3STCOMM
              Dif_Q3STABRT = Q3STABRT
          end
 
          Old_Q3STSIGN = Q3STSIGN
          Old_Q3STTERM = Q3STTERM
          Old_Q3STCTHD = Q3STCTHD
          Old_Q3STPREP = Q3STPREP
          Old_Q3STCOMM = Q3STCOMM
          Old_Q3STABRT = Q3STABRT
 
       /***************************/
       /* buffer pool stats       */
       /***************************/
 
 
      /****************************************/
      /* dsndqjst Log  Manager stats IFCID 001*/
      /****************************************/
      Dif_QJSTWRNW = QJSTWRNW - Old_QJSTWRNW
      Dif_QJSTWRW = QJSTWRW - Old_QJSTWRW
      Dif_QJSTWRF  = QJSTWRF  - Old_QJSTWRF
      Dif_QJSTBFFL = QJSTBFFL - Old_QJSTBFFL
      Dif_QJSTWTB  = QJSTWTB  - Old_QJSTWTB
      Dif_QJSTCIOF = QJSTCIOF - Old_QJSTCIOF
      Dif_QJSTBPAG = QJSTBPAG - Old_QJSTBPAG
      Dif_QJSTRBUF = QJSTRBUF - Old_QJSTRBUF
      Dif_QJSTRACT = QJSTRACT - Old_QJSTRACT
      Dif_QJSTRARH = QJSTRARH - Old_QJSTRARH
      Dif_QJSTTVC  = QJSTTVC  - Old_QJSTTVC
      Dif_QJSTBSDS = QJSTBSDS - Old_QJSTBSDS
      if  Dif_QJSTBFFL < 0 then  do
              Dif_QJSTWRNW = QJSTWRNW
              Dif_QJSTWRW = QJSTWRW
              Dif_QJSTWRF  = QJSTWRF
              Dif_QJSTBFFL = QJSTBFFL
              Dif_QJSTRBUF = QJSTRBUF
              Dif_QJSTRACT = QJSTRACT
              Dif_QJSTRARH = QJSTRARH
              Dif_QJSTTVC  = QJSTTVC
              Dif_QJSTBSDS = QJSTBSDS
              Dif_QJSTCIOF = QJSTCIOF
              Dif_QJSTBPAG = QJSTBPAG
              Dif_QJSTWTB  = QJSTWTB
      end
      Old_QJSTWRNW = QJSTWRNW
      Old_QJSTWRW = QJSTWRW
      Old_QJSTWRF  = QJSTWRF
      Old_QJSTRBUF = QJSTRBUF
      Old_QJSTRACT = QJSTRACT
      Old_QJSTRARH = QJSTRARH
      Old_QJSTTVC  = QJSTTVC
      Old_QJSTBSDS = QJSTBSDS
      Old_QJSTBFFL = QJSTBFFL
      Old_QJSTWTB  = QJSTWTB
      Old_QJSTCIOF = QJSTCIOF
      Old_QJSTBPAG = QJSTBPAG
 
      /****************************************/
      /* dsndqist Data Manager stats IFCID 002 */
      /****************************************/
              Dif_QWSDCKPT = QWSDCKPT - Old_QWSDCKPT /*checkpoints*/
              Dif_QTXADEA  = QTXADEA  - Old_QTXADEA
              Dif_QTXASLOC = QTXASLOC - Old_QTXASLOC
              Dif_QTXATIM  = QTXATIM  - Old_QTXATIM
              Dif_QTXALES  = QTXALES  - Old_QTXALES
              Dif_QTXALEX  = QTXALEX  - Old_QTXALEX
              Dif_QTXANPL  = QTXANPL  - Old_QTXANPL
              Dif_QTXASLAT = QTXASLAT - Old_QTXASLAT
              Dif_QTXASOTH = QTXASOTH - Old_QTXASOTH
              Dif_QTXALOCK = QTXALOCK - Old_QTXALOCK
              Dif_QTXACLNO = QTXACLNO - Old_QTXACLNO
              Dif_QTXADRNO = QTXADRNO - Old_QTXADRNO
              Dif_QXSELECT = QXSELECT - Old_QXSELECT
              Dif_QXINSRT  = QXINSRT  - Old_QXINSRT
              Dif_QXUPDTE  = QXUPDTE  - Old_QXUPDTE
              Dif_QXDELET  = QXDELET  - Old_QXDELET
              Dif_QXFETCH  = QXFETCH  - Old_QXFETCH
              Dif_QXSTFND  = QXSTFND  - Old_QXSTFND
              Dif_QXSTNFND = QXSTNFND - Old_QXSTNFND
              Dif_QXSTIPRP = QXSTIPRP - Old_QXSTIPRP
              Dif_QXSTNPRP = QXSTNPRP - Old_QXSTNPRP
              Dif_QXSTDEXP = QXSTDEXP - Old_QXSTDEXP
              Dif_QXNSMIAP = QXNSMIAP - Old_QXNSMIAP
              Dif_QXMRMIAP = QXMRMIAP - Old_QXMRMIAP
              Dif_QXWFRIDS = QXWFRIDS - Old_QXWFRIDS
              Dif_QXWFRIDT = QXWFRIDT - Old_QXWFRIDT
              Dif_QXHJINCS = QXHJINCS - Old_QXHJINCS
              Dif_QXHJINCT = QXHJINCT - Old_QXHJINCT
              Dif_QXSISTOR = QXSISTOR - Old_QXSISTOR
              if  QWHSRN > 'B1' then
              do
         Dif_QXRWSINSRTDAlg1 = QXRWSINSRTDAlg1-Old_QXRWSINSRTDAlg1
         Dif_QXRWSINSRTDAlg2 = QXRWSINSRTDAlg2-Old_QXRWSINSRTDAlg2
         Dif_QXRSDMAD=QXRSDMAD-Old_QXRSDMAD
         Dif_QXRFMIAP=QXRFMIAP-Old_QXRFMIAP
              end
              Dif_QISECTG  = QISECTG  - Old_QISECTG
              Dif_QISECTL  = QISECTL  - Old_QISECTL
              Dif_QISEDBDG = QISEDBDG - Old_QISEDBDG
              Dif_QISEDBDL = QISEDBDL - Old_QISEDBDL
              Dif_QISEKTG  = QISEKTG  - Old_QISEKTG
              Dif_QISEKTL  = QISEKTL  - Old_QISEKTL
              Dif_QISEDSG  = QISEDSG  - Old_QISEDSG
              Dif_QISEDSI  = QISEDSI  - Old_QISEDSI
              Dif_QISTRLLM = QISTRLLM - Old_QISTRLLM
              Dif_QISTRPLM = QISTRPLM - Old_QISTRPLM
              Dif_QISTCOLS = QISTCOLS - Old_QISTCOLS
              Dif_QISTWFP1 = QISTWFP1 - Old_QISTWFP1
              Dif_QISTWFP2 = QISTWFP2 - Old_QISTWFP2
              Dif_QISTI2OF = QISTI2OF - Old_QISTI2OF
 
      if  Dif_QWSDCKPT <0 then
              Dif_QWSDCKPT = QWSDCKPT
 
      if  Dif_QXSELECT <0 then
      do
              Dif_QISTRLLM = QISTRLLM
              Dif_QISECTG  = QISECTG
              Dif_QISECTL  = QISECTL
              Dif_QISEDBDG = QISEDBDG
              Dif_QISEDBDL = QISEDBDL
              Dif_QISEKTG  = QISEKTG
              Dif_QISEKTL  = QISEKTL
              Dif_QISEDSG  = QISEDSG
              Dif_QISEDSI  = QISEDSI
              Dif_QTXADEA  = QTXADEA
              Dif_QTXASLOC = QTXASLOC
              Dif_QTXATIM  = QTXATIM
              Dif_QTXALES  = QTXALES
              Dif_QTXALEX  = QTXALEX
              Dif_QTXANPL  = QTXANPL
              Dif_QTXASLAT = QTXASLAT
              Dif_QTXASOTH = QTXASOTH
              Dif_QTXALOCK = QTXALOCK
              Dif_QTXACLNO = QTXACLNO
              Dif_QTXADRNO = QTXADRNO
              Dif_QXSELECT = QXSELECT
              Dif_QXINSRT  = QXINSRT
              Dif_QXUPDTE  = QXUPDTE
              Dif_QXDELET  = QXDELET
              Dif_QXFETCH  = QXFETCH
              Dif_QXSTFND  = QXSTFND
              Dif_QXSTNFND = QXSTNFND
              Dif_QXSTIPRP = QXSTIPRP
              Dif_QXSTNPRP = QXSTNPRP
              Dif_QXSTDEXP = QXSTDEXP
              Dif_QXNSMIAP = QXNSMIAP
              Dif_QXMRMIAP = QXMRMIAP
              Dif_QXWFRIDS = QXWFRIDS
              Dif_QXWFRIDT = QXWFRIDT
              Dif_QXHJINCS = QXHJINCS
              Dif_QXHJINCT = QXHJINCT
              Dif_QXSISTOR = QXSISTOR
              if  QWHSRN > 'B1' then
              do
                Dif_QXRWSINSRTDAlg1 = QXRWSINSRTDAlg1
                Dif_QXRWSINSRTDAlg2 = QXRWSINSRTDAlg2
                Dif_QXRSDMAD = QXRSDMAD
                Dif_QXRFMIAP = QXRFMIAP
              end
              Dif_QISTRPLM = QISTRPLM
              Dif_QISTCOLS = QISTCOLS
              Dif_QISTWFP1 = QISTWFP1
              Dif_QISTWFP2 = QISTWFP2
              Dif_QISTI2OF = QISTI2OF
      end
              Old_QWSDCKPT = QWSDCKPT
 
              Old_QISTRLLM = QISTRLLM
              Old_QISECTG  = QISECTG
              Old_QISECTL  = QISECTL
              Old_QISEDBDG = QISEDBDG
              Old_QISEDBDL = QISEDBDL
              Old_QISEKTG  = QISEKTG
              Old_QISEKTL  = QISEKTL
              Old_QISEDSG  = QISEDSG
              Old_QISEDSI  = QISEDSI
              Old_QTXADEA  = QTXADEA
              Old_QTXASLOC = QTXASLOC
              Old_QTXATIM  = QTXATIM
              Old_QTXALES  = QTXALES
              Old_QTXALEX  = QTXALEX
              Old_QTXANPL  = QTXANPL
              Old_QTXASLAT = QTXASLAT
              Old_QTXASOTH = QTXASOTH
              Old_QTXALOCK = QTXALOCK
              Old_QTXACLNO = QTXACLNO
              Old_QTXADRNO = QTXADRNO
              Old_QXSELECT = QXSELECT
              Old_QXINSRT  = QXINSRT
              Old_QXUPDTE  = QXUPDTE
              Old_QXDELET  = QXDELET
              Old_QXFETCH  = QXFETCH
              Old_QXSTFND  = QXSTFND
              Old_QXSTNFND = QXSTNFND
              Old_QXSTIPRP = QXSTIPRP
              Old_QXSTNPRP = QXSTNPRP
              Old_QXSTDEXP = QXSTDEXP
              Old_QXNSMIAP = QXNSMIAP
              Old_QXMRMIAP = QXMRMIAP
              Old_QXWFRIDS = QXWFRIDS
              Old_QXWFRIDT = QXWFRIDT
              Old_QXHJINCS = QXHJINCS
              Old_QXHJINCT = QXHJINCT
              Old_QXSISTOR = QXSISTOR
              if  QWHSRN > 'B1' then
              do
                Old_QXRWSINSRTDAlg1 = QXRWSINSRTDAlg1
                Old_QXRWSINSRTDAlg2 = QXRWSINSRTDAlg2
                Old_QXRSDMAD = QXRSDMAD
                Old_QXRFMIAP = QXRFMIAP
              end
              Old_QISTRPLM = QISTRPLM
              Old_QISTCOLS = QISTCOLS
              Old_QISTWFP1 = QISTWFP1
              Old_QISTWFP2 = QISTWFP2
              Old_QISTI2OF = QISTI2OF
 
      return
DispVStor:
  if vsm='Y' & reco > 0 then
  do
    Say ' '; say ' '
    Say 'Threads observed Max : ' MaxThdSee 'at' MaxThdSeeDate,
                                                 MaxThdSeeTime
    Say '                 Min : ' MinThdSee 'at' MinThdSeeDate,
                                                 MinThdSeeTime
    Say ' '; say ' '
    Say 'Max Threads allowed projected with this period is : '
    Say '    ' floor(MinThdComp) 'at' MinThdCompDate MinThdCompTime,
        '/' floor(MaxThdComp) 'at' MaxThdCompDate MaxThdCompTime
    Say '    Formula without Min/Max applied : '
    Say '    ' floor(MinThdComp2) 'at' MinThdComp2Date MinThdComp2Time,
        '/' floor(MaxThdComp2) 'at' MaxThdComp2Date MaxThdComp2Time
    Say ' '
    Say 'DBM1, Max Real Storage is : ' format(MaxReal4K_dbm1,5,2),
        'MB at ' Date_MaxReal4K_dbm1 time_MaxReal4K_dbm1
    Say '                   Min is : ' ,
                             format(MinReal4K_dbm1,5,2) 'MB at ',
           Date_MinReal4K_dbm1 time_MinReal4K_dbm1
    Say 'DIST, Max Real Storage is : ' format(MaxReal4K_Dist,5,2),
        'MB at ' Date_MaxReal4K_Dist time_MaxReal4K_Dist
    Say '                   Min is : ' ,
                          format(MinReal4K_Dist,5,2) 'MB at ',
         Date_MinReal4K_Dist time_MinReal4K_Dist
    Say ' '
 /* Say 'Max Real Storage used by LPAR :' MaxRealLPAR ' Frames --', */
 /*            f2mb(MaxRealLPAR)  ' in MB'                          */
 /* Say '       at ' time_MaxRealLPAR                               */
    temp=MinQW0225_REALAVAIL*4096 / 1048576      /* in MB*/
    Say 'Min Real Storage available for LPAR : ' MinQW0225_REALAVAIL,
                'Frames --' f2mb(MinQW0225_REALAVAIL) ' MB'
    Say '       at ' Date_MinQW0225_REALAVAIL time_MinQW0225_REALAVAIL
    Say ' '
    Say 'Max Aux Storage used by DB2  :' MaxDB2AuxUse ' Slots  --',
           f2mb(MaxDB2AuxUse)        ' MB'
    Say '       at ' DateMaxDB2AuxUse timeMaxDB2AuxUse
  end
return
init_var:
  if  QWHSRN > 'B1' then  /*v12*/
  do
      Dif_QXRWSINSRTDAlg1=0
      Dif_QXRWSINSRTDAlg2=0
      Dif_QXRFMIAP=0
  end
  nbr_ifcid=0
  GBPCount   =0
  HistCKPT.0 =0
  HistRWRO.0 =0
  tsayLocal=0
  tsayNoDDF=0
 
  /* nb of buffers recorded*/
  NbBPEnt.0=0
  NbGBPEnt.0=0
  /* nb of simulated buffers recorded*/
  SimBp_Entry.0=0
  if vsm='Y' then
      do
           MaxND=0
           MinAS=999999999999999
           MinTS=999999999999999
           MaxTF=0
           MaxThdSee =0
           MaxThdComp=0
           MaxThdComp2=0
           MinThdSee =999999999999999
           MinThdComp=999999999999999
           MinThdComp2=999999999999999
           MaxReal4K_dbm1=0
           MinReal4K_dbm1=999999999999999
           MaxReal4K_Dist=0
           MinReal4K_Dist=999999999999999
           MinQW0225_REALAVAIL=999999999999999
        /* MaxRealLPAR = 0 */
           MaxDB2AuxUse = -1
      end
  /* init counters */
  Old_QDSTPOOL= 0
  Old_QDSTQDBT= 0
  Old_QDSTQCRT= 0
  Old_QDSTNDBA= 0
  Old_QTABINDA= 0
  Old_QTABIND = 0
  Old_QTAUCHK = 0
  Old_QTAUSUC = 0
  Old_QTAUCCH = 0
  Old_QTPACAUT= 0
  Old_QTPACNOT= 0
  Old_QTAUTOBA= 0
  Old_QTPKABND= 0
  Old_QTDSDRN = 0
  Old_QTPCCT  = 0
  Old_QVLSLC14=  0
  Old_QVLSLC19=  0
  Old_QVLSLC24=  0
  Old_QVLSLC31=  0
  Old_QVLSLC32=  0
  Old_QBSTGET = 0
  Old_QBSTRIO = 0
  Old_QBSTPWS = 0
  Old_QBSTDSO = 0
  Old_QBSTIMW = 0
  Old_QBSTWIO = 0
  Old_QBSTRPI = 0
  Old_QBSTWPI = 0
  Old_QBSTPIO = 0
  Old_QBSTPCO = 0
  Old_QBSTCIO = 0
  Old_QBSTDIO = 0
  Old_QBSTLIO = 0
  Old_QBSTSIO = 0
  Old_QBSTSGT = 0
  Old_QBSTHST = 0
  Old_QBSTRHS = 0
 
  Old_QJSTBFFL  = 0
  Old_QJSTWRNW  = 0
  Old_QJSTWRW  = 0
  Old_QJSTRBUF = 0
  Old_QJSTRACT = 0
  Old_QJSTRARH = 0
  Old_QJSTTVC  = 0
  Old_QJSTBSDS = 0
  Old_QJSTWRF =0
  Old_QJSTWTB   = 0
  Old_QJSTCIOF  = 0
  Old_QJSTBPAG  = 0
 
  Old_QISTRLLM  = 0
  Old_QISECTG   = 0
  Old_QISECTL   = 0
  Old_QISEDBDG  = 0
  Old_QISEDBDL  = 0
  Old_QISEKTG   = 0
  Old_QISEKTL   = 0
  Old_QISEDSG   = 0
  Old_QISEDSI   = 0
  Old_QWSDCKPT  = 0
  Old_QTXADEA   = 0
  Old_QTXASLOC  = 0
  Old_QTXATIM   = 0
  Old_QTXALES   = 0
  Old_QTXALEX   = 0
  Old_QTXANPL   = 0
  Old_QTXASLAT  = 0
  Old_QTXASOTH  = 0
  Old_QTXALOCK  = 0
  Old_QTXACLNO  = 0
  Old_QTXADRNO  = 0
  Old_QXSELECT  = 0
  Old_QXINSRT   = 0
  Old_QXUPDTE   = 0
  Old_QXDELET   = 0
  Old_QXFETCH   = 0
  Old_QXNSMIAP  = 0
  Old_QXSTFND   = 0
  Old_QXSTNFND  = 0
  Old_QXSTIPRP  = 0
  Old_QXSTNPRP  = 0
  Old_QXSTDEXP  = 0
  Old_QXMRMIAP  = 0
  Old_QXWFRIDS  = 0
  Old_QXWFRIDT  = 0
  Old_QXHJINCS  = 0
  Old_QXHJINCT  = 0
  Old_QXSISTOR = 0
  Old_QXRWSINSRTDAlg1 = 0
  Old_QXRWSINSRTDAlg2 = 0
  Old_QXRSDMAD = 0
  Old_QXRFMIAP = 0
  Old_QISTRPLM  = 0
  Old_QISTCOLS  = 0
  Old_QISTWFP1  = 0
  Old_QISTWFP2  = 0
  Old_QISTI2OF  = 0
 
  Old_Q3STSIGN = 0
  Old_Q3STTERM = 0
  Old_Q3STCTHD = 0
  Old_Q3STPREP = 0
  Old_Q3STCOMM = 0
  Old_Q3STABRT = 0
 
 
  Old_MstrTcb =       0
  Old_MstrSrb =       0
  Old_MstrpSRB=       0
  Old_MstrpSRB_ziip = 0
  Old_dbm1Tcb =       0
  Old_dbm1srb =       0
  Old_dbm1pSRB=       0
  Old_dbm1pSRB_ziip = 0
  Old_irlmTcb =       0
  Old_irlmsrb =       0
  Old_irlmpSRB=       0
  Old_irlmpSRB_ziip = 0
  Old_DistTcb =       0
  Old_Distsrb =       0
  Old_DistpSRB=       0
  Old_DistpSRB_ziip = 0
 
 
  /* compteurs input/output */
  reco= 0
  reci= 0
  recs= 0
 
  min_time ='26:00:00'
  max_time ='ZZ:00:00'
  min_date ='2100.000'
  max_date ='1900.000'
  /* reinit IFCID 2 data */
  call DSNDQXST0
  return
 
FLOOR: procedure
parse arg F
return TRUNC(F) - (F < 0) * (F <> TRUNC(F))
 
CEIL: procedure
parse arg C
return TRUNC(C) + (C > 0) * (C <> TRUNC(C))
/* convert 4K frames to MB */
f2mb:
 arg num
 num = format(num*4/1024,,2)
 return num
/* convert bytes to MB */
b2mb:
 arg num
 num = format(num/1048576,,0)
 return num
comp_sum_bpstats:
        /* we have all the stats for each bpid */
        /* now compare with old value to get the Dif and then*/
        /* have the sum */
         do i = 1 to NbBPEnt.0
            j = NbBPEnt.i
            /*--*/
            /* if value is given by DB2 */
            if  BufGET.j > 0  then
            do
                 Diff= BufGet.j- OBufGet.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufGet.j
                      Sum_QBSTGET = 0
                 end
                 Det_GET.j =  Diff
                 Sum_QBSTGET = Sum_QBSTGET + Diff
                 /*--*/
                 Diff= BufRIO.j- OBufRIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufRIO.j
                      Sum_QBSTRIO = 0
                 end
                 Det_RIO.j =  Diff
                 Sum_QBSTRIO = Sum_QBSTRIO + Diff
                 /*--*/
                 Diff= BufPWS.j- OBufPWS.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufPWS.j
                      Sum_QBSTPWS = 0
                 end
                 Det_PWS.j =  Diff
                 Sum_QBSTPWS = Sum_QBSTPWS + Diff
                 /*--*/
                 Diff= BufIMW.j- OBufIMW.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufIMW.j
                      Sum_QBSTIMW = 0
                 end
                 Det_IMW.j =  Diff
                 Sum_QBSTIMW = Sum_QBSTIMW + Diff
                 /*--*/
                 Diff= BufDSO.j- OBufDSO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufDSO.j
                      Sum_QBSTDSO = 0
                 end
                 Det_DSO.j =  Diff
                 Sum_QBSTDSO = Sum_QBSTDSO + Diff
                 /*--*/
                 Diff= BufWIO.j- OBufWIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufWIO.j
                      Sum_QBSTWIO = 0
                 end
                 Det_WIO.j =  Diff
                 Sum_QBSTWIO = Sum_QBSTWIO + Diff
                 /*--*/
                 Diff= BufRPI.j- OBufRPI.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufRPI.j
                      Sum_QBSTRPI = 0
                 end
                 Det_RPI.j =  Diff
                 Sum_QBSTRPI = Sum_QBSTRPI + Diff
                 /*--*/
                 Diff= BufWPI.j- OBufWPI.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufWPI.j
                      Sum_QBSTWPI = 0
                 end
                 Det_WPI.j =  Diff
                 Sum_QBSTWPI = Sum_QBSTWPI + Diff
                 /*--*/
                 Diff= BufPIO.j- OBufPIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufPIO.j
                      Sum_QBSTPIO = 0
                 end
                 Det_PIO.j =  Diff
                 Sum_QBSTPIO = Sum_QBSTPIO + Diff
                 /*--*/
                 Diff= BufPCO.j- OBufPCO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufPCO.j
                      Sum_QBSTPCO = 0
                 end
                 Det_PCO.j =  Diff
                 Sum_QBSTPCO = Sum_QBSTPCO + Diff
                 /*--*/
                 Diff= BufCIO.j- OBufCIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufCIO.j
                      Sum_QBSTCIO = 0
                 end
                 Det_CIO.j =  Diff
                 Sum_QBSTCIO = Sum_QBSTCIO + Diff
                 /*--*/
                 Diff= BufDIO.j- OBufDIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufDIO.j
                      Sum_QBSTDIO = 0
                 end
                 Det_DIO.j =  Diff
                 Sum_QBSTDIO = Sum_QBSTDIO + Diff
                 /*--*/
                 Diff= BufLIO.j- OBufLIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufLIO.j
                      Sum_QBSTLIO = 0
                 end
                 Det_LIO.j =  Diff
                 Sum_QBSTLIO = Sum_QBSTLIO + Diff
                 /*--*/
                 Diff= BufSGT.j- OBufSGT.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufSGT.j
                      Sum_QBSTSGT = 0
                 end
                 Det_SGT.j =  Diff
                 Sum_QBSTSGT = Sum_QBSTSGT + Diff
                 /*--*/
                 Diff= BufSIO.j- OBufSIO.j
                 /* db2 recycle */
                 if Diff < 0 then
                 do
                      Diff= BufSIO.j
                      Sum_QBSTSIO = 0
                 end
                 Det_SIO.j =  Diff
                 Sum_QBSTSIO = Sum_QBSTSIO + Diff
                 /*--*/
                 Diff= BufHST.j- OBufHST.j
                 /* db2 recycle */
                 if Diff < 0 then
                      Diff= BufHST.j
                 Det_HST.j =  Diff
                 /*--*/
                 Diff= BufRHS.j- OBufRHS.j
                 /* db2 recycle */
                 if Diff < 0 then
                      Diff= BufRHS.j
                 Det_RHS.j =  Diff
                 /*--*/
            end
            else
            do
                 Det_GET.j = 0
                 Det_RIO.j = 0
                 Det_PWS.j = 0
                 Det_IMW.j = 0
                 Det_DSO.j = 0
                 Det_WIO.j = 0
                 Det_RPI.j = 0
                 Det_WPI.j = 0
                 Det_PIO.j = 0
                 Det_PCO.j = 0
                 Det_CIO.j = 0
                 Det_DIO.j = 0
                 Det_LIO.j = 0
                 Det_SIO.j = 0
                 Det_SGT.j = 0
                 Det_HST.j = 0
                 Det_RHS.j = 0
            end
         end
   return
comp_diff_gbpstats:
        /* We have all the stats for each bpid */
        /* now compare with old value to get the Dif */
         GBPCount = GBPCount+1
         do i = 1 to NbGBPEnt.0
            j = NbGBPEnt.i
            /*--*/
            /* if value is given in the SMF record */
            if  GBPGetpage.j > 0  then
            do
                 Dif_GBPGetpage.j= GBPGetpage.j - oGBPGetpage.j
                 if Dif_GBPGetpage.j < 0 then
                 do
                      Dif_GBPGetpage.j= GBPGetpage.j
                 end
                 /*--*/
                 Dif_GBPXIReadRet.j= GBPXIReadRet.j -,
                                      oGBPXIReadRet.j
                 if Dif_GBPXIReadRet.j < 0 then
                 do
                      Dif_GBPXIReadRet.j= GBPXIReadRet.j
                 end
                 /*--*/
                 Dif_GBPXIReadNoRet.j= GBPXIReadNoRet.j -,
                                      oGBPXIReadNoRet.j
                 if Dif_GBPXIReadNoRet.j < 0 then
                 do
                 end
                 /*--*/
                 Dif_QBGLAW.j= QBGLAW.j - oQBGLAW.j
                 if Dif_QBGLAW.j < 0 then
                 do
                      Dif_QBGLAW.j= QBGLAW.j
                 end
                 /*--*/
                 Dif_QBGLSW.j= QBGLSW.j - oQBGLSW.j
                 if Dif_QBGLSW.j < 0 then
                 do
                      Dif_QBGLSW.j= QBGLSW.j
                 end
                 /*--*/
                 Dif_QBGLRC.j= QBGLRC.j - oQBGLRC.j
                 if Dif_QBGLRC.j < 0 then
                 do
                      Dif_QBGLRC.j= QBGLRC.j
                 end
                 /*--*/
                 Dif_QBGLWA.j= QBGLWA.j - oQBGLWA.j
                 if Dif_QBGLWA.j < 0 then
                 do
                      Dif_QBGLWA.j= QBGLWA.j
                 end
                 /*--*/
                 Dif_QBGLWX.j= QBGLWX.j - oQBGLWX.j
                 if Dif_QBGLWX.j < 0 then
                 do
                      Dif_QBGLWX.j= QBGLWX.j
                 end
                 /*--*/
                 Dif_QBGLAS.j= QBGLAS.j - oQBGLAS.j
                 if Dif_QBGLAS.j < 0 then
                 do
                      Dif_QBGLAS.j= QBGLAS.j
                 end
            end
            else
            do
                 Dif_GBPGetPage.j =  0
                 Dif_GBPXIReadRet.j =  0
                 Dif_GBPXIReadNoRet.j =  0
                 Dif_QBGLAW.j =  0
                 Dif_QBGLSW.j =  0
                 Dif_QBGLRC.j =  0
                 Dif_QBGLWA.j =  0
                 Dif_QBGLWX.j =  0
                 Dif_QBGLAS.j =  0
            end
            /* compute sum for every 15 values = 15 minutes */
            /* not a rolling average because too much CPU for usage*/
            Sum_GBPXIReadRet.j   =  Sum_GBPXIReadRet.j +,
                          Dif_GBPXIReadRet.j
            Sum_GBPXIReadNoRet.j =  Sum_GBPXIReadNoRet.j +,
                          Dif_GBPXIReadNoRet.j
            if GBPCount = 15 then
            do
               GBPXIMissRatio.j = Sum_GBPXIReadNoRet.j /,
                      (1+Sum_GBPXIReadNoRet.j + Sum_GBPXIReadRet.j)
               Sum_GBPXIReadRet.j   =  Dif_GBPXIReadRet.j
               Sum_GBPXIReadNoRet.j =  Dif_GBPXIReadNoRet.j
               GBPCount=0
            end
            else GBPXIMissRatio.j=0
         end /* loop */
   return
init_sum_bpstats:
          Sum_QBSTGET = 0
          Sum_QBSTRIO = 0
          Sum_QBSTPWS = 0
          Sum_QBSTIMW = 0
          Sum_QBSTDSO = 0
          Sum_QBSTWIO = 0
          Sum_QBSTRPI = 0
          Sum_QBSTWPI = 0
          Sum_QBSTPIO = 0
          Sum_QBSTPCO = 0
          Sum_QBSTCIO = 0
          Sum_QBSTDIO = 0
          Sum_QBSTLIO = 0
          Sum_QBSTSGT = 0
          Sum_QBSTSIO = 0
 
         /* raz all figures for all bufferpool */
         do i = 1 to NbBPEnt.0
            j = NbBPEnt.i
            BufGet.j = 0
            BufRIO.j = 0
            BufPWs.j = 0
            BufIMW.j = 0
            BufDSO.j = 0
            BufWIO.j = 0
            BufRPI.j = 0
            BufWPI.j = 0
            BufPIO.j = 0
            BufPCO.j = 0
            BufCIO.j = 0
            BufVPL.j = 0
            BufDIO.j = 0
            BufLIO.j = 0
            BufSGT.j = 0
            BufSIO.j = 0
            BufHST.j = 0
            BufRHS.j = 0
         end
     return
init_gbpstats:
         /* raz all figures for all bufferpool */
         do i = 1 to NbGBPEnt.0
            j = NbGBPEnt.i
            GBPGetpage.j=0
            GBPXIReadRet.j=0
            GBPXIReadNoRet.j=0
            QBGLAW.j=0
            QBGLSW.j=0
            QBGLRC.j=0
            QBGLWA.j=0
            QBGLWX.j=0
            QBGLAS.j=0
         end
     return
switch_bpstats:
         /* new to Old only if new value exists */
      if BufGet.j > 0  then do
         do i = 1 to NbBPEnt.0
            j = NbBPEnt.i
            oBufGet.j = BufGet.j
            oBufRIO.j = BufRIO.j
            oBufPWS.j = BufPWS.j
            oBufIMW.j = BufIMW.j
            oBufDSO.j = BufDSO.j
            oBufWIO.j = BufWIO.j
            oBufRPI.j = BufRPI.j
            oBufWPI.j = BufWPI.j
            oBufPIO.j = BufPIO.j
            oBufPCO.j = BufPCO.j
            oBufCIO.j = BufCIO.j
            oBufDIO.j = BufDIO.j
            oBufLIO.j = BufLIO.j
            oBufSGT.j = BufSGT.j
            oBufSIO.j = BufSIO.j
            oBufHST.j = BufHST.j
            oBufRHS.j = BufRHS.j
         end   /* end do */
      end /* end if ...*/
     return
switch_bpstatx:
         /* new to Old only if new value exists */
         do i = 1 to NbBPEnt.0
            j = NbBPEnt.i
            if BufGet.j > 0  then do
              oBufGet.j = BufGet.j
              oBufRIO.j = BufRIO.j
              oBufPWS.j = BufPWS.j
              oBufIMW.j = BufIMW.j
              oBufDSO.j = BufDSO.j
              oBufWIO.j = BufWIO.j
              oBufRPI.j = BufRPI.j
              oBufWPI.j = BufWPI.j
              oBufPIO.j = BufPIO.j
              oBufPCO.j = BufPCO.j
              oBufCIO.j = BufCIO.j
              oBufDIO.j = BufDIO.j
              oBufLIO.j = BufLIO.j
              oBufSGT.j = BufSGT.j
              oBufSIO.j = BufSIO.j
              oBufHST.j = BufHST.j
              oBufRHS.j = BufRHS.j
            end   /* end if */
         end /* end do ...*/
     return
switch_gbpstats:
         /* new to Old only if new value exists */
         do i = 1 to NbGBPEnt.0
            j = NbGBPEnt.i
            if GBPGetPage.j > 0 then do
               oGBPGetPage.j  =GBPGetPage.j
               oGBPXIReadRet.j  =GBPXIReadRet.j
               oGBPXIReadNoRet.j=GBPXIReadNoRet.j
               oQBGLAW.j=QBGLAW.j
               oQBGLSW.j=QBGLSW.j
               oQBGLRC.j=QBGLRC.j
               oQBGLWA.j=QBGLWA.j
               oQBGLWX.j=QBGLWX.j
               oQBGLAS.j=QBGLAS.j
            end
         end   /* end do */
     return
record_bp:
     /* add a new bufferpool id in the list */
           do i = 1 to NbBPEnt.0
              if QBSTPID = NbBPEnt.i then leave
           end
           /* not found => new entry */
           if i > NbBPEnt.0 then
           do
               NbBPEnt.0 = NbBPEnt.0 + 1
               j            = NbBPEnt.0
               NbBPEnt.j = QBSTPID
 
               oBufGet.QBSTPID = 0
               oBufRIO.QBSTPID = 0
               oBufPWS.QBSTPID = 0
               oBufIMW.QBSTPID = 0
               oBufDSO.QBSTPID = 0
               oBufWIO.QBSTPID = 0
               oBufRPI.QBSTPID = 0
               oBufWPI.QBSTPID = 0
               oBufPIO.QBSTPID = 0
               oBufPCO.QBSTPID = 0
               oBufCIO.QBSTPID = 0
               oBufDIO.QBSTPID = 0
               oBufLIO.QBSTPID = 0
               oBufSIO.QBSTPID = 0
               oBufSGT.QBSTPID = 0
               oBufHST.QBSTPID = 0
               oBufRHS.QBSTPID = 0
           end
   return
record_gbp:
     /* add a new bufferpool id in the list */
           do i = 1 to NbGBPEnt.0
              if QBGLGN  = NbGBPEnt.i then leave
           end
           /* not found => new entry */
           if i > NbGBPEnt.0 then
           do
               NbGBPEnt.0 = NbGBPEnt.0 + 1
               j            = NbGBPEnt.0
               NbGBPEnt.j = QBGLGN
               oGBPGetPage.QBGLGN  = 0
               oGBPXIReadRet.QBGLGN  = 0
               oGBPXIReadNoRet.QBGLGN  = 0
               oQBGLAW.QBGLGN  = 0
               oQBGLSW.QBGLGN  = 0
               oQBGLRC.QBGLGN  = 0
               oQBGLWA.QBGLGN  = 0
               oQBGLWX.QBGLGN  = 0
               oQBGLAS.QBGLGN  = 0
               Sum_GBPXIReadRet.QBGLGN  = 0
               Sum_GBPXIReadNoRet.QBGLGN  = 0
           end
   return
/********************************************************/
/* Check individual parameters for best practices alert */
/* (Checkcounters)                                      */
/********************************************************/
CheckForAlert:
    /*************************************/
    /*  V12 features                     */
    /*************************************/
    if  QWHSRN  > 'B1' then  /* V12 */
    do
      /* Insert Algorithm 2 usage */
      if Dif_QXRWSINSRTDAlg2 > 0 then
          do
             say 'Insert Algoritm 2 is used',
             '£'Dif_QXRWSINSRTDAlg2' à' substr(run_fmt_time,1,5)
          end
      /* FTB Usage */
      if (QISTFTBNUMC - QISTFTBCAN) > 0 then
          do
             say 'FTB Usage not optimal : Current is' QISTFTBNUMC,
             'Candidates is:' QISTFTBCAN' à' substr(run_fmt_time,1,5)
          end
      /* RiDList not done  */
      if Dif_QXRFMIAP> 0     then
          do
             say 'Warning : RID list processing was not used',
             '£'Dif_QXRFMIAP' à' substr(run_fmt_time,1,5)
             retcode=6
          end
    End   /* End V12 feature */
    /*************************************/
    /*  End DB2 12                       */
    /*************************************/
 
    /* No space to create SPARSE IX BUILT WF */
    /* Source V11 Transaction Monitoring Redbook */
    if Dif_QXSISTOR> 0     then
        do
           say 'Warning : No space to create Sparse Ix WF',
           '£'Dif_QXSISTOR' à' substr(run_fmt_time,1,5)
           retcode=6
        end
    /* RiD list no workfile */
    if Dif_QXWFRIDS> 0     then
        do
           say 'Warning : RID goes to workfile, no storage RIDPOOL',
           '£'Dif_QXWFRIDS' à' substr(run_fmt_time,1,5)
           retcode=6
        end
    /* Auth cache PLan */
    if Dif_QTAUCHK > 1000  then
    do
        Hit= Dif_QTAUCCH/(Dif_QTAUSUC+0.01)
        if Hit < 0.8  then
           do
             say 'Warning :Plan cache hit too low',
             format(Hit,2,2)' à' substr(run_fmt_time,1,5),
             'OK W/Cache:'Dif_QTAUCCH 'Success:'Dif_QTAUSUC,
             'Total checks:' Dif_QTAUCHK
             retcode=6
           end
    end
    /* Auth cache Pack */
    if (Dif_QTPACAUT+Dif_QTPACNOT) > 1000 then
    do
        Hit= 1- Dif_QTPACNOT/(Dif_QTPACAUT+0.01)
        if Hit < 0.8  & Hit > 0 then
           do
             say 'Warning :Pack cache hit too low',
        strip(format(Hit,4,2))' à' substr(run_fmt_time,1,5),
             '-OK W/o cache:'Dif_QTPACNOT,
             '-Success:'Dif_QTPACAUT
             retcode=6
           end
    end
    /* Autobind failed */
    if Dif_QTABIND < Dif_QTABINDA   then
       do
         say 'Warning :Autobind Plan failed',
         ' à' substr(run_fmt_time,1,5),
         '£Bind attemps:'Dif_QTABINDA,
         '£Bind success:'Dif_QTABIND
         retcode=6
       end
    if Dif_QTAUTOBA >Dif_QTPKABND   then
       do
         say 'Warning :Autobind Pack failed',
         ' à' substr(run_fmt_time,1,5),
         '£Bind attemps:'Dif_QTAUTOBA,
         '£Bind success:'Dif_QTPKABND
         retcode=6
       end
    /* Drain Close  */
    if Dif_QTDSDRN  > 0 then
             do
               say 'Warning : Drain Close DSMAX reached.',
               Dif_QTDSDRN  ' à' substr(run_fmt_time,1,5)
               retcode=6
             end
    /* Latch classes*/
    /* Put in stem for automatic processing */
    LCcl.1 = 14 /* Bufferpool LRU */
    LCVal.1=Dif_QVLSLC14
    LCcl.2 = 19 /* Log write */
    LCVal.2=Dif_QVLSLC19
    LCcl.3 = 24  /* EDM thread alloc, BM prefetch, unlatch serial.*/
    LCVal.3=Dif_QVLSLC24
    LCcl.4 = 31 /* Storage manager */
    LCVal.4=Dif_QVLSLC31
    LCcl.5 = 32 /* Storage manager */
    LCVal.5=Dif_QVLSLC32
    do i = 1 to 5
       if LCVal.i > 60000 then /* alerts if > 1000 events/s */
       do
         say 'Warning : Latch class' Lccl.i '> 1000/s',
         LCVal.i      ' à' substr(run_fmt_time,1,5)
         retcode=6
       end
    end i
    /* 32k used 4k preferred */
    if Dif_QISTWFP1 > 0 then
             do
               say 'Warning : Workfile - 32K used 4K preferred.',
               Dif_QISTWFP1 ' à' substr(run_fmt_time,1,5)
               retcode=6
             end
    /* 4K  used 32K preferred */
    if Dif_QISTWFP2 > 0 then
             do
               say 'Warning : Workfile - 4K used 32K preferred.',
               Dif_QISTWFP2 ' à' substr(run_fmt_time,1,5)
               retcode=6
             end
    /* Log Output Buffer unavailable */
    if Dif_QJSTWTB  > 0 then
             do
               say 'Warning : Wait - Log Output Buffer Unavail.',
               Dif_QJSTWTB  ' à' substr(run_fmt_time,1,5)
               retcode=6
             end
    /* Log Output Buffer Page In     */
    if Dif_QJSTBPAG > 0 then
             do
               say 'Warning : Log Output Buffer Page In',
             Dif_QJSTBPAG   ' à' substr(run_fmt_time,1,5)
               retcode=6
             end
    /* MAXDBAT reached */
    if Dif_QDSTQDBT > 0 then
             do
               say 'Warning : MAXDBAT reached, DBAT queued :',
                  Dif_QDSTQDBT  ' à' substr(run_fmt_time,1,5)
               retcode=6
             end
    if Dif_QDSTQCRT > 0 then
             do
               say 'Warning : CONDBAT reached, Conn rejected :',
                  Dif_QDSTQCRT ' à' substr(run_fmt_time,1,5)
               retcode=6
             end
    if QDSTNQR2 > 0 & QDSTNQAV > 0.01 then
             do
               say 'Warning : Type2 queued too long,£:' !!,
               QDSTNQR2 ' à' substr(run_fmt_time,1,5) ,
               '- Avg wait:'QDSTNQAV
               retcode=6
             end
    /* Global Dynamic Stmt cache hit ratio > 90% */
    if (Dif_QXSTFND+Dif_QXSTNFND) > 100 then do
        Hit = Dif_QXSTFND / (Dif_QXSTFND+Dif_QXSTNFND + 0.01)
        if Hit < 0.90 then
                 do
                   say 'Warning : Global Dyn. Cache Hit < 90%',
                      format(Hit,3,2) ' à' substr(run_fmt_time,1,5)
                   retcode=4
                 end
    end
    if (Dif_QXSTNPRP + Dif_QXSTIPRP) > 100 then do
    /* Local  Dynamic Stmt cache hit ratio > 70% */
    /* Source Optimizing DB2 System Performance using db2 statistics*/
        Hit = Dif_QXSTNPRP/ (Dif_QXSTNPRP + Dif_QXSTIPRP + 0.01)
        if Hit = 0   then do
               if tsaylocal=0 then do
                 say 'Warning : Local Dyn. Cache probably not used'
                 tsayLocal = 1
               end
        end
        else if Hit < 0.70 then
                 do
                   say 'Warning : Local Dyn. Cache Hit < 70%',
                      format(Hit,3,2) ' à' substr(run_fmt_time,1,5)
                   retcode=4
                 end
    end
    /* Checkpoints */
       period= 15
       if HistCKPT.0 < period then
       do
          /* store the value for sliding */
          HistCKPT.0 = HistCKPT.0 + 1
          j=HistCKPT.0
          HistCKPT.j = Dif_QWSDCKPT
       end
       else do /* decaler pour prendre que les 15 dernieres */
          i=1
          sum=0
          do until i= period
              j=i+1
              HistCKPT.i = HistCKPT.j
              sum = sum+HistCKPT.j
              i=i+1
          end
          HistCKPT.i = Dif_QWSDCKPT  /*i= period */
          sum = sum+HistCKPT.i
          if sum  > 9 then /* 1 checkpoint each 5/10 mn is OK */
             do
               say 'Warning : Checkpoint frequency too high' sum,
                   'for' period 'minutes à' substr(run_fmt_time,1,5)
               retcode=4
             end
       end
 
    /* RWRO Switch */
       period= 5
       if HistRWRO.0 < period then
       do
          HistRWRO.0 = HistRWRO.0 + 1
          j=HistRWRO.0
          HistRWRO.j = Dif_QTPCCT
       end
       else do /* push stack */
          i=1
          sum=0
          do until i= period
              j=i+1
              HistRWRO.i = HistRWRO.j
              sum = sum+HistRWRO.j
              i=i+1
          end
          HistRWRO.i = Dif_QTPCCT    /*i= period */
          sum = sum+HistRWRO.i
          /* 15 switch per minute is acceptable */
          if sum  > (15* period)  & Dif_Dbm1Srb >5 then
             do
               say 'Warning : RWRO switch too high' sum,
                   'for' period 'minutes à' substr(run_fmt_time,1,5),
                   'Dbm1Srb:'Dif_Dbm1Srb
               retcode=4
             end
       end
    /* Page Ins    */
          if (Sum_QBSTRPI  > 0 §  Sum_QBSTWPI > 0),
             & Sum_QBSTRIO/60 > 600 then
             do
               say 'Warning : Page in for Read/Write happened',
                   ' à' substr(run_fmt_time,1,5) ,
                   Sum_QBSTRPI Sum_QBSTWPI,
                   'SyncIO/s:' format(Sum_QBSTRIO/60,5,0)
               retcode=4
             end
 return
record_ifcid:
   found=0
   do i = 1 to nbr_ifcid
      if ifcid_st.i = ifcid then
         do
            found=1
            ifcid_count.i=ifcid_count.i+1
            leave
         end
   end
   /* not found : add new ifcid to list*/
   if found=0 then
      do
         nbr_ifcid = nbr_ifcid + 1
         ifcid_st.nbr_ifcid = ifcid
         ifcid_count.nbr_ifcid = 1
      end
   return
report_ifcid:
  say ' '
  say 'List of IFCIDS read in this SMF file :' nbr_ifcid
  say 'IFCID/Description/Count'
  do i=1 to nbr_ifcid
      Select
           When ifcid_st.i = 01 then
                      ifcid_desc='System stats - processed'
           When ifcid_st.i = 02 then
                      ifcid_desc='DB2 stats'
           When ifcid_st.i = 202 then
                      ifcid_desc='BP attributes'
           When ifcid_st.i = 230 then
                      ifcid_desc='GBP attributes'
           When ifcid_st.i = 225 then
                      ifcid_desc='Storage Stats'
           When ifcid_st.i = 402 then
                      ifcid_desc='Profile Stats'
           otherwise
                      ifcid_desc='Unknow'
 
      end   /* select */
     say ifcid_st.i  ifcid_desc ifcid_count.i
   end /* end do */
   say ' '
   return
/*---------------------------------------*/
/* Date functions from Chuck Meyer paper */
/*---------------------------------------*/
/*---------------------*/
/* yyyyddd => yyyymmdd */
/*---------------------*/
DAT_MVS2SD: Procedure
Parse Value REVERSE(arg(1)) With 1 j +3 y
Parse Value REVERSE(j y) With y j
If LENGTH(y) = 2 Then y = YY2YYYY(y)
months = '31' (28 + LY?(y)) ,
'31 30 31 30 31 31 30 31 30 31'
Do m = 1 To 12 While j > WORD(months,m)
j = j - WORD(months,m)
End
Return RIGHT(y,4,0) !! RIGHT(m,2,0) !! RIGHT(j,2,0)
/*---------------------*/
/* Is this leap year ? */
/*---------------------*/
LY?: Procedure
Parse Arg 1 y +4
Return ((y//4)=0)
stck:
Arg TUNITS
  TIMESTAMP = Copies(0,26)  /* force result length=26 */
  Address linkpgm "BLSUXTOD TUNITS TIMESTAMP"
  /* variable Timestamp has the value of timestamp */
  TSDate=substr(timestamp,1,10)
  TSTime=substr(timestamp,12,08)
  return
